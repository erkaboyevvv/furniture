
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Colors
 * 
 */
export type Colors = $Result.DefaultSelection<Prisma.$ColorsPayload>
/**
 * Model Materials
 * 
 */
export type Materials = $Result.DefaultSelection<Prisma.$MaterialsPayload>
/**
 * Model RoomTypes
 * 
 */
export type RoomTypes = $Result.DefaultSelection<Prisma.$RoomTypesPayload>
/**
 * Model FurnitureTypes
 * 
 */
export type FurnitureTypes = $Result.DefaultSelection<Prisma.$FurnitureTypesPayload>
/**
 * Model FurniturePhotos
 * 
 */
export type FurniturePhotos = $Result.DefaultSelection<Prisma.$FurniturePhotosPayload>
/**
 * Model Furniture
 * 
 */
export type Furniture = $Result.DefaultSelection<Prisma.$FurniturePayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model FurnitureComments
 * 
 */
export type FurnitureComments = $Result.DefaultSelection<Prisma.$FurnitureCommentsPayload>
/**
 * Model FurnitureLikes
 * 
 */
export type FurnitureLikes = $Result.DefaultSelection<Prisma.$FurnitureLikesPayload>
/**
 * Model Admins
 * 
 */
export type Admins = $Result.DefaultSelection<Prisma.$AdminsPayload>
/**
 * Model Roles
 * 
 */
export type Roles = $Result.DefaultSelection<Prisma.$RolesPayload>
/**
 * Model AdminRoles
 * 
 */
export type AdminRoles = $Result.DefaultSelection<Prisma.$AdminRolesPayload>
/**
 * Model UserCard
 * 
 */
export type UserCard = $Result.DefaultSelection<Prisma.$UserCardPayload>
/**
 * Model UserAddress
 * 
 */
export type UserAddress = $Result.DefaultSelection<Prisma.$UserAddressPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Contracts
 * 
 */
export type Contracts = $Result.DefaultSelection<Prisma.$ContractsPayload>
/**
 * Model ContractsDetailing
 * 
 */
export type ContractsDetailing = $Result.DefaultSelection<Prisma.$ContractsDetailingPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Colors
 * const colors = await prisma.colors.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Colors
   * const colors = await prisma.colors.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.colors`: Exposes CRUD operations for the **Colors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Colors
    * const colors = await prisma.colors.findMany()
    * ```
    */
  get colors(): Prisma.ColorsDelegate<ExtArgs>;

  /**
   * `prisma.materials`: Exposes CRUD operations for the **Materials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.materials.findMany()
    * ```
    */
  get materials(): Prisma.MaterialsDelegate<ExtArgs>;

  /**
   * `prisma.roomTypes`: Exposes CRUD operations for the **RoomTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomTypes
    * const roomTypes = await prisma.roomTypes.findMany()
    * ```
    */
  get roomTypes(): Prisma.RoomTypesDelegate<ExtArgs>;

  /**
   * `prisma.furnitureTypes`: Exposes CRUD operations for the **FurnitureTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FurnitureTypes
    * const furnitureTypes = await prisma.furnitureTypes.findMany()
    * ```
    */
  get furnitureTypes(): Prisma.FurnitureTypesDelegate<ExtArgs>;

  /**
   * `prisma.furniturePhotos`: Exposes CRUD operations for the **FurniturePhotos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FurniturePhotos
    * const furniturePhotos = await prisma.furniturePhotos.findMany()
    * ```
    */
  get furniturePhotos(): Prisma.FurniturePhotosDelegate<ExtArgs>;

  /**
   * `prisma.furniture`: Exposes CRUD operations for the **Furniture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Furnitures
    * const furnitures = await prisma.furniture.findMany()
    * ```
    */
  get furniture(): Prisma.FurnitureDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs>;

  /**
   * `prisma.furnitureComments`: Exposes CRUD operations for the **FurnitureComments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FurnitureComments
    * const furnitureComments = await prisma.furnitureComments.findMany()
    * ```
    */
  get furnitureComments(): Prisma.FurnitureCommentsDelegate<ExtArgs>;

  /**
   * `prisma.furnitureLikes`: Exposes CRUD operations for the **FurnitureLikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FurnitureLikes
    * const furnitureLikes = await prisma.furnitureLikes.findMany()
    * ```
    */
  get furnitureLikes(): Prisma.FurnitureLikesDelegate<ExtArgs>;

  /**
   * `prisma.admins`: Exposes CRUD operations for the **Admins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admins.findMany()
    * ```
    */
  get admins(): Prisma.AdminsDelegate<ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<ExtArgs>;

  /**
   * `prisma.adminRoles`: Exposes CRUD operations for the **AdminRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminRoles
    * const adminRoles = await prisma.adminRoles.findMany()
    * ```
    */
  get adminRoles(): Prisma.AdminRolesDelegate<ExtArgs>;

  /**
   * `prisma.userCard`: Exposes CRUD operations for the **UserCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCards
    * const userCards = await prisma.userCard.findMany()
    * ```
    */
  get userCard(): Prisma.UserCardDelegate<ExtArgs>;

  /**
   * `prisma.userAddress`: Exposes CRUD operations for the **UserAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAddresses
    * const userAddresses = await prisma.userAddress.findMany()
    * ```
    */
  get userAddress(): Prisma.UserAddressDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.contracts`: Exposes CRUD operations for the **Contracts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contracts.findMany()
    * ```
    */
  get contracts(): Prisma.ContractsDelegate<ExtArgs>;

  /**
   * `prisma.contractsDetailing`: Exposes CRUD operations for the **ContractsDetailing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractsDetailings
    * const contractsDetailings = await prisma.contractsDetailing.findMany()
    * ```
    */
  get contractsDetailing(): Prisma.ContractsDetailingDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.13.0
   * Query Engine version: b9a39a7ee606c28e3455d0fd60e78c3ba82b1a2b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Colors: 'Colors',
    Materials: 'Materials',
    RoomTypes: 'RoomTypes',
    FurnitureTypes: 'FurnitureTypes',
    FurniturePhotos: 'FurniturePhotos',
    Furniture: 'Furniture',
    Users: 'Users',
    FurnitureComments: 'FurnitureComments',
    FurnitureLikes: 'FurnitureLikes',
    Admins: 'Admins',
    Roles: 'Roles',
    AdminRoles: 'AdminRoles',
    UserCard: 'UserCard',
    UserAddress: 'UserAddress',
    Supplier: 'Supplier',
    Payment: 'Payment',
    Contracts: 'Contracts',
    ContractsDetailing: 'ContractsDetailing'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'colors' | 'materials' | 'roomTypes' | 'furnitureTypes' | 'furniturePhotos' | 'furniture' | 'users' | 'furnitureComments' | 'furnitureLikes' | 'admins' | 'roles' | 'adminRoles' | 'userCard' | 'userAddress' | 'supplier' | 'payment' | 'contracts' | 'contractsDetailing'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Colors: {
        payload: Prisma.$ColorsPayload<ExtArgs>
        fields: Prisma.ColorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ColorsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ColorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ColorsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ColorsPayload>
          }
          findFirst: {
            args: Prisma.ColorsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ColorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ColorsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ColorsPayload>
          }
          findMany: {
            args: Prisma.ColorsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ColorsPayload>[]
          }
          create: {
            args: Prisma.ColorsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ColorsPayload>
          }
          createMany: {
            args: Prisma.ColorsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ColorsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ColorsPayload>
          }
          update: {
            args: Prisma.ColorsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ColorsPayload>
          }
          deleteMany: {
            args: Prisma.ColorsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ColorsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ColorsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ColorsPayload>
          }
          aggregate: {
            args: Prisma.ColorsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateColors>
          }
          groupBy: {
            args: Prisma.ColorsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ColorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ColorsCountArgs<ExtArgs>,
            result: $Utils.Optional<ColorsCountAggregateOutputType> | number
          }
        }
      }
      Materials: {
        payload: Prisma.$MaterialsPayload<ExtArgs>
        fields: Prisma.MaterialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          findFirst: {
            args: Prisma.MaterialsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          findMany: {
            args: Prisma.MaterialsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>[]
          }
          create: {
            args: Prisma.MaterialsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          createMany: {
            args: Prisma.MaterialsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MaterialsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          update: {
            args: Prisma.MaterialsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          deleteMany: {
            args: Prisma.MaterialsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MaterialsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          aggregate: {
            args: Prisma.MaterialsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMaterials>
          }
          groupBy: {
            args: Prisma.MaterialsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MaterialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialsCountArgs<ExtArgs>,
            result: $Utils.Optional<MaterialsCountAggregateOutputType> | number
          }
        }
      }
      RoomTypes: {
        payload: Prisma.$RoomTypesPayload<ExtArgs>
        fields: Prisma.RoomTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomTypesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomTypesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypesPayload>
          }
          findFirst: {
            args: Prisma.RoomTypesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomTypesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypesPayload>
          }
          findMany: {
            args: Prisma.RoomTypesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypesPayload>[]
          }
          create: {
            args: Prisma.RoomTypesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypesPayload>
          }
          createMany: {
            args: Prisma.RoomTypesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomTypesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypesPayload>
          }
          update: {
            args: Prisma.RoomTypesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypesPayload>
          }
          deleteMany: {
            args: Prisma.RoomTypesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomTypesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomTypesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypesPayload>
          }
          aggregate: {
            args: Prisma.RoomTypesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoomTypes>
          }
          groupBy: {
            args: Prisma.RoomTypesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomTypesCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomTypesCountAggregateOutputType> | number
          }
        }
      }
      FurnitureTypes: {
        payload: Prisma.$FurnitureTypesPayload<ExtArgs>
        fields: Prisma.FurnitureTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FurnitureTypesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FurnitureTypesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureTypesPayload>
          }
          findFirst: {
            args: Prisma.FurnitureTypesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FurnitureTypesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureTypesPayload>
          }
          findMany: {
            args: Prisma.FurnitureTypesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureTypesPayload>[]
          }
          create: {
            args: Prisma.FurnitureTypesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureTypesPayload>
          }
          createMany: {
            args: Prisma.FurnitureTypesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FurnitureTypesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureTypesPayload>
          }
          update: {
            args: Prisma.FurnitureTypesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureTypesPayload>
          }
          deleteMany: {
            args: Prisma.FurnitureTypesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FurnitureTypesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FurnitureTypesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureTypesPayload>
          }
          aggregate: {
            args: Prisma.FurnitureTypesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFurnitureTypes>
          }
          groupBy: {
            args: Prisma.FurnitureTypesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FurnitureTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FurnitureTypesCountArgs<ExtArgs>,
            result: $Utils.Optional<FurnitureTypesCountAggregateOutputType> | number
          }
        }
      }
      FurniturePhotos: {
        payload: Prisma.$FurniturePhotosPayload<ExtArgs>
        fields: Prisma.FurniturePhotosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FurniturePhotosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePhotosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FurniturePhotosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePhotosPayload>
          }
          findFirst: {
            args: Prisma.FurniturePhotosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePhotosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FurniturePhotosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePhotosPayload>
          }
          findMany: {
            args: Prisma.FurniturePhotosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePhotosPayload>[]
          }
          create: {
            args: Prisma.FurniturePhotosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePhotosPayload>
          }
          createMany: {
            args: Prisma.FurniturePhotosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FurniturePhotosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePhotosPayload>
          }
          update: {
            args: Prisma.FurniturePhotosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePhotosPayload>
          }
          deleteMany: {
            args: Prisma.FurniturePhotosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FurniturePhotosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FurniturePhotosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePhotosPayload>
          }
          aggregate: {
            args: Prisma.FurniturePhotosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFurniturePhotos>
          }
          groupBy: {
            args: Prisma.FurniturePhotosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FurniturePhotosGroupByOutputType>[]
          }
          count: {
            args: Prisma.FurniturePhotosCountArgs<ExtArgs>,
            result: $Utils.Optional<FurniturePhotosCountAggregateOutputType> | number
          }
        }
      }
      Furniture: {
        payload: Prisma.$FurniturePayload<ExtArgs>
        fields: Prisma.FurnitureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FurnitureFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FurnitureFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePayload>
          }
          findFirst: {
            args: Prisma.FurnitureFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FurnitureFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePayload>
          }
          findMany: {
            args: Prisma.FurnitureFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePayload>[]
          }
          create: {
            args: Prisma.FurnitureCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePayload>
          }
          createMany: {
            args: Prisma.FurnitureCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FurnitureDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePayload>
          }
          update: {
            args: Prisma.FurnitureUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePayload>
          }
          deleteMany: {
            args: Prisma.FurnitureDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FurnitureUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FurnitureUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurniturePayload>
          }
          aggregate: {
            args: Prisma.FurnitureAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFurniture>
          }
          groupBy: {
            args: Prisma.FurnitureGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FurnitureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FurnitureCountArgs<ExtArgs>,
            result: $Utils.Optional<FurnitureCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      FurnitureComments: {
        payload: Prisma.$FurnitureCommentsPayload<ExtArgs>
        fields: Prisma.FurnitureCommentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FurnitureCommentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureCommentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FurnitureCommentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureCommentsPayload>
          }
          findFirst: {
            args: Prisma.FurnitureCommentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureCommentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FurnitureCommentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureCommentsPayload>
          }
          findMany: {
            args: Prisma.FurnitureCommentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureCommentsPayload>[]
          }
          create: {
            args: Prisma.FurnitureCommentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureCommentsPayload>
          }
          createMany: {
            args: Prisma.FurnitureCommentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FurnitureCommentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureCommentsPayload>
          }
          update: {
            args: Prisma.FurnitureCommentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureCommentsPayload>
          }
          deleteMany: {
            args: Prisma.FurnitureCommentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FurnitureCommentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FurnitureCommentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureCommentsPayload>
          }
          aggregate: {
            args: Prisma.FurnitureCommentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFurnitureComments>
          }
          groupBy: {
            args: Prisma.FurnitureCommentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FurnitureCommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FurnitureCommentsCountArgs<ExtArgs>,
            result: $Utils.Optional<FurnitureCommentsCountAggregateOutputType> | number
          }
        }
      }
      FurnitureLikes: {
        payload: Prisma.$FurnitureLikesPayload<ExtArgs>
        fields: Prisma.FurnitureLikesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FurnitureLikesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureLikesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FurnitureLikesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureLikesPayload>
          }
          findFirst: {
            args: Prisma.FurnitureLikesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureLikesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FurnitureLikesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureLikesPayload>
          }
          findMany: {
            args: Prisma.FurnitureLikesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureLikesPayload>[]
          }
          create: {
            args: Prisma.FurnitureLikesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureLikesPayload>
          }
          createMany: {
            args: Prisma.FurnitureLikesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FurnitureLikesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureLikesPayload>
          }
          update: {
            args: Prisma.FurnitureLikesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureLikesPayload>
          }
          deleteMany: {
            args: Prisma.FurnitureLikesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FurnitureLikesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FurnitureLikesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FurnitureLikesPayload>
          }
          aggregate: {
            args: Prisma.FurnitureLikesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFurnitureLikes>
          }
          groupBy: {
            args: Prisma.FurnitureLikesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FurnitureLikesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FurnitureLikesCountArgs<ExtArgs>,
            result: $Utils.Optional<FurnitureLikesCountAggregateOutputType> | number
          }
        }
      }
      Admins: {
        payload: Prisma.$AdminsPayload<ExtArgs>
        fields: Prisma.AdminsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          findFirst: {
            args: Prisma.AdminsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          findMany: {
            args: Prisma.AdminsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>[]
          }
          create: {
            args: Prisma.AdminsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          createMany: {
            args: Prisma.AdminsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          update: {
            args: Prisma.AdminsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          deleteMany: {
            args: Prisma.AdminsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminsPayload>
          }
          aggregate: {
            args: Prisma.AdminsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmins>
          }
          groupBy: {
            args: Prisma.AdminsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminsCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminsCountAggregateOutputType> | number
          }
        }
      }
      Roles: {
        payload: Prisma.$RolesPayload<ExtArgs>
        fields: Prisma.RolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findFirst: {
            args: Prisma.RolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findMany: {
            args: Prisma.RolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          create: {
            args: Prisma.RolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          createMany: {
            args: Prisma.RolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          update: {
            args: Prisma.RolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          deleteMany: {
            args: Prisma.RolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.RolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesCountArgs<ExtArgs>,
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      AdminRoles: {
        payload: Prisma.$AdminRolesPayload<ExtArgs>
        fields: Prisma.AdminRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminRolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminRolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminRolesPayload>
          }
          findFirst: {
            args: Prisma.AdminRolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminRolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminRolesPayload>
          }
          findMany: {
            args: Prisma.AdminRolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminRolesPayload>[]
          }
          create: {
            args: Prisma.AdminRolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminRolesPayload>
          }
          createMany: {
            args: Prisma.AdminRolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminRolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminRolesPayload>
          }
          update: {
            args: Prisma.AdminRolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminRolesPayload>
          }
          deleteMany: {
            args: Prisma.AdminRolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminRolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminRolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminRolesPayload>
          }
          aggregate: {
            args: Prisma.AdminRolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdminRoles>
          }
          groupBy: {
            args: Prisma.AdminRolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminRolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminRolesCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminRolesCountAggregateOutputType> | number
          }
        }
      }
      UserCard: {
        payload: Prisma.$UserCardPayload<ExtArgs>
        fields: Prisma.UserCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCardFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCardFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          findFirst: {
            args: Prisma.UserCardFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCardFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          findMany: {
            args: Prisma.UserCardFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>[]
          }
          create: {
            args: Prisma.UserCardCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          createMany: {
            args: Prisma.UserCardCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserCardDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          update: {
            args: Prisma.UserCardUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          deleteMany: {
            args: Prisma.UserCardDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserCardUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserCardUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          aggregate: {
            args: Prisma.UserCardAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserCard>
          }
          groupBy: {
            args: Prisma.UserCardGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCardCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCardCountAggregateOutputType> | number
          }
        }
      }
      UserAddress: {
        payload: Prisma.$UserAddressPayload<ExtArgs>
        fields: Prisma.UserAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAddressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAddressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          findFirst: {
            args: Prisma.UserAddressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAddressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          findMany: {
            args: Prisma.UserAddressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
          }
          create: {
            args: Prisma.UserAddressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          createMany: {
            args: Prisma.UserAddressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserAddressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          update: {
            args: Prisma.UserAddressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          deleteMany: {
            args: Prisma.UserAddressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserAddressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserAddressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          aggregate: {
            args: Prisma.UserAddressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserAddress>
          }
          groupBy: {
            args: Prisma.UserAddressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAddressCountArgs<ExtArgs>,
            result: $Utils.Optional<UserAddressCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Contracts: {
        payload: Prisma.$ContractsPayload<ExtArgs>
        fields: Prisma.ContractsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsPayload>
          }
          findFirst: {
            args: Prisma.ContractsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsPayload>
          }
          findMany: {
            args: Prisma.ContractsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsPayload>[]
          }
          create: {
            args: Prisma.ContractsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsPayload>
          }
          createMany: {
            args: Prisma.ContractsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContractsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsPayload>
          }
          update: {
            args: Prisma.ContractsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsPayload>
          }
          deleteMany: {
            args: Prisma.ContractsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContractsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContractsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsPayload>
          }
          aggregate: {
            args: Prisma.ContractsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContracts>
          }
          groupBy: {
            args: Prisma.ContractsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContractsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractsCountArgs<ExtArgs>,
            result: $Utils.Optional<ContractsCountAggregateOutputType> | number
          }
        }
      }
      ContractsDetailing: {
        payload: Prisma.$ContractsDetailingPayload<ExtArgs>
        fields: Prisma.ContractsDetailingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractsDetailingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsDetailingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractsDetailingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsDetailingPayload>
          }
          findFirst: {
            args: Prisma.ContractsDetailingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsDetailingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractsDetailingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsDetailingPayload>
          }
          findMany: {
            args: Prisma.ContractsDetailingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsDetailingPayload>[]
          }
          create: {
            args: Prisma.ContractsDetailingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsDetailingPayload>
          }
          createMany: {
            args: Prisma.ContractsDetailingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContractsDetailingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsDetailingPayload>
          }
          update: {
            args: Prisma.ContractsDetailingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsDetailingPayload>
          }
          deleteMany: {
            args: Prisma.ContractsDetailingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContractsDetailingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContractsDetailingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractsDetailingPayload>
          }
          aggregate: {
            args: Prisma.ContractsDetailingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContractsDetailing>
          }
          groupBy: {
            args: Prisma.ContractsDetailingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContractsDetailingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractsDetailingCountArgs<ExtArgs>,
            result: $Utils.Optional<ContractsDetailingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ColorsCountOutputType
   */

  export type ColorsCountOutputType = {
    furniture: number
  }

  export type ColorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    furniture?: boolean | ColorsCountOutputTypeCountFurnitureArgs
  }

  // Custom InputTypes
  /**
   * ColorsCountOutputType without action
   */
  export type ColorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorsCountOutputType
     */
    select?: ColorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ColorsCountOutputType without action
   */
  export type ColorsCountOutputTypeCountFurnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurnitureWhereInput
  }


  /**
   * Count Type MaterialsCountOutputType
   */

  export type MaterialsCountOutputType = {
    furniture: number
  }

  export type MaterialsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    furniture?: boolean | MaterialsCountOutputTypeCountFurnitureArgs
  }

  // Custom InputTypes
  /**
   * MaterialsCountOutputType without action
   */
  export type MaterialsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialsCountOutputType
     */
    select?: MaterialsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialsCountOutputType without action
   */
  export type MaterialsCountOutputTypeCountFurnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurnitureWhereInput
  }


  /**
   * Count Type RoomTypesCountOutputType
   */

  export type RoomTypesCountOutputType = {
    furniture: number
  }

  export type RoomTypesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    furniture?: boolean | RoomTypesCountOutputTypeCountFurnitureArgs
  }

  // Custom InputTypes
  /**
   * RoomTypesCountOutputType without action
   */
  export type RoomTypesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypesCountOutputType
     */
    select?: RoomTypesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomTypesCountOutputType without action
   */
  export type RoomTypesCountOutputTypeCountFurnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurnitureWhereInput
  }


  /**
   * Count Type FurnitureTypesCountOutputType
   */

  export type FurnitureTypesCountOutputType = {
    furniture: number
  }

  export type FurnitureTypesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    furniture?: boolean | FurnitureTypesCountOutputTypeCountFurnitureArgs
  }

  // Custom InputTypes
  /**
   * FurnitureTypesCountOutputType without action
   */
  export type FurnitureTypesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureTypesCountOutputType
     */
    select?: FurnitureTypesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FurnitureTypesCountOutputType without action
   */
  export type FurnitureTypesCountOutputTypeCountFurnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurnitureWhereInput
  }


  /**
   * Count Type FurnitureCountOutputType
   */

  export type FurnitureCountOutputType = {
    furniture_photos: number
    furniture_comments: number
    furniture_likes: number
    contracts_detailing: number
  }

  export type FurnitureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    furniture_photos?: boolean | FurnitureCountOutputTypeCountFurniture_photosArgs
    furniture_comments?: boolean | FurnitureCountOutputTypeCountFurniture_commentsArgs
    furniture_likes?: boolean | FurnitureCountOutputTypeCountFurniture_likesArgs
    contracts_detailing?: boolean | FurnitureCountOutputTypeCountContracts_detailingArgs
  }

  // Custom InputTypes
  /**
   * FurnitureCountOutputType without action
   */
  export type FurnitureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureCountOutputType
     */
    select?: FurnitureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FurnitureCountOutputType without action
   */
  export type FurnitureCountOutputTypeCountFurniture_photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurniturePhotosWhereInput
  }

  /**
   * FurnitureCountOutputType without action
   */
  export type FurnitureCountOutputTypeCountFurniture_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurnitureCommentsWhereInput
  }

  /**
   * FurnitureCountOutputType without action
   */
  export type FurnitureCountOutputTypeCountFurniture_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurnitureLikesWhereInput
  }

  /**
   * FurnitureCountOutputType without action
   */
  export type FurnitureCountOutputTypeCountContracts_detailingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractsDetailingWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    furniture_comments: number
    furniture_likes: number
    user_card: number
    user_address: number
    payment: number
    contracts: number
    contracts_detailing: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    furniture_comments?: boolean | UsersCountOutputTypeCountFurniture_commentsArgs
    furniture_likes?: boolean | UsersCountOutputTypeCountFurniture_likesArgs
    user_card?: boolean | UsersCountOutputTypeCountUser_cardArgs
    user_address?: boolean | UsersCountOutputTypeCountUser_addressArgs
    payment?: boolean | UsersCountOutputTypeCountPaymentArgs
    contracts?: boolean | UsersCountOutputTypeCountContractsArgs
    contracts_detailing?: boolean | UsersCountOutputTypeCountContracts_detailingArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFurniture_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurnitureCommentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFurniture_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurnitureLikesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_cardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCardWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountContracts_detailingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractsDetailingWhereInput
  }


  /**
   * Count Type AdminsCountOutputType
   */

  export type AdminsCountOutputType = {
    admin_roles: number
  }

  export type AdminsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_roles?: boolean | AdminsCountOutputTypeCountAdmin_rolesArgs
  }

  // Custom InputTypes
  /**
   * AdminsCountOutputType without action
   */
  export type AdminsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminsCountOutputType
     */
    select?: AdminsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminsCountOutputType without action
   */
  export type AdminsCountOutputTypeCountAdmin_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRolesWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    admin_roles: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_roles?: boolean | RolesCountOutputTypeCountAdmin_rolesArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountAdmin_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRolesWhereInput
  }


  /**
   * Count Type UserCardCountOutputType
   */

  export type UserCardCountOutputType = {
    payment: number
  }

  export type UserCardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | UserCardCountOutputTypeCountPaymentArgs
  }

  // Custom InputTypes
  /**
   * UserCardCountOutputType without action
   */
  export type UserCardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCardCountOutputType
     */
    select?: UserCardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCardCountOutputType without action
   */
  export type UserCardCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    contracts: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | SupplierCountOutputTypeCountContractsArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractsWhereInput
  }


  /**
   * Count Type ContractsCountOutputType
   */

  export type ContractsCountOutputType = {
    contracts_detailing: number
    payment: number
  }

  export type ContractsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts_detailing?: boolean | ContractsCountOutputTypeCountContracts_detailingArgs
    payment?: boolean | ContractsCountOutputTypeCountPaymentArgs
  }

  // Custom InputTypes
  /**
   * ContractsCountOutputType without action
   */
  export type ContractsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsCountOutputType
     */
    select?: ContractsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractsCountOutputType without action
   */
  export type ContractsCountOutputTypeCountContracts_detailingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractsDetailingWhereInput
  }

  /**
   * ContractsCountOutputType without action
   */
  export type ContractsCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Colors
   */

  export type AggregateColors = {
    _count: ColorsCountAggregateOutputType | null
    _avg: ColorsAvgAggregateOutputType | null
    _sum: ColorsSumAggregateOutputType | null
    _min: ColorsMinAggregateOutputType | null
    _max: ColorsMaxAggregateOutputType | null
  }

  export type ColorsAvgAggregateOutputType = {
    id: number | null
  }

  export type ColorsSumAggregateOutputType = {
    id: number | null
  }

  export type ColorsMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ColorsMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ColorsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ColorsAvgAggregateInputType = {
    id?: true
  }

  export type ColorsSumAggregateInputType = {
    id?: true
  }

  export type ColorsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ColorsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ColorsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ColorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Colors to aggregate.
     */
    where?: ColorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorsOrderByWithRelationInput | ColorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ColorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Colors
    **/
    _count?: true | ColorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ColorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ColorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColorsMaxAggregateInputType
  }

  export type GetColorsAggregateType<T extends ColorsAggregateArgs> = {
        [P in keyof T & keyof AggregateColors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColors[P]>
      : GetScalarType<T[P], AggregateColors[P]>
  }




  export type ColorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColorsWhereInput
    orderBy?: ColorsOrderByWithAggregationInput | ColorsOrderByWithAggregationInput[]
    by: ColorsScalarFieldEnum[] | ColorsScalarFieldEnum
    having?: ColorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColorsCountAggregateInputType | true
    _avg?: ColorsAvgAggregateInputType
    _sum?: ColorsSumAggregateInputType
    _min?: ColorsMinAggregateInputType
    _max?: ColorsMaxAggregateInputType
  }

  export type ColorsGroupByOutputType = {
    id: number
    name: string
    _count: ColorsCountAggregateOutputType | null
    _avg: ColorsAvgAggregateOutputType | null
    _sum: ColorsSumAggregateOutputType | null
    _min: ColorsMinAggregateOutputType | null
    _max: ColorsMaxAggregateOutputType | null
  }

  type GetColorsGroupByPayload<T extends ColorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColorsGroupByOutputType[P]>
            : GetScalarType<T[P], ColorsGroupByOutputType[P]>
        }
      >
    >


  export type ColorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    furniture?: boolean | Colors$furnitureArgs<ExtArgs>
    _count?: boolean | ColorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["colors"]>

  export type ColorsSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type ColorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    furniture?: boolean | Colors$furnitureArgs<ExtArgs>
    _count?: boolean | ColorsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ColorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Colors"
    objects: {
      furniture: Prisma.$FurniturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["colors"]>
    composites: {}
  }


  type ColorsGetPayload<S extends boolean | null | undefined | ColorsDefaultArgs> = $Result.GetResult<Prisma.$ColorsPayload, S>

  type ColorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ColorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ColorsCountAggregateInputType | true
    }

  export interface ColorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Colors'], meta: { name: 'Colors' } }
    /**
     * Find zero or one Colors that matches the filter.
     * @param {ColorsFindUniqueArgs} args - Arguments to find a Colors
     * @example
     * // Get one Colors
     * const colors = await prisma.colors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ColorsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ColorsFindUniqueArgs<ExtArgs>>
    ): Prisma__ColorsClient<$Result.GetResult<Prisma.$ColorsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Colors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ColorsFindUniqueOrThrowArgs} args - Arguments to find a Colors
     * @example
     * // Get one Colors
     * const colors = await prisma.colors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ColorsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ColorsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ColorsClient<$Result.GetResult<Prisma.$ColorsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Colors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorsFindFirstArgs} args - Arguments to find a Colors
     * @example
     * // Get one Colors
     * const colors = await prisma.colors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ColorsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ColorsFindFirstArgs<ExtArgs>>
    ): Prisma__ColorsClient<$Result.GetResult<Prisma.$ColorsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Colors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorsFindFirstOrThrowArgs} args - Arguments to find a Colors
     * @example
     * // Get one Colors
     * const colors = await prisma.colors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ColorsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ColorsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ColorsClient<$Result.GetResult<Prisma.$ColorsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Colors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Colors
     * const colors = await prisma.colors.findMany()
     * 
     * // Get first 10 Colors
     * const colors = await prisma.colors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const colorsWithIdOnly = await prisma.colors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ColorsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ColorsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Colors.
     * @param {ColorsCreateArgs} args - Arguments to create a Colors.
     * @example
     * // Create one Colors
     * const Colors = await prisma.colors.create({
     *   data: {
     *     // ... data to create a Colors
     *   }
     * })
     * 
    **/
    create<T extends ColorsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ColorsCreateArgs<ExtArgs>>
    ): Prisma__ColorsClient<$Result.GetResult<Prisma.$ColorsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Colors.
     *     @param {ColorsCreateManyArgs} args - Arguments to create many Colors.
     *     @example
     *     // Create many Colors
     *     const colors = await prisma.colors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ColorsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ColorsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Colors.
     * @param {ColorsDeleteArgs} args - Arguments to delete one Colors.
     * @example
     * // Delete one Colors
     * const Colors = await prisma.colors.delete({
     *   where: {
     *     // ... filter to delete one Colors
     *   }
     * })
     * 
    **/
    delete<T extends ColorsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ColorsDeleteArgs<ExtArgs>>
    ): Prisma__ColorsClient<$Result.GetResult<Prisma.$ColorsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Colors.
     * @param {ColorsUpdateArgs} args - Arguments to update one Colors.
     * @example
     * // Update one Colors
     * const colors = await prisma.colors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ColorsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ColorsUpdateArgs<ExtArgs>>
    ): Prisma__ColorsClient<$Result.GetResult<Prisma.$ColorsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Colors.
     * @param {ColorsDeleteManyArgs} args - Arguments to filter Colors to delete.
     * @example
     * // Delete a few Colors
     * const { count } = await prisma.colors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ColorsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ColorsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Colors
     * const colors = await prisma.colors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ColorsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ColorsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Colors.
     * @param {ColorsUpsertArgs} args - Arguments to update or create a Colors.
     * @example
     * // Update or create a Colors
     * const colors = await prisma.colors.upsert({
     *   create: {
     *     // ... data to create a Colors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Colors we want to update
     *   }
     * })
    **/
    upsert<T extends ColorsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ColorsUpsertArgs<ExtArgs>>
    ): Prisma__ColorsClient<$Result.GetResult<Prisma.$ColorsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorsCountArgs} args - Arguments to filter Colors to count.
     * @example
     * // Count the number of Colors
     * const count = await prisma.colors.count({
     *   where: {
     *     // ... the filter for the Colors we want to count
     *   }
     * })
    **/
    count<T extends ColorsCountArgs>(
      args?: Subset<T, ColorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColorsAggregateArgs>(args: Subset<T, ColorsAggregateArgs>): Prisma.PrismaPromise<GetColorsAggregateType<T>>

    /**
     * Group by Colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ColorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ColorsGroupByArgs['orderBy'] }
        : { orderBy?: ColorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ColorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Colors model
   */
  readonly fields: ColorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Colors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ColorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    furniture<T extends Colors$furnitureArgs<ExtArgs> = {}>(args?: Subset<T, Colors$furnitureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Colors model
   */ 
  interface ColorsFieldRefs {
    readonly id: FieldRef<"Colors", 'Int'>
    readonly name: FieldRef<"Colors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Colors findUnique
   */
  export type ColorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colors
     */
    select?: ColorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorsInclude<ExtArgs> | null
    /**
     * Filter, which Colors to fetch.
     */
    where: ColorsWhereUniqueInput
  }

  /**
   * Colors findUniqueOrThrow
   */
  export type ColorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colors
     */
    select?: ColorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorsInclude<ExtArgs> | null
    /**
     * Filter, which Colors to fetch.
     */
    where: ColorsWhereUniqueInput
  }

  /**
   * Colors findFirst
   */
  export type ColorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colors
     */
    select?: ColorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorsInclude<ExtArgs> | null
    /**
     * Filter, which Colors to fetch.
     */
    where?: ColorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorsOrderByWithRelationInput | ColorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colors.
     */
    cursor?: ColorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colors.
     */
    distinct?: ColorsScalarFieldEnum | ColorsScalarFieldEnum[]
  }

  /**
   * Colors findFirstOrThrow
   */
  export type ColorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colors
     */
    select?: ColorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorsInclude<ExtArgs> | null
    /**
     * Filter, which Colors to fetch.
     */
    where?: ColorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorsOrderByWithRelationInput | ColorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colors.
     */
    cursor?: ColorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colors.
     */
    distinct?: ColorsScalarFieldEnum | ColorsScalarFieldEnum[]
  }

  /**
   * Colors findMany
   */
  export type ColorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colors
     */
    select?: ColorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorsInclude<ExtArgs> | null
    /**
     * Filter, which Colors to fetch.
     */
    where?: ColorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorsOrderByWithRelationInput | ColorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Colors.
     */
    cursor?: ColorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    distinct?: ColorsScalarFieldEnum | ColorsScalarFieldEnum[]
  }

  /**
   * Colors create
   */
  export type ColorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colors
     */
    select?: ColorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorsInclude<ExtArgs> | null
    /**
     * The data needed to create a Colors.
     */
    data: XOR<ColorsCreateInput, ColorsUncheckedCreateInput>
  }

  /**
   * Colors createMany
   */
  export type ColorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Colors.
     */
    data: ColorsCreateManyInput | ColorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Colors update
   */
  export type ColorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colors
     */
    select?: ColorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorsInclude<ExtArgs> | null
    /**
     * The data needed to update a Colors.
     */
    data: XOR<ColorsUpdateInput, ColorsUncheckedUpdateInput>
    /**
     * Choose, which Colors to update.
     */
    where: ColorsWhereUniqueInput
  }

  /**
   * Colors updateMany
   */
  export type ColorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Colors.
     */
    data: XOR<ColorsUpdateManyMutationInput, ColorsUncheckedUpdateManyInput>
    /**
     * Filter which Colors to update
     */
    where?: ColorsWhereInput
  }

  /**
   * Colors upsert
   */
  export type ColorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colors
     */
    select?: ColorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorsInclude<ExtArgs> | null
    /**
     * The filter to search for the Colors to update in case it exists.
     */
    where: ColorsWhereUniqueInput
    /**
     * In case the Colors found by the `where` argument doesn't exist, create a new Colors with this data.
     */
    create: XOR<ColorsCreateInput, ColorsUncheckedCreateInput>
    /**
     * In case the Colors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ColorsUpdateInput, ColorsUncheckedUpdateInput>
  }

  /**
   * Colors delete
   */
  export type ColorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colors
     */
    select?: ColorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorsInclude<ExtArgs> | null
    /**
     * Filter which Colors to delete.
     */
    where: ColorsWhereUniqueInput
  }

  /**
   * Colors deleteMany
   */
  export type ColorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Colors to delete
     */
    where?: ColorsWhereInput
  }

  /**
   * Colors.furniture
   */
  export type Colors$furnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    where?: FurnitureWhereInput
    orderBy?: FurnitureOrderByWithRelationInput | FurnitureOrderByWithRelationInput[]
    cursor?: FurnitureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FurnitureScalarFieldEnum | FurnitureScalarFieldEnum[]
  }

  /**
   * Colors without action
   */
  export type ColorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colors
     */
    select?: ColorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorsInclude<ExtArgs> | null
  }


  /**
   * Model Materials
   */

  export type AggregateMaterials = {
    _count: MaterialsCountAggregateOutputType | null
    _avg: MaterialsAvgAggregateOutputType | null
    _sum: MaterialsSumAggregateOutputType | null
    _min: MaterialsMinAggregateOutputType | null
    _max: MaterialsMaxAggregateOutputType | null
  }

  export type MaterialsAvgAggregateOutputType = {
    id: number | null
  }

  export type MaterialsSumAggregateOutputType = {
    id: number | null
  }

  export type MaterialsMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MaterialsMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MaterialsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type MaterialsAvgAggregateInputType = {
    id?: true
  }

  export type MaterialsSumAggregateInputType = {
    id?: true
  }

  export type MaterialsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type MaterialsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type MaterialsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type MaterialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to aggregate.
     */
    where?: MaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialsMaxAggregateInputType
  }

  export type GetMaterialsAggregateType<T extends MaterialsAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterials[P]>
      : GetScalarType<T[P], AggregateMaterials[P]>
  }




  export type MaterialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialsWhereInput
    orderBy?: MaterialsOrderByWithAggregationInput | MaterialsOrderByWithAggregationInput[]
    by: MaterialsScalarFieldEnum[] | MaterialsScalarFieldEnum
    having?: MaterialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialsCountAggregateInputType | true
    _avg?: MaterialsAvgAggregateInputType
    _sum?: MaterialsSumAggregateInputType
    _min?: MaterialsMinAggregateInputType
    _max?: MaterialsMaxAggregateInputType
  }

  export type MaterialsGroupByOutputType = {
    id: number
    name: string
    _count: MaterialsCountAggregateOutputType | null
    _avg: MaterialsAvgAggregateOutputType | null
    _sum: MaterialsSumAggregateOutputType | null
    _min: MaterialsMinAggregateOutputType | null
    _max: MaterialsMaxAggregateOutputType | null
  }

  type GetMaterialsGroupByPayload<T extends MaterialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialsGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialsGroupByOutputType[P]>
        }
      >
    >


  export type MaterialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    furniture?: boolean | Materials$furnitureArgs<ExtArgs>
    _count?: boolean | MaterialsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materials"]>

  export type MaterialsSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type MaterialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    furniture?: boolean | Materials$furnitureArgs<ExtArgs>
    _count?: boolean | MaterialsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MaterialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Materials"
    objects: {
      furniture: Prisma.$FurniturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["materials"]>
    composites: {}
  }


  type MaterialsGetPayload<S extends boolean | null | undefined | MaterialsDefaultArgs> = $Result.GetResult<Prisma.$MaterialsPayload, S>

  type MaterialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialsCountAggregateInputType | true
    }

  export interface MaterialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Materials'], meta: { name: 'Materials' } }
    /**
     * Find zero or one Materials that matches the filter.
     * @param {MaterialsFindUniqueArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MaterialsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialsFindUniqueArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Materials that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MaterialsFindUniqueOrThrowArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MaterialsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsFindFirstArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MaterialsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialsFindFirstArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Materials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsFindFirstOrThrowArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MaterialsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.materials.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.materials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialsWithIdOnly = await prisma.materials.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MaterialsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Materials.
     * @param {MaterialsCreateArgs} args - Arguments to create a Materials.
     * @example
     * // Create one Materials
     * const Materials = await prisma.materials.create({
     *   data: {
     *     // ... data to create a Materials
     *   }
     * })
     * 
    **/
    create<T extends MaterialsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialsCreateArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Materials.
     *     @param {MaterialsCreateManyArgs} args - Arguments to create many Materials.
     *     @example
     *     // Create many Materials
     *     const materials = await prisma.materials.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MaterialsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Materials.
     * @param {MaterialsDeleteArgs} args - Arguments to delete one Materials.
     * @example
     * // Delete one Materials
     * const Materials = await prisma.materials.delete({
     *   where: {
     *     // ... filter to delete one Materials
     *   }
     * })
     * 
    **/
    delete<T extends MaterialsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialsDeleteArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Materials.
     * @param {MaterialsUpdateArgs} args - Arguments to update one Materials.
     * @example
     * // Update one Materials
     * const materials = await prisma.materials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MaterialsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialsUpdateArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Materials.
     * @param {MaterialsDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.materials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MaterialsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const materials = await prisma.materials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MaterialsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Materials.
     * @param {MaterialsUpsertArgs} args - Arguments to update or create a Materials.
     * @example
     * // Update or create a Materials
     * const materials = await prisma.materials.upsert({
     *   create: {
     *     // ... data to create a Materials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materials we want to update
     *   }
     * })
    **/
    upsert<T extends MaterialsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialsUpsertArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.materials.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialsCountArgs>(
      args?: Subset<T, MaterialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialsAggregateArgs>(args: Subset<T, MaterialsAggregateArgs>): Prisma.PrismaPromise<GetMaterialsAggregateType<T>>

    /**
     * Group by Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialsGroupByArgs['orderBy'] }
        : { orderBy?: MaterialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Materials model
   */
  readonly fields: MaterialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Materials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    furniture<T extends Materials$furnitureArgs<ExtArgs> = {}>(args?: Subset<T, Materials$furnitureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Materials model
   */ 
  interface MaterialsFieldRefs {
    readonly id: FieldRef<"Materials", 'Int'>
    readonly name: FieldRef<"Materials", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Materials findUnique
   */
  export type MaterialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where: MaterialsWhereUniqueInput
  }

  /**
   * Materials findUniqueOrThrow
   */
  export type MaterialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where: MaterialsWhereUniqueInput
  }

  /**
   * Materials findFirst
   */
  export type MaterialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }

  /**
   * Materials findFirstOrThrow
   */
  export type MaterialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }

  /**
   * Materials findMany
   */
  export type MaterialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }

  /**
   * Materials create
   */
  export type MaterialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * The data needed to create a Materials.
     */
    data: XOR<MaterialsCreateInput, MaterialsUncheckedCreateInput>
  }

  /**
   * Materials createMany
   */
  export type MaterialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialsCreateManyInput | MaterialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Materials update
   */
  export type MaterialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * The data needed to update a Materials.
     */
    data: XOR<MaterialsUpdateInput, MaterialsUncheckedUpdateInput>
    /**
     * Choose, which Materials to update.
     */
    where: MaterialsWhereUniqueInput
  }

  /**
   * Materials updateMany
   */
  export type MaterialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialsUpdateManyMutationInput, MaterialsUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialsWhereInput
  }

  /**
   * Materials upsert
   */
  export type MaterialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * The filter to search for the Materials to update in case it exists.
     */
    where: MaterialsWhereUniqueInput
    /**
     * In case the Materials found by the `where` argument doesn't exist, create a new Materials with this data.
     */
    create: XOR<MaterialsCreateInput, MaterialsUncheckedCreateInput>
    /**
     * In case the Materials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialsUpdateInput, MaterialsUncheckedUpdateInput>
  }

  /**
   * Materials delete
   */
  export type MaterialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter which Materials to delete.
     */
    where: MaterialsWhereUniqueInput
  }

  /**
   * Materials deleteMany
   */
  export type MaterialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialsWhereInput
  }

  /**
   * Materials.furniture
   */
  export type Materials$furnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    where?: FurnitureWhereInput
    orderBy?: FurnitureOrderByWithRelationInput | FurnitureOrderByWithRelationInput[]
    cursor?: FurnitureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FurnitureScalarFieldEnum | FurnitureScalarFieldEnum[]
  }

  /**
   * Materials without action
   */
  export type MaterialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
  }


  /**
   * Model RoomTypes
   */

  export type AggregateRoomTypes = {
    _count: RoomTypesCountAggregateOutputType | null
    _avg: RoomTypesAvgAggregateOutputType | null
    _sum: RoomTypesSumAggregateOutputType | null
    _min: RoomTypesMinAggregateOutputType | null
    _max: RoomTypesMaxAggregateOutputType | null
  }

  export type RoomTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type RoomTypesSumAggregateOutputType = {
    id: number | null
  }

  export type RoomTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoomTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoomTypesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoomTypesAvgAggregateInputType = {
    id?: true
  }

  export type RoomTypesSumAggregateInputType = {
    id?: true
  }

  export type RoomTypesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoomTypesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoomTypesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoomTypesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomTypes to aggregate.
     */
    where?: RoomTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypesOrderByWithRelationInput | RoomTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomTypes
    **/
    _count?: true | RoomTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomTypesMaxAggregateInputType
  }

  export type GetRoomTypesAggregateType<T extends RoomTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomTypes[P]>
      : GetScalarType<T[P], AggregateRoomTypes[P]>
  }




  export type RoomTypesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTypesWhereInput
    orderBy?: RoomTypesOrderByWithAggregationInput | RoomTypesOrderByWithAggregationInput[]
    by: RoomTypesScalarFieldEnum[] | RoomTypesScalarFieldEnum
    having?: RoomTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomTypesCountAggregateInputType | true
    _avg?: RoomTypesAvgAggregateInputType
    _sum?: RoomTypesSumAggregateInputType
    _min?: RoomTypesMinAggregateInputType
    _max?: RoomTypesMaxAggregateInputType
  }

  export type RoomTypesGroupByOutputType = {
    id: number
    name: string
    _count: RoomTypesCountAggregateOutputType | null
    _avg: RoomTypesAvgAggregateOutputType | null
    _sum: RoomTypesSumAggregateOutputType | null
    _min: RoomTypesMinAggregateOutputType | null
    _max: RoomTypesMaxAggregateOutputType | null
  }

  type GetRoomTypesGroupByPayload<T extends RoomTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomTypesGroupByOutputType[P]>
            : GetScalarType<T[P], RoomTypesGroupByOutputType[P]>
        }
      >
    >


  export type RoomTypesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    furniture?: boolean | RoomTypes$furnitureArgs<ExtArgs>
    _count?: boolean | RoomTypesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomTypes"]>

  export type RoomTypesSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type RoomTypesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    furniture?: boolean | RoomTypes$furnitureArgs<ExtArgs>
    _count?: boolean | RoomTypesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RoomTypesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomTypes"
    objects: {
      furniture: Prisma.$FurniturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["roomTypes"]>
    composites: {}
  }


  type RoomTypesGetPayload<S extends boolean | null | undefined | RoomTypesDefaultArgs> = $Result.GetResult<Prisma.$RoomTypesPayload, S>

  type RoomTypesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomTypesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomTypesCountAggregateInputType | true
    }

  export interface RoomTypesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomTypes'], meta: { name: 'RoomTypes' } }
    /**
     * Find zero or one RoomTypes that matches the filter.
     * @param {RoomTypesFindUniqueArgs} args - Arguments to find a RoomTypes
     * @example
     * // Get one RoomTypes
     * const roomTypes = await prisma.roomTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomTypesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTypesFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomTypesClient<$Result.GetResult<Prisma.$RoomTypesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoomTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomTypesFindUniqueOrThrowArgs} args - Arguments to find a RoomTypes
     * @example
     * // Get one RoomTypes
     * const roomTypes = await prisma.roomTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomTypesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTypesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomTypesClient<$Result.GetResult<Prisma.$RoomTypesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoomTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypesFindFirstArgs} args - Arguments to find a RoomTypes
     * @example
     * // Get one RoomTypes
     * const roomTypes = await prisma.roomTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomTypesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTypesFindFirstArgs<ExtArgs>>
    ): Prisma__RoomTypesClient<$Result.GetResult<Prisma.$RoomTypesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoomTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypesFindFirstOrThrowArgs} args - Arguments to find a RoomTypes
     * @example
     * // Get one RoomTypes
     * const roomTypes = await prisma.roomTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomTypesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTypesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomTypesClient<$Result.GetResult<Prisma.$RoomTypesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoomTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomTypes
     * const roomTypes = await prisma.roomTypes.findMany()
     * 
     * // Get first 10 RoomTypes
     * const roomTypes = await prisma.roomTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomTypesWithIdOnly = await prisma.roomTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomTypesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTypesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoomTypes.
     * @param {RoomTypesCreateArgs} args - Arguments to create a RoomTypes.
     * @example
     * // Create one RoomTypes
     * const RoomTypes = await prisma.roomTypes.create({
     *   data: {
     *     // ... data to create a RoomTypes
     *   }
     * })
     * 
    **/
    create<T extends RoomTypesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTypesCreateArgs<ExtArgs>>
    ): Prisma__RoomTypesClient<$Result.GetResult<Prisma.$RoomTypesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoomTypes.
     *     @param {RoomTypesCreateManyArgs} args - Arguments to create many RoomTypes.
     *     @example
     *     // Create many RoomTypes
     *     const roomTypes = await prisma.roomTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomTypesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTypesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomTypes.
     * @param {RoomTypesDeleteArgs} args - Arguments to delete one RoomTypes.
     * @example
     * // Delete one RoomTypes
     * const RoomTypes = await prisma.roomTypes.delete({
     *   where: {
     *     // ... filter to delete one RoomTypes
     *   }
     * })
     * 
    **/
    delete<T extends RoomTypesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTypesDeleteArgs<ExtArgs>>
    ): Prisma__RoomTypesClient<$Result.GetResult<Prisma.$RoomTypesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoomTypes.
     * @param {RoomTypesUpdateArgs} args - Arguments to update one RoomTypes.
     * @example
     * // Update one RoomTypes
     * const roomTypes = await prisma.roomTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomTypesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTypesUpdateArgs<ExtArgs>>
    ): Prisma__RoomTypesClient<$Result.GetResult<Prisma.$RoomTypesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoomTypes.
     * @param {RoomTypesDeleteManyArgs} args - Arguments to filter RoomTypes to delete.
     * @example
     * // Delete a few RoomTypes
     * const { count } = await prisma.roomTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomTypesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTypesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomTypes
     * const roomTypes = await prisma.roomTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomTypesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTypesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomTypes.
     * @param {RoomTypesUpsertArgs} args - Arguments to update or create a RoomTypes.
     * @example
     * // Update or create a RoomTypes
     * const roomTypes = await prisma.roomTypes.upsert({
     *   create: {
     *     // ... data to create a RoomTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomTypes we want to update
     *   }
     * })
    **/
    upsert<T extends RoomTypesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTypesUpsertArgs<ExtArgs>>
    ): Prisma__RoomTypesClient<$Result.GetResult<Prisma.$RoomTypesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypesCountArgs} args - Arguments to filter RoomTypes to count.
     * @example
     * // Count the number of RoomTypes
     * const count = await prisma.roomTypes.count({
     *   where: {
     *     // ... the filter for the RoomTypes we want to count
     *   }
     * })
    **/
    count<T extends RoomTypesCountArgs>(
      args?: Subset<T, RoomTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomTypesAggregateArgs>(args: Subset<T, RoomTypesAggregateArgs>): Prisma.PrismaPromise<GetRoomTypesAggregateType<T>>

    /**
     * Group by RoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomTypesGroupByArgs['orderBy'] }
        : { orderBy?: RoomTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomTypes model
   */
  readonly fields: RoomTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomTypesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    furniture<T extends RoomTypes$furnitureArgs<ExtArgs> = {}>(args?: Subset<T, RoomTypes$furnitureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoomTypes model
   */ 
  interface RoomTypesFieldRefs {
    readonly id: FieldRef<"RoomTypes", 'Int'>
    readonly name: FieldRef<"RoomTypes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoomTypes findUnique
   */
  export type RoomTypesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypes
     */
    select?: RoomTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypesInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypes to fetch.
     */
    where: RoomTypesWhereUniqueInput
  }

  /**
   * RoomTypes findUniqueOrThrow
   */
  export type RoomTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypes
     */
    select?: RoomTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypesInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypes to fetch.
     */
    where: RoomTypesWhereUniqueInput
  }

  /**
   * RoomTypes findFirst
   */
  export type RoomTypesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypes
     */
    select?: RoomTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypesInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypes to fetch.
     */
    where?: RoomTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypesOrderByWithRelationInput | RoomTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTypes.
     */
    cursor?: RoomTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTypes.
     */
    distinct?: RoomTypesScalarFieldEnum | RoomTypesScalarFieldEnum[]
  }

  /**
   * RoomTypes findFirstOrThrow
   */
  export type RoomTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypes
     */
    select?: RoomTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypesInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypes to fetch.
     */
    where?: RoomTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypesOrderByWithRelationInput | RoomTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTypes.
     */
    cursor?: RoomTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTypes.
     */
    distinct?: RoomTypesScalarFieldEnum | RoomTypesScalarFieldEnum[]
  }

  /**
   * RoomTypes findMany
   */
  export type RoomTypesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypes
     */
    select?: RoomTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypesInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypes to fetch.
     */
    where?: RoomTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypesOrderByWithRelationInput | RoomTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomTypes.
     */
    cursor?: RoomTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    distinct?: RoomTypesScalarFieldEnum | RoomTypesScalarFieldEnum[]
  }

  /**
   * RoomTypes create
   */
  export type RoomTypesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypes
     */
    select?: RoomTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypesInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomTypes.
     */
    data: XOR<RoomTypesCreateInput, RoomTypesUncheckedCreateInput>
  }

  /**
   * RoomTypes createMany
   */
  export type RoomTypesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomTypes.
     */
    data: RoomTypesCreateManyInput | RoomTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomTypes update
   */
  export type RoomTypesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypes
     */
    select?: RoomTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypesInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomTypes.
     */
    data: XOR<RoomTypesUpdateInput, RoomTypesUncheckedUpdateInput>
    /**
     * Choose, which RoomTypes to update.
     */
    where: RoomTypesWhereUniqueInput
  }

  /**
   * RoomTypes updateMany
   */
  export type RoomTypesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomTypes.
     */
    data: XOR<RoomTypesUpdateManyMutationInput, RoomTypesUncheckedUpdateManyInput>
    /**
     * Filter which RoomTypes to update
     */
    where?: RoomTypesWhereInput
  }

  /**
   * RoomTypes upsert
   */
  export type RoomTypesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypes
     */
    select?: RoomTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypesInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomTypes to update in case it exists.
     */
    where: RoomTypesWhereUniqueInput
    /**
     * In case the RoomTypes found by the `where` argument doesn't exist, create a new RoomTypes with this data.
     */
    create: XOR<RoomTypesCreateInput, RoomTypesUncheckedCreateInput>
    /**
     * In case the RoomTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomTypesUpdateInput, RoomTypesUncheckedUpdateInput>
  }

  /**
   * RoomTypes delete
   */
  export type RoomTypesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypes
     */
    select?: RoomTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypesInclude<ExtArgs> | null
    /**
     * Filter which RoomTypes to delete.
     */
    where: RoomTypesWhereUniqueInput
  }

  /**
   * RoomTypes deleteMany
   */
  export type RoomTypesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomTypes to delete
     */
    where?: RoomTypesWhereInput
  }

  /**
   * RoomTypes.furniture
   */
  export type RoomTypes$furnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    where?: FurnitureWhereInput
    orderBy?: FurnitureOrderByWithRelationInput | FurnitureOrderByWithRelationInput[]
    cursor?: FurnitureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FurnitureScalarFieldEnum | FurnitureScalarFieldEnum[]
  }

  /**
   * RoomTypes without action
   */
  export type RoomTypesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypes
     */
    select?: RoomTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypesInclude<ExtArgs> | null
  }


  /**
   * Model FurnitureTypes
   */

  export type AggregateFurnitureTypes = {
    _count: FurnitureTypesCountAggregateOutputType | null
    _avg: FurnitureTypesAvgAggregateOutputType | null
    _sum: FurnitureTypesSumAggregateOutputType | null
    _min: FurnitureTypesMinAggregateOutputType | null
    _max: FurnitureTypesMaxAggregateOutputType | null
  }

  export type FurnitureTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type FurnitureTypesSumAggregateOutputType = {
    id: number | null
  }

  export type FurnitureTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type FurnitureTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type FurnitureTypesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type FurnitureTypesAvgAggregateInputType = {
    id?: true
  }

  export type FurnitureTypesSumAggregateInputType = {
    id?: true
  }

  export type FurnitureTypesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type FurnitureTypesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type FurnitureTypesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type FurnitureTypesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FurnitureTypes to aggregate.
     */
    where?: FurnitureTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurnitureTypes to fetch.
     */
    orderBy?: FurnitureTypesOrderByWithRelationInput | FurnitureTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FurnitureTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurnitureTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurnitureTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FurnitureTypes
    **/
    _count?: true | FurnitureTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FurnitureTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FurnitureTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FurnitureTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FurnitureTypesMaxAggregateInputType
  }

  export type GetFurnitureTypesAggregateType<T extends FurnitureTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateFurnitureTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFurnitureTypes[P]>
      : GetScalarType<T[P], AggregateFurnitureTypes[P]>
  }




  export type FurnitureTypesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurnitureTypesWhereInput
    orderBy?: FurnitureTypesOrderByWithAggregationInput | FurnitureTypesOrderByWithAggregationInput[]
    by: FurnitureTypesScalarFieldEnum[] | FurnitureTypesScalarFieldEnum
    having?: FurnitureTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FurnitureTypesCountAggregateInputType | true
    _avg?: FurnitureTypesAvgAggregateInputType
    _sum?: FurnitureTypesSumAggregateInputType
    _min?: FurnitureTypesMinAggregateInputType
    _max?: FurnitureTypesMaxAggregateInputType
  }

  export type FurnitureTypesGroupByOutputType = {
    id: number
    name: string
    _count: FurnitureTypesCountAggregateOutputType | null
    _avg: FurnitureTypesAvgAggregateOutputType | null
    _sum: FurnitureTypesSumAggregateOutputType | null
    _min: FurnitureTypesMinAggregateOutputType | null
    _max: FurnitureTypesMaxAggregateOutputType | null
  }

  type GetFurnitureTypesGroupByPayload<T extends FurnitureTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FurnitureTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FurnitureTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FurnitureTypesGroupByOutputType[P]>
            : GetScalarType<T[P], FurnitureTypesGroupByOutputType[P]>
        }
      >
    >


  export type FurnitureTypesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    furniture?: boolean | FurnitureTypes$furnitureArgs<ExtArgs>
    _count?: boolean | FurnitureTypesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["furnitureTypes"]>

  export type FurnitureTypesSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type FurnitureTypesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    furniture?: boolean | FurnitureTypes$furnitureArgs<ExtArgs>
    _count?: boolean | FurnitureTypesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FurnitureTypesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FurnitureTypes"
    objects: {
      furniture: Prisma.$FurniturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["furnitureTypes"]>
    composites: {}
  }


  type FurnitureTypesGetPayload<S extends boolean | null | undefined | FurnitureTypesDefaultArgs> = $Result.GetResult<Prisma.$FurnitureTypesPayload, S>

  type FurnitureTypesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FurnitureTypesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FurnitureTypesCountAggregateInputType | true
    }

  export interface FurnitureTypesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FurnitureTypes'], meta: { name: 'FurnitureTypes' } }
    /**
     * Find zero or one FurnitureTypes that matches the filter.
     * @param {FurnitureTypesFindUniqueArgs} args - Arguments to find a FurnitureTypes
     * @example
     * // Get one FurnitureTypes
     * const furnitureTypes = await prisma.furnitureTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FurnitureTypesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureTypesFindUniqueArgs<ExtArgs>>
    ): Prisma__FurnitureTypesClient<$Result.GetResult<Prisma.$FurnitureTypesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FurnitureTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FurnitureTypesFindUniqueOrThrowArgs} args - Arguments to find a FurnitureTypes
     * @example
     * // Get one FurnitureTypes
     * const furnitureTypes = await prisma.furnitureTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FurnitureTypesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureTypesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FurnitureTypesClient<$Result.GetResult<Prisma.$FurnitureTypesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FurnitureTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureTypesFindFirstArgs} args - Arguments to find a FurnitureTypes
     * @example
     * // Get one FurnitureTypes
     * const furnitureTypes = await prisma.furnitureTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FurnitureTypesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureTypesFindFirstArgs<ExtArgs>>
    ): Prisma__FurnitureTypesClient<$Result.GetResult<Prisma.$FurnitureTypesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FurnitureTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureTypesFindFirstOrThrowArgs} args - Arguments to find a FurnitureTypes
     * @example
     * // Get one FurnitureTypes
     * const furnitureTypes = await prisma.furnitureTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FurnitureTypesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureTypesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FurnitureTypesClient<$Result.GetResult<Prisma.$FurnitureTypesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FurnitureTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FurnitureTypes
     * const furnitureTypes = await prisma.furnitureTypes.findMany()
     * 
     * // Get first 10 FurnitureTypes
     * const furnitureTypes = await prisma.furnitureTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const furnitureTypesWithIdOnly = await prisma.furnitureTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FurnitureTypesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureTypesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurnitureTypesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FurnitureTypes.
     * @param {FurnitureTypesCreateArgs} args - Arguments to create a FurnitureTypes.
     * @example
     * // Create one FurnitureTypes
     * const FurnitureTypes = await prisma.furnitureTypes.create({
     *   data: {
     *     // ... data to create a FurnitureTypes
     *   }
     * })
     * 
    **/
    create<T extends FurnitureTypesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureTypesCreateArgs<ExtArgs>>
    ): Prisma__FurnitureTypesClient<$Result.GetResult<Prisma.$FurnitureTypesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FurnitureTypes.
     *     @param {FurnitureTypesCreateManyArgs} args - Arguments to create many FurnitureTypes.
     *     @example
     *     // Create many FurnitureTypes
     *     const furnitureTypes = await prisma.furnitureTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FurnitureTypesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureTypesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FurnitureTypes.
     * @param {FurnitureTypesDeleteArgs} args - Arguments to delete one FurnitureTypes.
     * @example
     * // Delete one FurnitureTypes
     * const FurnitureTypes = await prisma.furnitureTypes.delete({
     *   where: {
     *     // ... filter to delete one FurnitureTypes
     *   }
     * })
     * 
    **/
    delete<T extends FurnitureTypesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureTypesDeleteArgs<ExtArgs>>
    ): Prisma__FurnitureTypesClient<$Result.GetResult<Prisma.$FurnitureTypesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FurnitureTypes.
     * @param {FurnitureTypesUpdateArgs} args - Arguments to update one FurnitureTypes.
     * @example
     * // Update one FurnitureTypes
     * const furnitureTypes = await prisma.furnitureTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FurnitureTypesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureTypesUpdateArgs<ExtArgs>>
    ): Prisma__FurnitureTypesClient<$Result.GetResult<Prisma.$FurnitureTypesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FurnitureTypes.
     * @param {FurnitureTypesDeleteManyArgs} args - Arguments to filter FurnitureTypes to delete.
     * @example
     * // Delete a few FurnitureTypes
     * const { count } = await prisma.furnitureTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FurnitureTypesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureTypesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FurnitureTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FurnitureTypes
     * const furnitureTypes = await prisma.furnitureTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FurnitureTypesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureTypesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FurnitureTypes.
     * @param {FurnitureTypesUpsertArgs} args - Arguments to update or create a FurnitureTypes.
     * @example
     * // Update or create a FurnitureTypes
     * const furnitureTypes = await prisma.furnitureTypes.upsert({
     *   create: {
     *     // ... data to create a FurnitureTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FurnitureTypes we want to update
     *   }
     * })
    **/
    upsert<T extends FurnitureTypesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureTypesUpsertArgs<ExtArgs>>
    ): Prisma__FurnitureTypesClient<$Result.GetResult<Prisma.$FurnitureTypesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FurnitureTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureTypesCountArgs} args - Arguments to filter FurnitureTypes to count.
     * @example
     * // Count the number of FurnitureTypes
     * const count = await prisma.furnitureTypes.count({
     *   where: {
     *     // ... the filter for the FurnitureTypes we want to count
     *   }
     * })
    **/
    count<T extends FurnitureTypesCountArgs>(
      args?: Subset<T, FurnitureTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FurnitureTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FurnitureTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FurnitureTypesAggregateArgs>(args: Subset<T, FurnitureTypesAggregateArgs>): Prisma.PrismaPromise<GetFurnitureTypesAggregateType<T>>

    /**
     * Group by FurnitureTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FurnitureTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FurnitureTypesGroupByArgs['orderBy'] }
        : { orderBy?: FurnitureTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FurnitureTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFurnitureTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FurnitureTypes model
   */
  readonly fields: FurnitureTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FurnitureTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FurnitureTypesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    furniture<T extends FurnitureTypes$furnitureArgs<ExtArgs> = {}>(args?: Subset<T, FurnitureTypes$furnitureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FurnitureTypes model
   */ 
  interface FurnitureTypesFieldRefs {
    readonly id: FieldRef<"FurnitureTypes", 'Int'>
    readonly name: FieldRef<"FurnitureTypes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FurnitureTypes findUnique
   */
  export type FurnitureTypesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureTypes
     */
    select?: FurnitureTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureTypesInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureTypes to fetch.
     */
    where: FurnitureTypesWhereUniqueInput
  }

  /**
   * FurnitureTypes findUniqueOrThrow
   */
  export type FurnitureTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureTypes
     */
    select?: FurnitureTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureTypesInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureTypes to fetch.
     */
    where: FurnitureTypesWhereUniqueInput
  }

  /**
   * FurnitureTypes findFirst
   */
  export type FurnitureTypesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureTypes
     */
    select?: FurnitureTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureTypesInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureTypes to fetch.
     */
    where?: FurnitureTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurnitureTypes to fetch.
     */
    orderBy?: FurnitureTypesOrderByWithRelationInput | FurnitureTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FurnitureTypes.
     */
    cursor?: FurnitureTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurnitureTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurnitureTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FurnitureTypes.
     */
    distinct?: FurnitureTypesScalarFieldEnum | FurnitureTypesScalarFieldEnum[]
  }

  /**
   * FurnitureTypes findFirstOrThrow
   */
  export type FurnitureTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureTypes
     */
    select?: FurnitureTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureTypesInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureTypes to fetch.
     */
    where?: FurnitureTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurnitureTypes to fetch.
     */
    orderBy?: FurnitureTypesOrderByWithRelationInput | FurnitureTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FurnitureTypes.
     */
    cursor?: FurnitureTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurnitureTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurnitureTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FurnitureTypes.
     */
    distinct?: FurnitureTypesScalarFieldEnum | FurnitureTypesScalarFieldEnum[]
  }

  /**
   * FurnitureTypes findMany
   */
  export type FurnitureTypesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureTypes
     */
    select?: FurnitureTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureTypesInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureTypes to fetch.
     */
    where?: FurnitureTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurnitureTypes to fetch.
     */
    orderBy?: FurnitureTypesOrderByWithRelationInput | FurnitureTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FurnitureTypes.
     */
    cursor?: FurnitureTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurnitureTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurnitureTypes.
     */
    skip?: number
    distinct?: FurnitureTypesScalarFieldEnum | FurnitureTypesScalarFieldEnum[]
  }

  /**
   * FurnitureTypes create
   */
  export type FurnitureTypesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureTypes
     */
    select?: FurnitureTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureTypesInclude<ExtArgs> | null
    /**
     * The data needed to create a FurnitureTypes.
     */
    data: XOR<FurnitureTypesCreateInput, FurnitureTypesUncheckedCreateInput>
  }

  /**
   * FurnitureTypes createMany
   */
  export type FurnitureTypesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FurnitureTypes.
     */
    data: FurnitureTypesCreateManyInput | FurnitureTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FurnitureTypes update
   */
  export type FurnitureTypesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureTypes
     */
    select?: FurnitureTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureTypesInclude<ExtArgs> | null
    /**
     * The data needed to update a FurnitureTypes.
     */
    data: XOR<FurnitureTypesUpdateInput, FurnitureTypesUncheckedUpdateInput>
    /**
     * Choose, which FurnitureTypes to update.
     */
    where: FurnitureTypesWhereUniqueInput
  }

  /**
   * FurnitureTypes updateMany
   */
  export type FurnitureTypesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FurnitureTypes.
     */
    data: XOR<FurnitureTypesUpdateManyMutationInput, FurnitureTypesUncheckedUpdateManyInput>
    /**
     * Filter which FurnitureTypes to update
     */
    where?: FurnitureTypesWhereInput
  }

  /**
   * FurnitureTypes upsert
   */
  export type FurnitureTypesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureTypes
     */
    select?: FurnitureTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureTypesInclude<ExtArgs> | null
    /**
     * The filter to search for the FurnitureTypes to update in case it exists.
     */
    where: FurnitureTypesWhereUniqueInput
    /**
     * In case the FurnitureTypes found by the `where` argument doesn't exist, create a new FurnitureTypes with this data.
     */
    create: XOR<FurnitureTypesCreateInput, FurnitureTypesUncheckedCreateInput>
    /**
     * In case the FurnitureTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FurnitureTypesUpdateInput, FurnitureTypesUncheckedUpdateInput>
  }

  /**
   * FurnitureTypes delete
   */
  export type FurnitureTypesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureTypes
     */
    select?: FurnitureTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureTypesInclude<ExtArgs> | null
    /**
     * Filter which FurnitureTypes to delete.
     */
    where: FurnitureTypesWhereUniqueInput
  }

  /**
   * FurnitureTypes deleteMany
   */
  export type FurnitureTypesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FurnitureTypes to delete
     */
    where?: FurnitureTypesWhereInput
  }

  /**
   * FurnitureTypes.furniture
   */
  export type FurnitureTypes$furnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    where?: FurnitureWhereInput
    orderBy?: FurnitureOrderByWithRelationInput | FurnitureOrderByWithRelationInput[]
    cursor?: FurnitureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FurnitureScalarFieldEnum | FurnitureScalarFieldEnum[]
  }

  /**
   * FurnitureTypes without action
   */
  export type FurnitureTypesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureTypes
     */
    select?: FurnitureTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureTypesInclude<ExtArgs> | null
  }


  /**
   * Model FurniturePhotos
   */

  export type AggregateFurniturePhotos = {
    _count: FurniturePhotosCountAggregateOutputType | null
    _avg: FurniturePhotosAvgAggregateOutputType | null
    _sum: FurniturePhotosSumAggregateOutputType | null
    _min: FurniturePhotosMinAggregateOutputType | null
    _max: FurniturePhotosMaxAggregateOutputType | null
  }

  export type FurniturePhotosAvgAggregateOutputType = {
    id: number | null
    furniture_id: number | null
  }

  export type FurniturePhotosSumAggregateOutputType = {
    id: number | null
    furniture_id: number | null
  }

  export type FurniturePhotosMinAggregateOutputType = {
    id: number | null
    furniture_id: number | null
    url: string | null
    caption: string | null
  }

  export type FurniturePhotosMaxAggregateOutputType = {
    id: number | null
    furniture_id: number | null
    url: string | null
    caption: string | null
  }

  export type FurniturePhotosCountAggregateOutputType = {
    id: number
    furniture_id: number
    url: number
    caption: number
    _all: number
  }


  export type FurniturePhotosAvgAggregateInputType = {
    id?: true
    furniture_id?: true
  }

  export type FurniturePhotosSumAggregateInputType = {
    id?: true
    furniture_id?: true
  }

  export type FurniturePhotosMinAggregateInputType = {
    id?: true
    furniture_id?: true
    url?: true
    caption?: true
  }

  export type FurniturePhotosMaxAggregateInputType = {
    id?: true
    furniture_id?: true
    url?: true
    caption?: true
  }

  export type FurniturePhotosCountAggregateInputType = {
    id?: true
    furniture_id?: true
    url?: true
    caption?: true
    _all?: true
  }

  export type FurniturePhotosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FurniturePhotos to aggregate.
     */
    where?: FurniturePhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurniturePhotos to fetch.
     */
    orderBy?: FurniturePhotosOrderByWithRelationInput | FurniturePhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FurniturePhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurniturePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurniturePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FurniturePhotos
    **/
    _count?: true | FurniturePhotosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FurniturePhotosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FurniturePhotosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FurniturePhotosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FurniturePhotosMaxAggregateInputType
  }

  export type GetFurniturePhotosAggregateType<T extends FurniturePhotosAggregateArgs> = {
        [P in keyof T & keyof AggregateFurniturePhotos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFurniturePhotos[P]>
      : GetScalarType<T[P], AggregateFurniturePhotos[P]>
  }




  export type FurniturePhotosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurniturePhotosWhereInput
    orderBy?: FurniturePhotosOrderByWithAggregationInput | FurniturePhotosOrderByWithAggregationInput[]
    by: FurniturePhotosScalarFieldEnum[] | FurniturePhotosScalarFieldEnum
    having?: FurniturePhotosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FurniturePhotosCountAggregateInputType | true
    _avg?: FurniturePhotosAvgAggregateInputType
    _sum?: FurniturePhotosSumAggregateInputType
    _min?: FurniturePhotosMinAggregateInputType
    _max?: FurniturePhotosMaxAggregateInputType
  }

  export type FurniturePhotosGroupByOutputType = {
    id: number
    furniture_id: number | null
    url: string
    caption: string
    _count: FurniturePhotosCountAggregateOutputType | null
    _avg: FurniturePhotosAvgAggregateOutputType | null
    _sum: FurniturePhotosSumAggregateOutputType | null
    _min: FurniturePhotosMinAggregateOutputType | null
    _max: FurniturePhotosMaxAggregateOutputType | null
  }

  type GetFurniturePhotosGroupByPayload<T extends FurniturePhotosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FurniturePhotosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FurniturePhotosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FurniturePhotosGroupByOutputType[P]>
            : GetScalarType<T[P], FurniturePhotosGroupByOutputType[P]>
        }
      >
    >


  export type FurniturePhotosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    furniture_id?: boolean
    url?: boolean
    caption?: boolean
    Furniture?: boolean | FurniturePhotos$FurnitureArgs<ExtArgs>
  }, ExtArgs["result"]["furniturePhotos"]>

  export type FurniturePhotosSelectScalar = {
    id?: boolean
    furniture_id?: boolean
    url?: boolean
    caption?: boolean
  }


  export type FurniturePhotosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Furniture?: boolean | FurniturePhotos$FurnitureArgs<ExtArgs>
  }


  export type $FurniturePhotosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FurniturePhotos"
    objects: {
      Furniture: Prisma.$FurniturePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      furniture_id: number | null
      url: string
      caption: string
    }, ExtArgs["result"]["furniturePhotos"]>
    composites: {}
  }


  type FurniturePhotosGetPayload<S extends boolean | null | undefined | FurniturePhotosDefaultArgs> = $Result.GetResult<Prisma.$FurniturePhotosPayload, S>

  type FurniturePhotosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FurniturePhotosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FurniturePhotosCountAggregateInputType | true
    }

  export interface FurniturePhotosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FurniturePhotos'], meta: { name: 'FurniturePhotos' } }
    /**
     * Find zero or one FurniturePhotos that matches the filter.
     * @param {FurniturePhotosFindUniqueArgs} args - Arguments to find a FurniturePhotos
     * @example
     * // Get one FurniturePhotos
     * const furniturePhotos = await prisma.furniturePhotos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FurniturePhotosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FurniturePhotosFindUniqueArgs<ExtArgs>>
    ): Prisma__FurniturePhotosClient<$Result.GetResult<Prisma.$FurniturePhotosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FurniturePhotos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FurniturePhotosFindUniqueOrThrowArgs} args - Arguments to find a FurniturePhotos
     * @example
     * // Get one FurniturePhotos
     * const furniturePhotos = await prisma.furniturePhotos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FurniturePhotosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FurniturePhotosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FurniturePhotosClient<$Result.GetResult<Prisma.$FurniturePhotosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FurniturePhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurniturePhotosFindFirstArgs} args - Arguments to find a FurniturePhotos
     * @example
     * // Get one FurniturePhotos
     * const furniturePhotos = await prisma.furniturePhotos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FurniturePhotosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FurniturePhotosFindFirstArgs<ExtArgs>>
    ): Prisma__FurniturePhotosClient<$Result.GetResult<Prisma.$FurniturePhotosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FurniturePhotos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurniturePhotosFindFirstOrThrowArgs} args - Arguments to find a FurniturePhotos
     * @example
     * // Get one FurniturePhotos
     * const furniturePhotos = await prisma.furniturePhotos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FurniturePhotosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FurniturePhotosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FurniturePhotosClient<$Result.GetResult<Prisma.$FurniturePhotosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FurniturePhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurniturePhotosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FurniturePhotos
     * const furniturePhotos = await prisma.furniturePhotos.findMany()
     * 
     * // Get first 10 FurniturePhotos
     * const furniturePhotos = await prisma.furniturePhotos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const furniturePhotosWithIdOnly = await prisma.furniturePhotos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FurniturePhotosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurniturePhotosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurniturePhotosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FurniturePhotos.
     * @param {FurniturePhotosCreateArgs} args - Arguments to create a FurniturePhotos.
     * @example
     * // Create one FurniturePhotos
     * const FurniturePhotos = await prisma.furniturePhotos.create({
     *   data: {
     *     // ... data to create a FurniturePhotos
     *   }
     * })
     * 
    **/
    create<T extends FurniturePhotosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FurniturePhotosCreateArgs<ExtArgs>>
    ): Prisma__FurniturePhotosClient<$Result.GetResult<Prisma.$FurniturePhotosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FurniturePhotos.
     *     @param {FurniturePhotosCreateManyArgs} args - Arguments to create many FurniturePhotos.
     *     @example
     *     // Create many FurniturePhotos
     *     const furniturePhotos = await prisma.furniturePhotos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FurniturePhotosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurniturePhotosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FurniturePhotos.
     * @param {FurniturePhotosDeleteArgs} args - Arguments to delete one FurniturePhotos.
     * @example
     * // Delete one FurniturePhotos
     * const FurniturePhotos = await prisma.furniturePhotos.delete({
     *   where: {
     *     // ... filter to delete one FurniturePhotos
     *   }
     * })
     * 
    **/
    delete<T extends FurniturePhotosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FurniturePhotosDeleteArgs<ExtArgs>>
    ): Prisma__FurniturePhotosClient<$Result.GetResult<Prisma.$FurniturePhotosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FurniturePhotos.
     * @param {FurniturePhotosUpdateArgs} args - Arguments to update one FurniturePhotos.
     * @example
     * // Update one FurniturePhotos
     * const furniturePhotos = await prisma.furniturePhotos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FurniturePhotosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FurniturePhotosUpdateArgs<ExtArgs>>
    ): Prisma__FurniturePhotosClient<$Result.GetResult<Prisma.$FurniturePhotosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FurniturePhotos.
     * @param {FurniturePhotosDeleteManyArgs} args - Arguments to filter FurniturePhotos to delete.
     * @example
     * // Delete a few FurniturePhotos
     * const { count } = await prisma.furniturePhotos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FurniturePhotosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurniturePhotosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FurniturePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurniturePhotosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FurniturePhotos
     * const furniturePhotos = await prisma.furniturePhotos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FurniturePhotosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FurniturePhotosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FurniturePhotos.
     * @param {FurniturePhotosUpsertArgs} args - Arguments to update or create a FurniturePhotos.
     * @example
     * // Update or create a FurniturePhotos
     * const furniturePhotos = await prisma.furniturePhotos.upsert({
     *   create: {
     *     // ... data to create a FurniturePhotos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FurniturePhotos we want to update
     *   }
     * })
    **/
    upsert<T extends FurniturePhotosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FurniturePhotosUpsertArgs<ExtArgs>>
    ): Prisma__FurniturePhotosClient<$Result.GetResult<Prisma.$FurniturePhotosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FurniturePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurniturePhotosCountArgs} args - Arguments to filter FurniturePhotos to count.
     * @example
     * // Count the number of FurniturePhotos
     * const count = await prisma.furniturePhotos.count({
     *   where: {
     *     // ... the filter for the FurniturePhotos we want to count
     *   }
     * })
    **/
    count<T extends FurniturePhotosCountArgs>(
      args?: Subset<T, FurniturePhotosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FurniturePhotosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FurniturePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurniturePhotosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FurniturePhotosAggregateArgs>(args: Subset<T, FurniturePhotosAggregateArgs>): Prisma.PrismaPromise<GetFurniturePhotosAggregateType<T>>

    /**
     * Group by FurniturePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurniturePhotosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FurniturePhotosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FurniturePhotosGroupByArgs['orderBy'] }
        : { orderBy?: FurniturePhotosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FurniturePhotosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFurniturePhotosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FurniturePhotos model
   */
  readonly fields: FurniturePhotosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FurniturePhotos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FurniturePhotosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Furniture<T extends FurniturePhotos$FurnitureArgs<ExtArgs> = {}>(args?: Subset<T, FurniturePhotos$FurnitureArgs<ExtArgs>>): Prisma__FurnitureClient<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FurniturePhotos model
   */ 
  interface FurniturePhotosFieldRefs {
    readonly id: FieldRef<"FurniturePhotos", 'Int'>
    readonly furniture_id: FieldRef<"FurniturePhotos", 'Int'>
    readonly url: FieldRef<"FurniturePhotos", 'String'>
    readonly caption: FieldRef<"FurniturePhotos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FurniturePhotos findUnique
   */
  export type FurniturePhotosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurniturePhotos
     */
    select?: FurniturePhotosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurniturePhotosInclude<ExtArgs> | null
    /**
     * Filter, which FurniturePhotos to fetch.
     */
    where: FurniturePhotosWhereUniqueInput
  }

  /**
   * FurniturePhotos findUniqueOrThrow
   */
  export type FurniturePhotosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurniturePhotos
     */
    select?: FurniturePhotosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurniturePhotosInclude<ExtArgs> | null
    /**
     * Filter, which FurniturePhotos to fetch.
     */
    where: FurniturePhotosWhereUniqueInput
  }

  /**
   * FurniturePhotos findFirst
   */
  export type FurniturePhotosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurniturePhotos
     */
    select?: FurniturePhotosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurniturePhotosInclude<ExtArgs> | null
    /**
     * Filter, which FurniturePhotos to fetch.
     */
    where?: FurniturePhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurniturePhotos to fetch.
     */
    orderBy?: FurniturePhotosOrderByWithRelationInput | FurniturePhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FurniturePhotos.
     */
    cursor?: FurniturePhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurniturePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurniturePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FurniturePhotos.
     */
    distinct?: FurniturePhotosScalarFieldEnum | FurniturePhotosScalarFieldEnum[]
  }

  /**
   * FurniturePhotos findFirstOrThrow
   */
  export type FurniturePhotosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurniturePhotos
     */
    select?: FurniturePhotosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurniturePhotosInclude<ExtArgs> | null
    /**
     * Filter, which FurniturePhotos to fetch.
     */
    where?: FurniturePhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurniturePhotos to fetch.
     */
    orderBy?: FurniturePhotosOrderByWithRelationInput | FurniturePhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FurniturePhotos.
     */
    cursor?: FurniturePhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurniturePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurniturePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FurniturePhotos.
     */
    distinct?: FurniturePhotosScalarFieldEnum | FurniturePhotosScalarFieldEnum[]
  }

  /**
   * FurniturePhotos findMany
   */
  export type FurniturePhotosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurniturePhotos
     */
    select?: FurniturePhotosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurniturePhotosInclude<ExtArgs> | null
    /**
     * Filter, which FurniturePhotos to fetch.
     */
    where?: FurniturePhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurniturePhotos to fetch.
     */
    orderBy?: FurniturePhotosOrderByWithRelationInput | FurniturePhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FurniturePhotos.
     */
    cursor?: FurniturePhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurniturePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurniturePhotos.
     */
    skip?: number
    distinct?: FurniturePhotosScalarFieldEnum | FurniturePhotosScalarFieldEnum[]
  }

  /**
   * FurniturePhotos create
   */
  export type FurniturePhotosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurniturePhotos
     */
    select?: FurniturePhotosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurniturePhotosInclude<ExtArgs> | null
    /**
     * The data needed to create a FurniturePhotos.
     */
    data: XOR<FurniturePhotosCreateInput, FurniturePhotosUncheckedCreateInput>
  }

  /**
   * FurniturePhotos createMany
   */
  export type FurniturePhotosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FurniturePhotos.
     */
    data: FurniturePhotosCreateManyInput | FurniturePhotosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FurniturePhotos update
   */
  export type FurniturePhotosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurniturePhotos
     */
    select?: FurniturePhotosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurniturePhotosInclude<ExtArgs> | null
    /**
     * The data needed to update a FurniturePhotos.
     */
    data: XOR<FurniturePhotosUpdateInput, FurniturePhotosUncheckedUpdateInput>
    /**
     * Choose, which FurniturePhotos to update.
     */
    where: FurniturePhotosWhereUniqueInput
  }

  /**
   * FurniturePhotos updateMany
   */
  export type FurniturePhotosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FurniturePhotos.
     */
    data: XOR<FurniturePhotosUpdateManyMutationInput, FurniturePhotosUncheckedUpdateManyInput>
    /**
     * Filter which FurniturePhotos to update
     */
    where?: FurniturePhotosWhereInput
  }

  /**
   * FurniturePhotos upsert
   */
  export type FurniturePhotosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurniturePhotos
     */
    select?: FurniturePhotosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurniturePhotosInclude<ExtArgs> | null
    /**
     * The filter to search for the FurniturePhotos to update in case it exists.
     */
    where: FurniturePhotosWhereUniqueInput
    /**
     * In case the FurniturePhotos found by the `where` argument doesn't exist, create a new FurniturePhotos with this data.
     */
    create: XOR<FurniturePhotosCreateInput, FurniturePhotosUncheckedCreateInput>
    /**
     * In case the FurniturePhotos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FurniturePhotosUpdateInput, FurniturePhotosUncheckedUpdateInput>
  }

  /**
   * FurniturePhotos delete
   */
  export type FurniturePhotosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurniturePhotos
     */
    select?: FurniturePhotosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurniturePhotosInclude<ExtArgs> | null
    /**
     * Filter which FurniturePhotos to delete.
     */
    where: FurniturePhotosWhereUniqueInput
  }

  /**
   * FurniturePhotos deleteMany
   */
  export type FurniturePhotosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FurniturePhotos to delete
     */
    where?: FurniturePhotosWhereInput
  }

  /**
   * FurniturePhotos.Furniture
   */
  export type FurniturePhotos$FurnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    where?: FurnitureWhereInput
  }

  /**
   * FurniturePhotos without action
   */
  export type FurniturePhotosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurniturePhotos
     */
    select?: FurniturePhotosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurniturePhotosInclude<ExtArgs> | null
  }


  /**
   * Model Furniture
   */

  export type AggregateFurniture = {
    _count: FurnitureCountAggregateOutputType | null
    _avg: FurnitureAvgAggregateOutputType | null
    _sum: FurnitureSumAggregateOutputType | null
    _min: FurnitureMinAggregateOutputType | null
    _max: FurnitureMaxAggregateOutputType | null
  }

  export type FurnitureAvgAggregateOutputType = {
    id: number | null
    colors_id: number | null
    materials_id: number | null
    roomTypes_id: number | null
    furniture_types_id: number | null
    height: Decimal | null
    width: Decimal | null
    price: Decimal | null
  }

  export type FurnitureSumAggregateOutputType = {
    id: number | null
    colors_id: number | null
    materials_id: number | null
    roomTypes_id: number | null
    furniture_types_id: number | null
    height: Decimal | null
    width: Decimal | null
    price: Decimal | null
  }

  export type FurnitureMinAggregateOutputType = {
    id: number | null
    name: string | null
    produced_date: string | null
    colors_id: number | null
    materials_id: number | null
    roomTypes_id: number | null
    furniture_types_id: number | null
    description: string | null
    height: Decimal | null
    width: Decimal | null
    price: Decimal | null
  }

  export type FurnitureMaxAggregateOutputType = {
    id: number | null
    name: string | null
    produced_date: string | null
    colors_id: number | null
    materials_id: number | null
    roomTypes_id: number | null
    furniture_types_id: number | null
    description: string | null
    height: Decimal | null
    width: Decimal | null
    price: Decimal | null
  }

  export type FurnitureCountAggregateOutputType = {
    id: number
    name: number
    produced_date: number
    colors_id: number
    materials_id: number
    roomTypes_id: number
    furniture_types_id: number
    description: number
    height: number
    width: number
    price: number
    _all: number
  }


  export type FurnitureAvgAggregateInputType = {
    id?: true
    colors_id?: true
    materials_id?: true
    roomTypes_id?: true
    furniture_types_id?: true
    height?: true
    width?: true
    price?: true
  }

  export type FurnitureSumAggregateInputType = {
    id?: true
    colors_id?: true
    materials_id?: true
    roomTypes_id?: true
    furniture_types_id?: true
    height?: true
    width?: true
    price?: true
  }

  export type FurnitureMinAggregateInputType = {
    id?: true
    name?: true
    produced_date?: true
    colors_id?: true
    materials_id?: true
    roomTypes_id?: true
    furniture_types_id?: true
    description?: true
    height?: true
    width?: true
    price?: true
  }

  export type FurnitureMaxAggregateInputType = {
    id?: true
    name?: true
    produced_date?: true
    colors_id?: true
    materials_id?: true
    roomTypes_id?: true
    furniture_types_id?: true
    description?: true
    height?: true
    width?: true
    price?: true
  }

  export type FurnitureCountAggregateInputType = {
    id?: true
    name?: true
    produced_date?: true
    colors_id?: true
    materials_id?: true
    roomTypes_id?: true
    furniture_types_id?: true
    description?: true
    height?: true
    width?: true
    price?: true
    _all?: true
  }

  export type FurnitureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Furniture to aggregate.
     */
    where?: FurnitureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Furnitures to fetch.
     */
    orderBy?: FurnitureOrderByWithRelationInput | FurnitureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FurnitureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Furnitures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Furnitures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Furnitures
    **/
    _count?: true | FurnitureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FurnitureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FurnitureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FurnitureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FurnitureMaxAggregateInputType
  }

  export type GetFurnitureAggregateType<T extends FurnitureAggregateArgs> = {
        [P in keyof T & keyof AggregateFurniture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFurniture[P]>
      : GetScalarType<T[P], AggregateFurniture[P]>
  }




  export type FurnitureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurnitureWhereInput
    orderBy?: FurnitureOrderByWithAggregationInput | FurnitureOrderByWithAggregationInput[]
    by: FurnitureScalarFieldEnum[] | FurnitureScalarFieldEnum
    having?: FurnitureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FurnitureCountAggregateInputType | true
    _avg?: FurnitureAvgAggregateInputType
    _sum?: FurnitureSumAggregateInputType
    _min?: FurnitureMinAggregateInputType
    _max?: FurnitureMaxAggregateInputType
  }

  export type FurnitureGroupByOutputType = {
    id: number
    name: string
    produced_date: string
    colors_id: number | null
    materials_id: number | null
    roomTypes_id: number | null
    furniture_types_id: number | null
    description: string
    height: Decimal
    width: Decimal
    price: Decimal
    _count: FurnitureCountAggregateOutputType | null
    _avg: FurnitureAvgAggregateOutputType | null
    _sum: FurnitureSumAggregateOutputType | null
    _min: FurnitureMinAggregateOutputType | null
    _max: FurnitureMaxAggregateOutputType | null
  }

  type GetFurnitureGroupByPayload<T extends FurnitureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FurnitureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FurnitureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FurnitureGroupByOutputType[P]>
            : GetScalarType<T[P], FurnitureGroupByOutputType[P]>
        }
      >
    >


  export type FurnitureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    produced_date?: boolean
    colors_id?: boolean
    materials_id?: boolean
    roomTypes_id?: boolean
    furniture_types_id?: boolean
    description?: boolean
    height?: boolean
    width?: boolean
    price?: boolean
    Colors?: boolean | Furniture$ColorsArgs<ExtArgs>
    Materials?: boolean | Furniture$MaterialsArgs<ExtArgs>
    RoomTypes?: boolean | Furniture$RoomTypesArgs<ExtArgs>
    FurnitureTypes?: boolean | Furniture$FurnitureTypesArgs<ExtArgs>
    furniture_photos?: boolean | Furniture$furniture_photosArgs<ExtArgs>
    furniture_comments?: boolean | Furniture$furniture_commentsArgs<ExtArgs>
    furniture_likes?: boolean | Furniture$furniture_likesArgs<ExtArgs>
    contracts_detailing?: boolean | Furniture$contracts_detailingArgs<ExtArgs>
    _count?: boolean | FurnitureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["furniture"]>

  export type FurnitureSelectScalar = {
    id?: boolean
    name?: boolean
    produced_date?: boolean
    colors_id?: boolean
    materials_id?: boolean
    roomTypes_id?: boolean
    furniture_types_id?: boolean
    description?: boolean
    height?: boolean
    width?: boolean
    price?: boolean
  }


  export type FurnitureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Colors?: boolean | Furniture$ColorsArgs<ExtArgs>
    Materials?: boolean | Furniture$MaterialsArgs<ExtArgs>
    RoomTypes?: boolean | Furniture$RoomTypesArgs<ExtArgs>
    FurnitureTypes?: boolean | Furniture$FurnitureTypesArgs<ExtArgs>
    furniture_photos?: boolean | Furniture$furniture_photosArgs<ExtArgs>
    furniture_comments?: boolean | Furniture$furniture_commentsArgs<ExtArgs>
    furniture_likes?: boolean | Furniture$furniture_likesArgs<ExtArgs>
    contracts_detailing?: boolean | Furniture$contracts_detailingArgs<ExtArgs>
    _count?: boolean | FurnitureCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FurniturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Furniture"
    objects: {
      Colors: Prisma.$ColorsPayload<ExtArgs> | null
      Materials: Prisma.$MaterialsPayload<ExtArgs> | null
      RoomTypes: Prisma.$RoomTypesPayload<ExtArgs> | null
      FurnitureTypes: Prisma.$FurnitureTypesPayload<ExtArgs> | null
      furniture_photos: Prisma.$FurniturePhotosPayload<ExtArgs>[]
      furniture_comments: Prisma.$FurnitureCommentsPayload<ExtArgs>[]
      furniture_likes: Prisma.$FurnitureLikesPayload<ExtArgs>[]
      contracts_detailing: Prisma.$ContractsDetailingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      produced_date: string
      colors_id: number | null
      materials_id: number | null
      roomTypes_id: number | null
      furniture_types_id: number | null
      description: string
      height: Prisma.Decimal
      width: Prisma.Decimal
      price: Prisma.Decimal
    }, ExtArgs["result"]["furniture"]>
    composites: {}
  }


  type FurnitureGetPayload<S extends boolean | null | undefined | FurnitureDefaultArgs> = $Result.GetResult<Prisma.$FurniturePayload, S>

  type FurnitureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FurnitureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FurnitureCountAggregateInputType | true
    }

  export interface FurnitureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Furniture'], meta: { name: 'Furniture' } }
    /**
     * Find zero or one Furniture that matches the filter.
     * @param {FurnitureFindUniqueArgs} args - Arguments to find a Furniture
     * @example
     * // Get one Furniture
     * const furniture = await prisma.furniture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FurnitureFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureFindUniqueArgs<ExtArgs>>
    ): Prisma__FurnitureClient<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Furniture that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FurnitureFindUniqueOrThrowArgs} args - Arguments to find a Furniture
     * @example
     * // Get one Furniture
     * const furniture = await prisma.furniture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FurnitureFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FurnitureClient<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Furniture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureFindFirstArgs} args - Arguments to find a Furniture
     * @example
     * // Get one Furniture
     * const furniture = await prisma.furniture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FurnitureFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureFindFirstArgs<ExtArgs>>
    ): Prisma__FurnitureClient<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Furniture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureFindFirstOrThrowArgs} args - Arguments to find a Furniture
     * @example
     * // Get one Furniture
     * const furniture = await prisma.furniture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FurnitureFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FurnitureClient<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Furnitures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Furnitures
     * const furnitures = await prisma.furniture.findMany()
     * 
     * // Get first 10 Furnitures
     * const furnitures = await prisma.furniture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const furnitureWithIdOnly = await prisma.furniture.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FurnitureFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Furniture.
     * @param {FurnitureCreateArgs} args - Arguments to create a Furniture.
     * @example
     * // Create one Furniture
     * const Furniture = await prisma.furniture.create({
     *   data: {
     *     // ... data to create a Furniture
     *   }
     * })
     * 
    **/
    create<T extends FurnitureCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureCreateArgs<ExtArgs>>
    ): Prisma__FurnitureClient<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Furnitures.
     *     @param {FurnitureCreateManyArgs} args - Arguments to create many Furnitures.
     *     @example
     *     // Create many Furnitures
     *     const furniture = await prisma.furniture.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FurnitureCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Furniture.
     * @param {FurnitureDeleteArgs} args - Arguments to delete one Furniture.
     * @example
     * // Delete one Furniture
     * const Furniture = await prisma.furniture.delete({
     *   where: {
     *     // ... filter to delete one Furniture
     *   }
     * })
     * 
    **/
    delete<T extends FurnitureDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureDeleteArgs<ExtArgs>>
    ): Prisma__FurnitureClient<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Furniture.
     * @param {FurnitureUpdateArgs} args - Arguments to update one Furniture.
     * @example
     * // Update one Furniture
     * const furniture = await prisma.furniture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FurnitureUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureUpdateArgs<ExtArgs>>
    ): Prisma__FurnitureClient<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Furnitures.
     * @param {FurnitureDeleteManyArgs} args - Arguments to filter Furnitures to delete.
     * @example
     * // Delete a few Furnitures
     * const { count } = await prisma.furniture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FurnitureDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Furnitures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Furnitures
     * const furniture = await prisma.furniture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FurnitureUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Furniture.
     * @param {FurnitureUpsertArgs} args - Arguments to update or create a Furniture.
     * @example
     * // Update or create a Furniture
     * const furniture = await prisma.furniture.upsert({
     *   create: {
     *     // ... data to create a Furniture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Furniture we want to update
     *   }
     * })
    **/
    upsert<T extends FurnitureUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureUpsertArgs<ExtArgs>>
    ): Prisma__FurnitureClient<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Furnitures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureCountArgs} args - Arguments to filter Furnitures to count.
     * @example
     * // Count the number of Furnitures
     * const count = await prisma.furniture.count({
     *   where: {
     *     // ... the filter for the Furnitures we want to count
     *   }
     * })
    **/
    count<T extends FurnitureCountArgs>(
      args?: Subset<T, FurnitureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FurnitureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Furniture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FurnitureAggregateArgs>(args: Subset<T, FurnitureAggregateArgs>): Prisma.PrismaPromise<GetFurnitureAggregateType<T>>

    /**
     * Group by Furniture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FurnitureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FurnitureGroupByArgs['orderBy'] }
        : { orderBy?: FurnitureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FurnitureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFurnitureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Furniture model
   */
  readonly fields: FurnitureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Furniture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FurnitureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Colors<T extends Furniture$ColorsArgs<ExtArgs> = {}>(args?: Subset<T, Furniture$ColorsArgs<ExtArgs>>): Prisma__ColorsClient<$Result.GetResult<Prisma.$ColorsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Materials<T extends Furniture$MaterialsArgs<ExtArgs> = {}>(args?: Subset<T, Furniture$MaterialsArgs<ExtArgs>>): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    RoomTypes<T extends Furniture$RoomTypesArgs<ExtArgs> = {}>(args?: Subset<T, Furniture$RoomTypesArgs<ExtArgs>>): Prisma__RoomTypesClient<$Result.GetResult<Prisma.$RoomTypesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    FurnitureTypes<T extends Furniture$FurnitureTypesArgs<ExtArgs> = {}>(args?: Subset<T, Furniture$FurnitureTypesArgs<ExtArgs>>): Prisma__FurnitureTypesClient<$Result.GetResult<Prisma.$FurnitureTypesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    furniture_photos<T extends Furniture$furniture_photosArgs<ExtArgs> = {}>(args?: Subset<T, Furniture$furniture_photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurniturePhotosPayload<ExtArgs>, T, 'findMany'> | Null>;

    furniture_comments<T extends Furniture$furniture_commentsArgs<ExtArgs> = {}>(args?: Subset<T, Furniture$furniture_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurnitureCommentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    furniture_likes<T extends Furniture$furniture_likesArgs<ExtArgs> = {}>(args?: Subset<T, Furniture$furniture_likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurnitureLikesPayload<ExtArgs>, T, 'findMany'> | Null>;

    contracts_detailing<T extends Furniture$contracts_detailingArgs<ExtArgs> = {}>(args?: Subset<T, Furniture$contracts_detailingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractsDetailingPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Furniture model
   */ 
  interface FurnitureFieldRefs {
    readonly id: FieldRef<"Furniture", 'Int'>
    readonly name: FieldRef<"Furniture", 'String'>
    readonly produced_date: FieldRef<"Furniture", 'String'>
    readonly colors_id: FieldRef<"Furniture", 'Int'>
    readonly materials_id: FieldRef<"Furniture", 'Int'>
    readonly roomTypes_id: FieldRef<"Furniture", 'Int'>
    readonly furniture_types_id: FieldRef<"Furniture", 'Int'>
    readonly description: FieldRef<"Furniture", 'String'>
    readonly height: FieldRef<"Furniture", 'Decimal'>
    readonly width: FieldRef<"Furniture", 'Decimal'>
    readonly price: FieldRef<"Furniture", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Furniture findUnique
   */
  export type FurnitureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    /**
     * Filter, which Furniture to fetch.
     */
    where: FurnitureWhereUniqueInput
  }

  /**
   * Furniture findUniqueOrThrow
   */
  export type FurnitureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    /**
     * Filter, which Furniture to fetch.
     */
    where: FurnitureWhereUniqueInput
  }

  /**
   * Furniture findFirst
   */
  export type FurnitureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    /**
     * Filter, which Furniture to fetch.
     */
    where?: FurnitureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Furnitures to fetch.
     */
    orderBy?: FurnitureOrderByWithRelationInput | FurnitureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Furnitures.
     */
    cursor?: FurnitureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Furnitures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Furnitures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Furnitures.
     */
    distinct?: FurnitureScalarFieldEnum | FurnitureScalarFieldEnum[]
  }

  /**
   * Furniture findFirstOrThrow
   */
  export type FurnitureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    /**
     * Filter, which Furniture to fetch.
     */
    where?: FurnitureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Furnitures to fetch.
     */
    orderBy?: FurnitureOrderByWithRelationInput | FurnitureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Furnitures.
     */
    cursor?: FurnitureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Furnitures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Furnitures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Furnitures.
     */
    distinct?: FurnitureScalarFieldEnum | FurnitureScalarFieldEnum[]
  }

  /**
   * Furniture findMany
   */
  export type FurnitureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    /**
     * Filter, which Furnitures to fetch.
     */
    where?: FurnitureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Furnitures to fetch.
     */
    orderBy?: FurnitureOrderByWithRelationInput | FurnitureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Furnitures.
     */
    cursor?: FurnitureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Furnitures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Furnitures.
     */
    skip?: number
    distinct?: FurnitureScalarFieldEnum | FurnitureScalarFieldEnum[]
  }

  /**
   * Furniture create
   */
  export type FurnitureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    /**
     * The data needed to create a Furniture.
     */
    data: XOR<FurnitureCreateInput, FurnitureUncheckedCreateInput>
  }

  /**
   * Furniture createMany
   */
  export type FurnitureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Furnitures.
     */
    data: FurnitureCreateManyInput | FurnitureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Furniture update
   */
  export type FurnitureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    /**
     * The data needed to update a Furniture.
     */
    data: XOR<FurnitureUpdateInput, FurnitureUncheckedUpdateInput>
    /**
     * Choose, which Furniture to update.
     */
    where: FurnitureWhereUniqueInput
  }

  /**
   * Furniture updateMany
   */
  export type FurnitureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Furnitures.
     */
    data: XOR<FurnitureUpdateManyMutationInput, FurnitureUncheckedUpdateManyInput>
    /**
     * Filter which Furnitures to update
     */
    where?: FurnitureWhereInput
  }

  /**
   * Furniture upsert
   */
  export type FurnitureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    /**
     * The filter to search for the Furniture to update in case it exists.
     */
    where: FurnitureWhereUniqueInput
    /**
     * In case the Furniture found by the `where` argument doesn't exist, create a new Furniture with this data.
     */
    create: XOR<FurnitureCreateInput, FurnitureUncheckedCreateInput>
    /**
     * In case the Furniture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FurnitureUpdateInput, FurnitureUncheckedUpdateInput>
  }

  /**
   * Furniture delete
   */
  export type FurnitureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    /**
     * Filter which Furniture to delete.
     */
    where: FurnitureWhereUniqueInput
  }

  /**
   * Furniture deleteMany
   */
  export type FurnitureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Furnitures to delete
     */
    where?: FurnitureWhereInput
  }

  /**
   * Furniture.Colors
   */
  export type Furniture$ColorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colors
     */
    select?: ColorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorsInclude<ExtArgs> | null
    where?: ColorsWhereInput
  }

  /**
   * Furniture.Materials
   */
  export type Furniture$MaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialsInclude<ExtArgs> | null
    where?: MaterialsWhereInput
  }

  /**
   * Furniture.RoomTypes
   */
  export type Furniture$RoomTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypes
     */
    select?: RoomTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypesInclude<ExtArgs> | null
    where?: RoomTypesWhereInput
  }

  /**
   * Furniture.FurnitureTypes
   */
  export type Furniture$FurnitureTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureTypes
     */
    select?: FurnitureTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureTypesInclude<ExtArgs> | null
    where?: FurnitureTypesWhereInput
  }

  /**
   * Furniture.furniture_photos
   */
  export type Furniture$furniture_photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurniturePhotos
     */
    select?: FurniturePhotosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurniturePhotosInclude<ExtArgs> | null
    where?: FurniturePhotosWhereInput
    orderBy?: FurniturePhotosOrderByWithRelationInput | FurniturePhotosOrderByWithRelationInput[]
    cursor?: FurniturePhotosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FurniturePhotosScalarFieldEnum | FurniturePhotosScalarFieldEnum[]
  }

  /**
   * Furniture.furniture_comments
   */
  export type Furniture$furniture_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureComments
     */
    select?: FurnitureCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureCommentsInclude<ExtArgs> | null
    where?: FurnitureCommentsWhereInput
    orderBy?: FurnitureCommentsOrderByWithRelationInput | FurnitureCommentsOrderByWithRelationInput[]
    cursor?: FurnitureCommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FurnitureCommentsScalarFieldEnum | FurnitureCommentsScalarFieldEnum[]
  }

  /**
   * Furniture.furniture_likes
   */
  export type Furniture$furniture_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureLikes
     */
    select?: FurnitureLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureLikesInclude<ExtArgs> | null
    where?: FurnitureLikesWhereInput
    orderBy?: FurnitureLikesOrderByWithRelationInput | FurnitureLikesOrderByWithRelationInput[]
    cursor?: FurnitureLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FurnitureLikesScalarFieldEnum | FurnitureLikesScalarFieldEnum[]
  }

  /**
   * Furniture.contracts_detailing
   */
  export type Furniture$contracts_detailingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
    where?: ContractsDetailingWhereInput
    orderBy?: ContractsDetailingOrderByWithRelationInput | ContractsDetailingOrderByWithRelationInput[]
    cursor?: ContractsDetailingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractsDetailingScalarFieldEnum | ContractsDetailingScalarFieldEnum[]
  }

  /**
   * Furniture without action
   */
  export type FurnitureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    birth_date: string | null
    phone_number: string | null
    email: string | null
    hashed_password: string | null
    hashed_refresh_token: string | null
    activation_link: string | null
    is_active: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    birth_date: string | null
    phone_number: string | null
    email: string | null
    hashed_password: string | null
    hashed_refresh_token: string | null
    activation_link: string | null
    is_active: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    full_name: number
    birth_date: number
    phone_number: number
    email: number
    hashed_password: number
    hashed_refresh_token: number
    activation_link: number
    is_active: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    full_name?: true
    birth_date?: true
    phone_number?: true
    email?: true
    hashed_password?: true
    hashed_refresh_token?: true
    activation_link?: true
    is_active?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    full_name?: true
    birth_date?: true
    phone_number?: true
    email?: true
    hashed_password?: true
    hashed_refresh_token?: true
    activation_link?: true
    is_active?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    full_name?: true
    birth_date?: true
    phone_number?: true
    email?: true
    hashed_password?: true
    hashed_refresh_token?: true
    activation_link?: true
    is_active?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    full_name: string
    birth_date: string | null
    phone_number: string | null
    email: string
    hashed_password: string
    hashed_refresh_token: string | null
    activation_link: string
    is_active: boolean
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    birth_date?: boolean
    phone_number?: boolean
    email?: boolean
    hashed_password?: boolean
    hashed_refresh_token?: boolean
    activation_link?: boolean
    is_active?: boolean
    furniture_comments?: boolean | Users$furniture_commentsArgs<ExtArgs>
    furniture_likes?: boolean | Users$furniture_likesArgs<ExtArgs>
    user_card?: boolean | Users$user_cardArgs<ExtArgs>
    user_address?: boolean | Users$user_addressArgs<ExtArgs>
    payment?: boolean | Users$paymentArgs<ExtArgs>
    contracts?: boolean | Users$contractsArgs<ExtArgs>
    contracts_detailing?: boolean | Users$contracts_detailingArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    full_name?: boolean
    birth_date?: boolean
    phone_number?: boolean
    email?: boolean
    hashed_password?: boolean
    hashed_refresh_token?: boolean
    activation_link?: boolean
    is_active?: boolean
  }


  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    furniture_comments?: boolean | Users$furniture_commentsArgs<ExtArgs>
    furniture_likes?: boolean | Users$furniture_likesArgs<ExtArgs>
    user_card?: boolean | Users$user_cardArgs<ExtArgs>
    user_address?: boolean | Users$user_addressArgs<ExtArgs>
    payment?: boolean | Users$paymentArgs<ExtArgs>
    contracts?: boolean | Users$contractsArgs<ExtArgs>
    contracts_detailing?: boolean | Users$contracts_detailingArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      furniture_comments: Prisma.$FurnitureCommentsPayload<ExtArgs>[]
      furniture_likes: Prisma.$FurnitureLikesPayload<ExtArgs>[]
      user_card: Prisma.$UserCardPayload<ExtArgs>[]
      user_address: Prisma.$UserAddressPayload<ExtArgs>[]
      payment: Prisma.$PaymentPayload<ExtArgs>[]
      contracts: Prisma.$ContractsPayload<ExtArgs>[]
      contracts_detailing: Prisma.$ContractsDetailingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      birth_date: string | null
      phone_number: string | null
      email: string
      hashed_password: string
      hashed_refresh_token: string | null
      activation_link: string
      is_active: boolean
    }, ExtArgs["result"]["users"]>
    composites: {}
  }


  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends UsersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersCreateArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UsersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends UsersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends UsersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    furniture_comments<T extends Users$furniture_commentsArgs<ExtArgs> = {}>(args?: Subset<T, Users$furniture_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurnitureCommentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    furniture_likes<T extends Users$furniture_likesArgs<ExtArgs> = {}>(args?: Subset<T, Users$furniture_likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurnitureLikesPayload<ExtArgs>, T, 'findMany'> | Null>;

    user_card<T extends Users$user_cardArgs<ExtArgs> = {}>(args?: Subset<T, Users$user_cardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, 'findMany'> | Null>;

    user_address<T extends Users$user_addressArgs<ExtArgs> = {}>(args?: Subset<T, Users$user_addressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, 'findMany'> | Null>;

    payment<T extends Users$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Users$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    contracts<T extends Users$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Users$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'findMany'> | Null>;

    contracts_detailing<T extends Users$contracts_detailingArgs<ExtArgs> = {}>(args?: Subset<T, Users$contracts_detailingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractsDetailingPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Users model
   */ 
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'Int'>
    readonly full_name: FieldRef<"Users", 'String'>
    readonly birth_date: FieldRef<"Users", 'String'>
    readonly phone_number: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly hashed_password: FieldRef<"Users", 'String'>
    readonly hashed_refresh_token: FieldRef<"Users", 'String'>
    readonly activation_link: FieldRef<"Users", 'String'>
    readonly is_active: FieldRef<"Users", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
  }

  /**
   * Users.furniture_comments
   */
  export type Users$furniture_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureComments
     */
    select?: FurnitureCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureCommentsInclude<ExtArgs> | null
    where?: FurnitureCommentsWhereInput
    orderBy?: FurnitureCommentsOrderByWithRelationInput | FurnitureCommentsOrderByWithRelationInput[]
    cursor?: FurnitureCommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FurnitureCommentsScalarFieldEnum | FurnitureCommentsScalarFieldEnum[]
  }

  /**
   * Users.furniture_likes
   */
  export type Users$furniture_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureLikes
     */
    select?: FurnitureLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureLikesInclude<ExtArgs> | null
    where?: FurnitureLikesWhereInput
    orderBy?: FurnitureLikesOrderByWithRelationInput | FurnitureLikesOrderByWithRelationInput[]
    cursor?: FurnitureLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FurnitureLikesScalarFieldEnum | FurnitureLikesScalarFieldEnum[]
  }

  /**
   * Users.user_card
   */
  export type Users$user_cardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    where?: UserCardWhereInput
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    cursor?: UserCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * Users.user_address
   */
  export type Users$user_addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    where?: UserAddressWhereInput
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    cursor?: UserAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * Users.payment
   */
  export type Users$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Users.contracts
   */
  export type Users$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    where?: ContractsWhereInput
    orderBy?: ContractsOrderByWithRelationInput | ContractsOrderByWithRelationInput[]
    cursor?: ContractsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractsScalarFieldEnum | ContractsScalarFieldEnum[]
  }

  /**
   * Users.contracts_detailing
   */
  export type Users$contracts_detailingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
    where?: ContractsDetailingWhereInput
    orderBy?: ContractsDetailingOrderByWithRelationInput | ContractsDetailingOrderByWithRelationInput[]
    cursor?: ContractsDetailingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractsDetailingScalarFieldEnum | ContractsDetailingScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model FurnitureComments
   */

  export type AggregateFurnitureComments = {
    _count: FurnitureCommentsCountAggregateOutputType | null
    _avg: FurnitureCommentsAvgAggregateOutputType | null
    _sum: FurnitureCommentsSumAggregateOutputType | null
    _min: FurnitureCommentsMinAggregateOutputType | null
    _max: FurnitureCommentsMaxAggregateOutputType | null
  }

  export type FurnitureCommentsAvgAggregateOutputType = {
    id: number | null
    users_id: number | null
    furniture_id: number | null
  }

  export type FurnitureCommentsSumAggregateOutputType = {
    id: number | null
    users_id: number | null
    furniture_id: number | null
  }

  export type FurnitureCommentsMinAggregateOutputType = {
    id: number | null
    users_id: number | null
    furniture_id: number | null
    user_comment: string | null
  }

  export type FurnitureCommentsMaxAggregateOutputType = {
    id: number | null
    users_id: number | null
    furniture_id: number | null
    user_comment: string | null
  }

  export type FurnitureCommentsCountAggregateOutputType = {
    id: number
    users_id: number
    furniture_id: number
    user_comment: number
    _all: number
  }


  export type FurnitureCommentsAvgAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
  }

  export type FurnitureCommentsSumAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
  }

  export type FurnitureCommentsMinAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
    user_comment?: true
  }

  export type FurnitureCommentsMaxAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
    user_comment?: true
  }

  export type FurnitureCommentsCountAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
    user_comment?: true
    _all?: true
  }

  export type FurnitureCommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FurnitureComments to aggregate.
     */
    where?: FurnitureCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurnitureComments to fetch.
     */
    orderBy?: FurnitureCommentsOrderByWithRelationInput | FurnitureCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FurnitureCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurnitureComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurnitureComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FurnitureComments
    **/
    _count?: true | FurnitureCommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FurnitureCommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FurnitureCommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FurnitureCommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FurnitureCommentsMaxAggregateInputType
  }

  export type GetFurnitureCommentsAggregateType<T extends FurnitureCommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateFurnitureComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFurnitureComments[P]>
      : GetScalarType<T[P], AggregateFurnitureComments[P]>
  }




  export type FurnitureCommentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurnitureCommentsWhereInput
    orderBy?: FurnitureCommentsOrderByWithAggregationInput | FurnitureCommentsOrderByWithAggregationInput[]
    by: FurnitureCommentsScalarFieldEnum[] | FurnitureCommentsScalarFieldEnum
    having?: FurnitureCommentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FurnitureCommentsCountAggregateInputType | true
    _avg?: FurnitureCommentsAvgAggregateInputType
    _sum?: FurnitureCommentsSumAggregateInputType
    _min?: FurnitureCommentsMinAggregateInputType
    _max?: FurnitureCommentsMaxAggregateInputType
  }

  export type FurnitureCommentsGroupByOutputType = {
    id: number
    users_id: number | null
    furniture_id: number | null
    user_comment: string
    _count: FurnitureCommentsCountAggregateOutputType | null
    _avg: FurnitureCommentsAvgAggregateOutputType | null
    _sum: FurnitureCommentsSumAggregateOutputType | null
    _min: FurnitureCommentsMinAggregateOutputType | null
    _max: FurnitureCommentsMaxAggregateOutputType | null
  }

  type GetFurnitureCommentsGroupByPayload<T extends FurnitureCommentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FurnitureCommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FurnitureCommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FurnitureCommentsGroupByOutputType[P]>
            : GetScalarType<T[P], FurnitureCommentsGroupByOutputType[P]>
        }
      >
    >


  export type FurnitureCommentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    furniture_id?: boolean
    user_comment?: boolean
    Users?: boolean | FurnitureComments$UsersArgs<ExtArgs>
    Furniture?: boolean | FurnitureComments$FurnitureArgs<ExtArgs>
  }, ExtArgs["result"]["furnitureComments"]>

  export type FurnitureCommentsSelectScalar = {
    id?: boolean
    users_id?: boolean
    furniture_id?: boolean
    user_comment?: boolean
  }


  export type FurnitureCommentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | FurnitureComments$UsersArgs<ExtArgs>
    Furniture?: boolean | FurnitureComments$FurnitureArgs<ExtArgs>
  }


  export type $FurnitureCommentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FurnitureComments"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs> | null
      Furniture: Prisma.$FurniturePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      users_id: number | null
      furniture_id: number | null
      user_comment: string
    }, ExtArgs["result"]["furnitureComments"]>
    composites: {}
  }


  type FurnitureCommentsGetPayload<S extends boolean | null | undefined | FurnitureCommentsDefaultArgs> = $Result.GetResult<Prisma.$FurnitureCommentsPayload, S>

  type FurnitureCommentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FurnitureCommentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FurnitureCommentsCountAggregateInputType | true
    }

  export interface FurnitureCommentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FurnitureComments'], meta: { name: 'FurnitureComments' } }
    /**
     * Find zero or one FurnitureComments that matches the filter.
     * @param {FurnitureCommentsFindUniqueArgs} args - Arguments to find a FurnitureComments
     * @example
     * // Get one FurnitureComments
     * const furnitureComments = await prisma.furnitureComments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FurnitureCommentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureCommentsFindUniqueArgs<ExtArgs>>
    ): Prisma__FurnitureCommentsClient<$Result.GetResult<Prisma.$FurnitureCommentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FurnitureComments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FurnitureCommentsFindUniqueOrThrowArgs} args - Arguments to find a FurnitureComments
     * @example
     * // Get one FurnitureComments
     * const furnitureComments = await prisma.furnitureComments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FurnitureCommentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureCommentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FurnitureCommentsClient<$Result.GetResult<Prisma.$FurnitureCommentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FurnitureComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureCommentsFindFirstArgs} args - Arguments to find a FurnitureComments
     * @example
     * // Get one FurnitureComments
     * const furnitureComments = await prisma.furnitureComments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FurnitureCommentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureCommentsFindFirstArgs<ExtArgs>>
    ): Prisma__FurnitureCommentsClient<$Result.GetResult<Prisma.$FurnitureCommentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FurnitureComments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureCommentsFindFirstOrThrowArgs} args - Arguments to find a FurnitureComments
     * @example
     * // Get one FurnitureComments
     * const furnitureComments = await prisma.furnitureComments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FurnitureCommentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureCommentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FurnitureCommentsClient<$Result.GetResult<Prisma.$FurnitureCommentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FurnitureComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureCommentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FurnitureComments
     * const furnitureComments = await prisma.furnitureComments.findMany()
     * 
     * // Get first 10 FurnitureComments
     * const furnitureComments = await prisma.furnitureComments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const furnitureCommentsWithIdOnly = await prisma.furnitureComments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FurnitureCommentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureCommentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurnitureCommentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FurnitureComments.
     * @param {FurnitureCommentsCreateArgs} args - Arguments to create a FurnitureComments.
     * @example
     * // Create one FurnitureComments
     * const FurnitureComments = await prisma.furnitureComments.create({
     *   data: {
     *     // ... data to create a FurnitureComments
     *   }
     * })
     * 
    **/
    create<T extends FurnitureCommentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureCommentsCreateArgs<ExtArgs>>
    ): Prisma__FurnitureCommentsClient<$Result.GetResult<Prisma.$FurnitureCommentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FurnitureComments.
     *     @param {FurnitureCommentsCreateManyArgs} args - Arguments to create many FurnitureComments.
     *     @example
     *     // Create many FurnitureComments
     *     const furnitureComments = await prisma.furnitureComments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FurnitureCommentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureCommentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FurnitureComments.
     * @param {FurnitureCommentsDeleteArgs} args - Arguments to delete one FurnitureComments.
     * @example
     * // Delete one FurnitureComments
     * const FurnitureComments = await prisma.furnitureComments.delete({
     *   where: {
     *     // ... filter to delete one FurnitureComments
     *   }
     * })
     * 
    **/
    delete<T extends FurnitureCommentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureCommentsDeleteArgs<ExtArgs>>
    ): Prisma__FurnitureCommentsClient<$Result.GetResult<Prisma.$FurnitureCommentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FurnitureComments.
     * @param {FurnitureCommentsUpdateArgs} args - Arguments to update one FurnitureComments.
     * @example
     * // Update one FurnitureComments
     * const furnitureComments = await prisma.furnitureComments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FurnitureCommentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureCommentsUpdateArgs<ExtArgs>>
    ): Prisma__FurnitureCommentsClient<$Result.GetResult<Prisma.$FurnitureCommentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FurnitureComments.
     * @param {FurnitureCommentsDeleteManyArgs} args - Arguments to filter FurnitureComments to delete.
     * @example
     * // Delete a few FurnitureComments
     * const { count } = await prisma.furnitureComments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FurnitureCommentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureCommentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FurnitureComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureCommentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FurnitureComments
     * const furnitureComments = await prisma.furnitureComments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FurnitureCommentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureCommentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FurnitureComments.
     * @param {FurnitureCommentsUpsertArgs} args - Arguments to update or create a FurnitureComments.
     * @example
     * // Update or create a FurnitureComments
     * const furnitureComments = await prisma.furnitureComments.upsert({
     *   create: {
     *     // ... data to create a FurnitureComments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FurnitureComments we want to update
     *   }
     * })
    **/
    upsert<T extends FurnitureCommentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureCommentsUpsertArgs<ExtArgs>>
    ): Prisma__FurnitureCommentsClient<$Result.GetResult<Prisma.$FurnitureCommentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FurnitureComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureCommentsCountArgs} args - Arguments to filter FurnitureComments to count.
     * @example
     * // Count the number of FurnitureComments
     * const count = await prisma.furnitureComments.count({
     *   where: {
     *     // ... the filter for the FurnitureComments we want to count
     *   }
     * })
    **/
    count<T extends FurnitureCommentsCountArgs>(
      args?: Subset<T, FurnitureCommentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FurnitureCommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FurnitureComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureCommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FurnitureCommentsAggregateArgs>(args: Subset<T, FurnitureCommentsAggregateArgs>): Prisma.PrismaPromise<GetFurnitureCommentsAggregateType<T>>

    /**
     * Group by FurnitureComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureCommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FurnitureCommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FurnitureCommentsGroupByArgs['orderBy'] }
        : { orderBy?: FurnitureCommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FurnitureCommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFurnitureCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FurnitureComments model
   */
  readonly fields: FurnitureCommentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FurnitureComments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FurnitureCommentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends FurnitureComments$UsersArgs<ExtArgs> = {}>(args?: Subset<T, FurnitureComments$UsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Furniture<T extends FurnitureComments$FurnitureArgs<ExtArgs> = {}>(args?: Subset<T, FurnitureComments$FurnitureArgs<ExtArgs>>): Prisma__FurnitureClient<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FurnitureComments model
   */ 
  interface FurnitureCommentsFieldRefs {
    readonly id: FieldRef<"FurnitureComments", 'Int'>
    readonly users_id: FieldRef<"FurnitureComments", 'Int'>
    readonly furniture_id: FieldRef<"FurnitureComments", 'Int'>
    readonly user_comment: FieldRef<"FurnitureComments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FurnitureComments findUnique
   */
  export type FurnitureCommentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureComments
     */
    select?: FurnitureCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureCommentsInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureComments to fetch.
     */
    where: FurnitureCommentsWhereUniqueInput
  }

  /**
   * FurnitureComments findUniqueOrThrow
   */
  export type FurnitureCommentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureComments
     */
    select?: FurnitureCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureCommentsInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureComments to fetch.
     */
    where: FurnitureCommentsWhereUniqueInput
  }

  /**
   * FurnitureComments findFirst
   */
  export type FurnitureCommentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureComments
     */
    select?: FurnitureCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureCommentsInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureComments to fetch.
     */
    where?: FurnitureCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurnitureComments to fetch.
     */
    orderBy?: FurnitureCommentsOrderByWithRelationInput | FurnitureCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FurnitureComments.
     */
    cursor?: FurnitureCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurnitureComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurnitureComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FurnitureComments.
     */
    distinct?: FurnitureCommentsScalarFieldEnum | FurnitureCommentsScalarFieldEnum[]
  }

  /**
   * FurnitureComments findFirstOrThrow
   */
  export type FurnitureCommentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureComments
     */
    select?: FurnitureCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureCommentsInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureComments to fetch.
     */
    where?: FurnitureCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurnitureComments to fetch.
     */
    orderBy?: FurnitureCommentsOrderByWithRelationInput | FurnitureCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FurnitureComments.
     */
    cursor?: FurnitureCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurnitureComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurnitureComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FurnitureComments.
     */
    distinct?: FurnitureCommentsScalarFieldEnum | FurnitureCommentsScalarFieldEnum[]
  }

  /**
   * FurnitureComments findMany
   */
  export type FurnitureCommentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureComments
     */
    select?: FurnitureCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureCommentsInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureComments to fetch.
     */
    where?: FurnitureCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurnitureComments to fetch.
     */
    orderBy?: FurnitureCommentsOrderByWithRelationInput | FurnitureCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FurnitureComments.
     */
    cursor?: FurnitureCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurnitureComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurnitureComments.
     */
    skip?: number
    distinct?: FurnitureCommentsScalarFieldEnum | FurnitureCommentsScalarFieldEnum[]
  }

  /**
   * FurnitureComments create
   */
  export type FurnitureCommentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureComments
     */
    select?: FurnitureCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureCommentsInclude<ExtArgs> | null
    /**
     * The data needed to create a FurnitureComments.
     */
    data: XOR<FurnitureCommentsCreateInput, FurnitureCommentsUncheckedCreateInput>
  }

  /**
   * FurnitureComments createMany
   */
  export type FurnitureCommentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FurnitureComments.
     */
    data: FurnitureCommentsCreateManyInput | FurnitureCommentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FurnitureComments update
   */
  export type FurnitureCommentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureComments
     */
    select?: FurnitureCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureCommentsInclude<ExtArgs> | null
    /**
     * The data needed to update a FurnitureComments.
     */
    data: XOR<FurnitureCommentsUpdateInput, FurnitureCommentsUncheckedUpdateInput>
    /**
     * Choose, which FurnitureComments to update.
     */
    where: FurnitureCommentsWhereUniqueInput
  }

  /**
   * FurnitureComments updateMany
   */
  export type FurnitureCommentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FurnitureComments.
     */
    data: XOR<FurnitureCommentsUpdateManyMutationInput, FurnitureCommentsUncheckedUpdateManyInput>
    /**
     * Filter which FurnitureComments to update
     */
    where?: FurnitureCommentsWhereInput
  }

  /**
   * FurnitureComments upsert
   */
  export type FurnitureCommentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureComments
     */
    select?: FurnitureCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureCommentsInclude<ExtArgs> | null
    /**
     * The filter to search for the FurnitureComments to update in case it exists.
     */
    where: FurnitureCommentsWhereUniqueInput
    /**
     * In case the FurnitureComments found by the `where` argument doesn't exist, create a new FurnitureComments with this data.
     */
    create: XOR<FurnitureCommentsCreateInput, FurnitureCommentsUncheckedCreateInput>
    /**
     * In case the FurnitureComments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FurnitureCommentsUpdateInput, FurnitureCommentsUncheckedUpdateInput>
  }

  /**
   * FurnitureComments delete
   */
  export type FurnitureCommentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureComments
     */
    select?: FurnitureCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureCommentsInclude<ExtArgs> | null
    /**
     * Filter which FurnitureComments to delete.
     */
    where: FurnitureCommentsWhereUniqueInput
  }

  /**
   * FurnitureComments deleteMany
   */
  export type FurnitureCommentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FurnitureComments to delete
     */
    where?: FurnitureCommentsWhereInput
  }

  /**
   * FurnitureComments.Users
   */
  export type FurnitureComments$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * FurnitureComments.Furniture
   */
  export type FurnitureComments$FurnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    where?: FurnitureWhereInput
  }

  /**
   * FurnitureComments without action
   */
  export type FurnitureCommentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureComments
     */
    select?: FurnitureCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureCommentsInclude<ExtArgs> | null
  }


  /**
   * Model FurnitureLikes
   */

  export type AggregateFurnitureLikes = {
    _count: FurnitureLikesCountAggregateOutputType | null
    _avg: FurnitureLikesAvgAggregateOutputType | null
    _sum: FurnitureLikesSumAggregateOutputType | null
    _min: FurnitureLikesMinAggregateOutputType | null
    _max: FurnitureLikesMaxAggregateOutputType | null
  }

  export type FurnitureLikesAvgAggregateOutputType = {
    id: number | null
    users_id: number | null
    furniture_id: number | null
  }

  export type FurnitureLikesSumAggregateOutputType = {
    id: number | null
    users_id: number | null
    furniture_id: number | null
  }

  export type FurnitureLikesMinAggregateOutputType = {
    id: number | null
    users_id: number | null
    furniture_id: number | null
  }

  export type FurnitureLikesMaxAggregateOutputType = {
    id: number | null
    users_id: number | null
    furniture_id: number | null
  }

  export type FurnitureLikesCountAggregateOutputType = {
    id: number
    users_id: number
    furniture_id: number
    _all: number
  }


  export type FurnitureLikesAvgAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
  }

  export type FurnitureLikesSumAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
  }

  export type FurnitureLikesMinAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
  }

  export type FurnitureLikesMaxAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
  }

  export type FurnitureLikesCountAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
    _all?: true
  }

  export type FurnitureLikesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FurnitureLikes to aggregate.
     */
    where?: FurnitureLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurnitureLikes to fetch.
     */
    orderBy?: FurnitureLikesOrderByWithRelationInput | FurnitureLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FurnitureLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurnitureLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurnitureLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FurnitureLikes
    **/
    _count?: true | FurnitureLikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FurnitureLikesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FurnitureLikesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FurnitureLikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FurnitureLikesMaxAggregateInputType
  }

  export type GetFurnitureLikesAggregateType<T extends FurnitureLikesAggregateArgs> = {
        [P in keyof T & keyof AggregateFurnitureLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFurnitureLikes[P]>
      : GetScalarType<T[P], AggregateFurnitureLikes[P]>
  }




  export type FurnitureLikesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FurnitureLikesWhereInput
    orderBy?: FurnitureLikesOrderByWithAggregationInput | FurnitureLikesOrderByWithAggregationInput[]
    by: FurnitureLikesScalarFieldEnum[] | FurnitureLikesScalarFieldEnum
    having?: FurnitureLikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FurnitureLikesCountAggregateInputType | true
    _avg?: FurnitureLikesAvgAggregateInputType
    _sum?: FurnitureLikesSumAggregateInputType
    _min?: FurnitureLikesMinAggregateInputType
    _max?: FurnitureLikesMaxAggregateInputType
  }

  export type FurnitureLikesGroupByOutputType = {
    id: number
    users_id: number | null
    furniture_id: number | null
    _count: FurnitureLikesCountAggregateOutputType | null
    _avg: FurnitureLikesAvgAggregateOutputType | null
    _sum: FurnitureLikesSumAggregateOutputType | null
    _min: FurnitureLikesMinAggregateOutputType | null
    _max: FurnitureLikesMaxAggregateOutputType | null
  }

  type GetFurnitureLikesGroupByPayload<T extends FurnitureLikesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FurnitureLikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FurnitureLikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FurnitureLikesGroupByOutputType[P]>
            : GetScalarType<T[P], FurnitureLikesGroupByOutputType[P]>
        }
      >
    >


  export type FurnitureLikesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    furniture_id?: boolean
    Users?: boolean | FurnitureLikes$UsersArgs<ExtArgs>
    Furniture?: boolean | FurnitureLikes$FurnitureArgs<ExtArgs>
  }, ExtArgs["result"]["furnitureLikes"]>

  export type FurnitureLikesSelectScalar = {
    id?: boolean
    users_id?: boolean
    furniture_id?: boolean
  }


  export type FurnitureLikesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | FurnitureLikes$UsersArgs<ExtArgs>
    Furniture?: boolean | FurnitureLikes$FurnitureArgs<ExtArgs>
  }


  export type $FurnitureLikesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FurnitureLikes"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs> | null
      Furniture: Prisma.$FurniturePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      users_id: number | null
      furniture_id: number | null
    }, ExtArgs["result"]["furnitureLikes"]>
    composites: {}
  }


  type FurnitureLikesGetPayload<S extends boolean | null | undefined | FurnitureLikesDefaultArgs> = $Result.GetResult<Prisma.$FurnitureLikesPayload, S>

  type FurnitureLikesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FurnitureLikesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FurnitureLikesCountAggregateInputType | true
    }

  export interface FurnitureLikesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FurnitureLikes'], meta: { name: 'FurnitureLikes' } }
    /**
     * Find zero or one FurnitureLikes that matches the filter.
     * @param {FurnitureLikesFindUniqueArgs} args - Arguments to find a FurnitureLikes
     * @example
     * // Get one FurnitureLikes
     * const furnitureLikes = await prisma.furnitureLikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FurnitureLikesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureLikesFindUniqueArgs<ExtArgs>>
    ): Prisma__FurnitureLikesClient<$Result.GetResult<Prisma.$FurnitureLikesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FurnitureLikes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FurnitureLikesFindUniqueOrThrowArgs} args - Arguments to find a FurnitureLikes
     * @example
     * // Get one FurnitureLikes
     * const furnitureLikes = await prisma.furnitureLikes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FurnitureLikesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureLikesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FurnitureLikesClient<$Result.GetResult<Prisma.$FurnitureLikesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FurnitureLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureLikesFindFirstArgs} args - Arguments to find a FurnitureLikes
     * @example
     * // Get one FurnitureLikes
     * const furnitureLikes = await prisma.furnitureLikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FurnitureLikesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureLikesFindFirstArgs<ExtArgs>>
    ): Prisma__FurnitureLikesClient<$Result.GetResult<Prisma.$FurnitureLikesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FurnitureLikes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureLikesFindFirstOrThrowArgs} args - Arguments to find a FurnitureLikes
     * @example
     * // Get one FurnitureLikes
     * const furnitureLikes = await prisma.furnitureLikes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FurnitureLikesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureLikesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FurnitureLikesClient<$Result.GetResult<Prisma.$FurnitureLikesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FurnitureLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureLikesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FurnitureLikes
     * const furnitureLikes = await prisma.furnitureLikes.findMany()
     * 
     * // Get first 10 FurnitureLikes
     * const furnitureLikes = await prisma.furnitureLikes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const furnitureLikesWithIdOnly = await prisma.furnitureLikes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FurnitureLikesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureLikesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FurnitureLikesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FurnitureLikes.
     * @param {FurnitureLikesCreateArgs} args - Arguments to create a FurnitureLikes.
     * @example
     * // Create one FurnitureLikes
     * const FurnitureLikes = await prisma.furnitureLikes.create({
     *   data: {
     *     // ... data to create a FurnitureLikes
     *   }
     * })
     * 
    **/
    create<T extends FurnitureLikesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureLikesCreateArgs<ExtArgs>>
    ): Prisma__FurnitureLikesClient<$Result.GetResult<Prisma.$FurnitureLikesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FurnitureLikes.
     *     @param {FurnitureLikesCreateManyArgs} args - Arguments to create many FurnitureLikes.
     *     @example
     *     // Create many FurnitureLikes
     *     const furnitureLikes = await prisma.furnitureLikes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FurnitureLikesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureLikesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FurnitureLikes.
     * @param {FurnitureLikesDeleteArgs} args - Arguments to delete one FurnitureLikes.
     * @example
     * // Delete one FurnitureLikes
     * const FurnitureLikes = await prisma.furnitureLikes.delete({
     *   where: {
     *     // ... filter to delete one FurnitureLikes
     *   }
     * })
     * 
    **/
    delete<T extends FurnitureLikesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureLikesDeleteArgs<ExtArgs>>
    ): Prisma__FurnitureLikesClient<$Result.GetResult<Prisma.$FurnitureLikesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FurnitureLikes.
     * @param {FurnitureLikesUpdateArgs} args - Arguments to update one FurnitureLikes.
     * @example
     * // Update one FurnitureLikes
     * const furnitureLikes = await prisma.furnitureLikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FurnitureLikesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureLikesUpdateArgs<ExtArgs>>
    ): Prisma__FurnitureLikesClient<$Result.GetResult<Prisma.$FurnitureLikesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FurnitureLikes.
     * @param {FurnitureLikesDeleteManyArgs} args - Arguments to filter FurnitureLikes to delete.
     * @example
     * // Delete a few FurnitureLikes
     * const { count } = await prisma.furnitureLikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FurnitureLikesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FurnitureLikesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FurnitureLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureLikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FurnitureLikes
     * const furnitureLikes = await prisma.furnitureLikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FurnitureLikesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureLikesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FurnitureLikes.
     * @param {FurnitureLikesUpsertArgs} args - Arguments to update or create a FurnitureLikes.
     * @example
     * // Update or create a FurnitureLikes
     * const furnitureLikes = await prisma.furnitureLikes.upsert({
     *   create: {
     *     // ... data to create a FurnitureLikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FurnitureLikes we want to update
     *   }
     * })
    **/
    upsert<T extends FurnitureLikesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FurnitureLikesUpsertArgs<ExtArgs>>
    ): Prisma__FurnitureLikesClient<$Result.GetResult<Prisma.$FurnitureLikesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FurnitureLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureLikesCountArgs} args - Arguments to filter FurnitureLikes to count.
     * @example
     * // Count the number of FurnitureLikes
     * const count = await prisma.furnitureLikes.count({
     *   where: {
     *     // ... the filter for the FurnitureLikes we want to count
     *   }
     * })
    **/
    count<T extends FurnitureLikesCountArgs>(
      args?: Subset<T, FurnitureLikesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FurnitureLikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FurnitureLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureLikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FurnitureLikesAggregateArgs>(args: Subset<T, FurnitureLikesAggregateArgs>): Prisma.PrismaPromise<GetFurnitureLikesAggregateType<T>>

    /**
     * Group by FurnitureLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FurnitureLikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FurnitureLikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FurnitureLikesGroupByArgs['orderBy'] }
        : { orderBy?: FurnitureLikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FurnitureLikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFurnitureLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FurnitureLikes model
   */
  readonly fields: FurnitureLikesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FurnitureLikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FurnitureLikesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends FurnitureLikes$UsersArgs<ExtArgs> = {}>(args?: Subset<T, FurnitureLikes$UsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Furniture<T extends FurnitureLikes$FurnitureArgs<ExtArgs> = {}>(args?: Subset<T, FurnitureLikes$FurnitureArgs<ExtArgs>>): Prisma__FurnitureClient<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FurnitureLikes model
   */ 
  interface FurnitureLikesFieldRefs {
    readonly id: FieldRef<"FurnitureLikes", 'Int'>
    readonly users_id: FieldRef<"FurnitureLikes", 'Int'>
    readonly furniture_id: FieldRef<"FurnitureLikes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FurnitureLikes findUnique
   */
  export type FurnitureLikesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureLikes
     */
    select?: FurnitureLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureLikesInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureLikes to fetch.
     */
    where: FurnitureLikesWhereUniqueInput
  }

  /**
   * FurnitureLikes findUniqueOrThrow
   */
  export type FurnitureLikesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureLikes
     */
    select?: FurnitureLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureLikesInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureLikes to fetch.
     */
    where: FurnitureLikesWhereUniqueInput
  }

  /**
   * FurnitureLikes findFirst
   */
  export type FurnitureLikesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureLikes
     */
    select?: FurnitureLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureLikesInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureLikes to fetch.
     */
    where?: FurnitureLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurnitureLikes to fetch.
     */
    orderBy?: FurnitureLikesOrderByWithRelationInput | FurnitureLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FurnitureLikes.
     */
    cursor?: FurnitureLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurnitureLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurnitureLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FurnitureLikes.
     */
    distinct?: FurnitureLikesScalarFieldEnum | FurnitureLikesScalarFieldEnum[]
  }

  /**
   * FurnitureLikes findFirstOrThrow
   */
  export type FurnitureLikesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureLikes
     */
    select?: FurnitureLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureLikesInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureLikes to fetch.
     */
    where?: FurnitureLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurnitureLikes to fetch.
     */
    orderBy?: FurnitureLikesOrderByWithRelationInput | FurnitureLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FurnitureLikes.
     */
    cursor?: FurnitureLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurnitureLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurnitureLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FurnitureLikes.
     */
    distinct?: FurnitureLikesScalarFieldEnum | FurnitureLikesScalarFieldEnum[]
  }

  /**
   * FurnitureLikes findMany
   */
  export type FurnitureLikesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureLikes
     */
    select?: FurnitureLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureLikesInclude<ExtArgs> | null
    /**
     * Filter, which FurnitureLikes to fetch.
     */
    where?: FurnitureLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FurnitureLikes to fetch.
     */
    orderBy?: FurnitureLikesOrderByWithRelationInput | FurnitureLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FurnitureLikes.
     */
    cursor?: FurnitureLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FurnitureLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FurnitureLikes.
     */
    skip?: number
    distinct?: FurnitureLikesScalarFieldEnum | FurnitureLikesScalarFieldEnum[]
  }

  /**
   * FurnitureLikes create
   */
  export type FurnitureLikesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureLikes
     */
    select?: FurnitureLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureLikesInclude<ExtArgs> | null
    /**
     * The data needed to create a FurnitureLikes.
     */
    data?: XOR<FurnitureLikesCreateInput, FurnitureLikesUncheckedCreateInput>
  }

  /**
   * FurnitureLikes createMany
   */
  export type FurnitureLikesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FurnitureLikes.
     */
    data: FurnitureLikesCreateManyInput | FurnitureLikesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FurnitureLikes update
   */
  export type FurnitureLikesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureLikes
     */
    select?: FurnitureLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureLikesInclude<ExtArgs> | null
    /**
     * The data needed to update a FurnitureLikes.
     */
    data: XOR<FurnitureLikesUpdateInput, FurnitureLikesUncheckedUpdateInput>
    /**
     * Choose, which FurnitureLikes to update.
     */
    where: FurnitureLikesWhereUniqueInput
  }

  /**
   * FurnitureLikes updateMany
   */
  export type FurnitureLikesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FurnitureLikes.
     */
    data: XOR<FurnitureLikesUpdateManyMutationInput, FurnitureLikesUncheckedUpdateManyInput>
    /**
     * Filter which FurnitureLikes to update
     */
    where?: FurnitureLikesWhereInput
  }

  /**
   * FurnitureLikes upsert
   */
  export type FurnitureLikesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureLikes
     */
    select?: FurnitureLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureLikesInclude<ExtArgs> | null
    /**
     * The filter to search for the FurnitureLikes to update in case it exists.
     */
    where: FurnitureLikesWhereUniqueInput
    /**
     * In case the FurnitureLikes found by the `where` argument doesn't exist, create a new FurnitureLikes with this data.
     */
    create: XOR<FurnitureLikesCreateInput, FurnitureLikesUncheckedCreateInput>
    /**
     * In case the FurnitureLikes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FurnitureLikesUpdateInput, FurnitureLikesUncheckedUpdateInput>
  }

  /**
   * FurnitureLikes delete
   */
  export type FurnitureLikesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureLikes
     */
    select?: FurnitureLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureLikesInclude<ExtArgs> | null
    /**
     * Filter which FurnitureLikes to delete.
     */
    where: FurnitureLikesWhereUniqueInput
  }

  /**
   * FurnitureLikes deleteMany
   */
  export type FurnitureLikesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FurnitureLikes to delete
     */
    where?: FurnitureLikesWhereInput
  }

  /**
   * FurnitureLikes.Users
   */
  export type FurnitureLikes$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * FurnitureLikes.Furniture
   */
  export type FurnitureLikes$FurnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    where?: FurnitureWhereInput
  }

  /**
   * FurnitureLikes without action
   */
  export type FurnitureLikesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FurnitureLikes
     */
    select?: FurnitureLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureLikesInclude<ExtArgs> | null
  }


  /**
   * Model Admins
   */

  export type AggregateAdmins = {
    _count: AdminsCountAggregateOutputType | null
    _avg: AdminsAvgAggregateOutputType | null
    _sum: AdminsSumAggregateOutputType | null
    _min: AdminsMinAggregateOutputType | null
    _max: AdminsMaxAggregateOutputType | null
  }

  export type AdminsAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminsSumAggregateOutputType = {
    id: number | null
  }

  export type AdminsMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    birth_date: string | null
    phone_number: string | null
    email: string | null
    hashed_password: string | null
    hashed_refresh_token: string | null
    is_creator: boolean | null
  }

  export type AdminsMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    birth_date: string | null
    phone_number: string | null
    email: string | null
    hashed_password: string | null
    hashed_refresh_token: string | null
    is_creator: boolean | null
  }

  export type AdminsCountAggregateOutputType = {
    id: number
    full_name: number
    birth_date: number
    phone_number: number
    email: number
    hashed_password: number
    hashed_refresh_token: number
    is_creator: number
    _all: number
  }


  export type AdminsAvgAggregateInputType = {
    id?: true
  }

  export type AdminsSumAggregateInputType = {
    id?: true
  }

  export type AdminsMinAggregateInputType = {
    id?: true
    full_name?: true
    birth_date?: true
    phone_number?: true
    email?: true
    hashed_password?: true
    hashed_refresh_token?: true
    is_creator?: true
  }

  export type AdminsMaxAggregateInputType = {
    id?: true
    full_name?: true
    birth_date?: true
    phone_number?: true
    email?: true
    hashed_password?: true
    hashed_refresh_token?: true
    is_creator?: true
  }

  export type AdminsCountAggregateInputType = {
    id?: true
    full_name?: true
    birth_date?: true
    phone_number?: true
    email?: true
    hashed_password?: true
    hashed_refresh_token?: true
    is_creator?: true
    _all?: true
  }

  export type AdminsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to aggregate.
     */
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminsMaxAggregateInputType
  }

  export type GetAdminsAggregateType<T extends AdminsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmins[P]>
      : GetScalarType<T[P], AggregateAdmins[P]>
  }




  export type AdminsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminsWhereInput
    orderBy?: AdminsOrderByWithAggregationInput | AdminsOrderByWithAggregationInput[]
    by: AdminsScalarFieldEnum[] | AdminsScalarFieldEnum
    having?: AdminsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminsCountAggregateInputType | true
    _avg?: AdminsAvgAggregateInputType
    _sum?: AdminsSumAggregateInputType
    _min?: AdminsMinAggregateInputType
    _max?: AdminsMaxAggregateInputType
  }

  export type AdminsGroupByOutputType = {
    id: number
    full_name: string
    birth_date: string | null
    phone_number: string
    email: string
    hashed_password: string | null
    hashed_refresh_token: string | null
    is_creator: boolean
    _count: AdminsCountAggregateOutputType | null
    _avg: AdminsAvgAggregateOutputType | null
    _sum: AdminsSumAggregateOutputType | null
    _min: AdminsMinAggregateOutputType | null
    _max: AdminsMaxAggregateOutputType | null
  }

  type GetAdminsGroupByPayload<T extends AdminsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminsGroupByOutputType[P]>
            : GetScalarType<T[P], AdminsGroupByOutputType[P]>
        }
      >
    >


  export type AdminsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    birth_date?: boolean
    phone_number?: boolean
    email?: boolean
    hashed_password?: boolean
    hashed_refresh_token?: boolean
    is_creator?: boolean
    admin_roles?: boolean | Admins$admin_rolesArgs<ExtArgs>
    _count?: boolean | AdminsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admins"]>

  export type AdminsSelectScalar = {
    id?: boolean
    full_name?: boolean
    birth_date?: boolean
    phone_number?: boolean
    email?: boolean
    hashed_password?: boolean
    hashed_refresh_token?: boolean
    is_creator?: boolean
  }


  export type AdminsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_roles?: boolean | Admins$admin_rolesArgs<ExtArgs>
    _count?: boolean | AdminsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AdminsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admins"
    objects: {
      admin_roles: Prisma.$AdminRolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      birth_date: string | null
      phone_number: string
      email: string
      hashed_password: string | null
      hashed_refresh_token: string | null
      is_creator: boolean
    }, ExtArgs["result"]["admins"]>
    composites: {}
  }


  type AdminsGetPayload<S extends boolean | null | undefined | AdminsDefaultArgs> = $Result.GetResult<Prisma.$AdminsPayload, S>

  type AdminsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminsCountAggregateInputType | true
    }

  export interface AdminsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admins'], meta: { name: 'Admins' } }
    /**
     * Find zero or one Admins that matches the filter.
     * @param {AdminsFindUniqueArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminsFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Admins that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminsFindUniqueOrThrowArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsFindFirstArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminsFindFirstArgs<ExtArgs>>
    ): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Admins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsFindFirstOrThrowArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admins.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admins.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminsWithIdOnly = await prisma.admins.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Admins.
     * @param {AdminsCreateArgs} args - Arguments to create a Admins.
     * @example
     * // Create one Admins
     * const Admins = await prisma.admins.create({
     *   data: {
     *     // ... data to create a Admins
     *   }
     * })
     * 
    **/
    create<T extends AdminsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminsCreateArgs<ExtArgs>>
    ): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Admins.
     *     @param {AdminsCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admins = await prisma.admins.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admins.
     * @param {AdminsDeleteArgs} args - Arguments to delete one Admins.
     * @example
     * // Delete one Admins
     * const Admins = await prisma.admins.delete({
     *   where: {
     *     // ... filter to delete one Admins
     *   }
     * })
     * 
    **/
    delete<T extends AdminsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminsDeleteArgs<ExtArgs>>
    ): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Admins.
     * @param {AdminsUpdateArgs} args - Arguments to update one Admins.
     * @example
     * // Update one Admins
     * const admins = await prisma.admins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminsUpdateArgs<ExtArgs>>
    ): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminsDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admins = await prisma.admins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admins.
     * @param {AdminsUpsertArgs} args - Arguments to update or create a Admins.
     * @example
     * // Update or create a Admins
     * const admins = await prisma.admins.upsert({
     *   create: {
     *     // ... data to create a Admins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admins we want to update
     *   }
     * })
    **/
    upsert<T extends AdminsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminsUpsertArgs<ExtArgs>>
    ): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admins.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminsCountArgs>(
      args?: Subset<T, AdminsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminsAggregateArgs>(args: Subset<T, AdminsAggregateArgs>): Prisma.PrismaPromise<GetAdminsAggregateType<T>>

    /**
     * Group by Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminsGroupByArgs['orderBy'] }
        : { orderBy?: AdminsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admins model
   */
  readonly fields: AdminsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    admin_roles<T extends Admins$admin_rolesArgs<ExtArgs> = {}>(args?: Subset<T, Admins$admin_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRolesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Admins model
   */ 
  interface AdminsFieldRefs {
    readonly id: FieldRef<"Admins", 'Int'>
    readonly full_name: FieldRef<"Admins", 'String'>
    readonly birth_date: FieldRef<"Admins", 'String'>
    readonly phone_number: FieldRef<"Admins", 'String'>
    readonly email: FieldRef<"Admins", 'String'>
    readonly hashed_password: FieldRef<"Admins", 'String'>
    readonly hashed_refresh_token: FieldRef<"Admins", 'String'>
    readonly is_creator: FieldRef<"Admins", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Admins findUnique
   */
  export type AdminsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where: AdminsWhereUniqueInput
  }

  /**
   * Admins findUniqueOrThrow
   */
  export type AdminsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where: AdminsWhereUniqueInput
  }

  /**
   * Admins findFirst
   */
  export type AdminsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * Admins findFirstOrThrow
   */
  export type AdminsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * Admins findMany
   */
  export type AdminsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminsOrderByWithRelationInput | AdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * Admins create
   */
  export type AdminsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * The data needed to create a Admins.
     */
    data: XOR<AdminsCreateInput, AdminsUncheckedCreateInput>
  }

  /**
   * Admins createMany
   */
  export type AdminsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminsCreateManyInput | AdminsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admins update
   */
  export type AdminsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * The data needed to update a Admins.
     */
    data: XOR<AdminsUpdateInput, AdminsUncheckedUpdateInput>
    /**
     * Choose, which Admins to update.
     */
    where: AdminsWhereUniqueInput
  }

  /**
   * Admins updateMany
   */
  export type AdminsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminsUpdateManyMutationInput, AdminsUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminsWhereInput
  }

  /**
   * Admins upsert
   */
  export type AdminsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * The filter to search for the Admins to update in case it exists.
     */
    where: AdminsWhereUniqueInput
    /**
     * In case the Admins found by the `where` argument doesn't exist, create a new Admins with this data.
     */
    create: XOR<AdminsCreateInput, AdminsUncheckedCreateInput>
    /**
     * In case the Admins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminsUpdateInput, AdminsUncheckedUpdateInput>
  }

  /**
   * Admins delete
   */
  export type AdminsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    /**
     * Filter which Admins to delete.
     */
    where: AdminsWhereUniqueInput
  }

  /**
   * Admins deleteMany
   */
  export type AdminsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminsWhereInput
  }

  /**
   * Admins.admin_roles
   */
  export type Admins$admin_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoles
     */
    select?: AdminRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRolesInclude<ExtArgs> | null
    where?: AdminRolesWhereInput
    orderBy?: AdminRolesOrderByWithRelationInput | AdminRolesOrderByWithRelationInput[]
    cursor?: AdminRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminRolesScalarFieldEnum | AdminRolesScalarFieldEnum[]
  }

  /**
   * Admins without action
   */
  export type AdminsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
  }


  /**
   * Model Roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    value: string | null
    description: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    value: string | null
    description: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    value: number
    description: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    value?: true
    description?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    value?: true
    description?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    value?: true
    description?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to aggregate.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesWhereInput
    orderBy?: RolesOrderByWithAggregationInput | RolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    value: string
    description: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
    admin_roles?: boolean | Roles$admin_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectScalar = {
    id?: boolean
    value?: boolean
    description?: boolean
  }


  export type RolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_roles?: boolean | Roles$admin_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles"
    objects: {
      admin_roles: Prisma.$AdminRolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
      description: string
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }


  type RolesGetPayload<S extends boolean | null | undefined | RolesDefaultArgs> = $Result.GetResult<Prisma.$RolesPayload, S>

  type RolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface RolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles'], meta: { name: 'Roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RolesFindUniqueArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesFindFirstArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
    **/
    create<T extends RolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RolesCreateArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Roles.
     *     @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const roles = await prisma.roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
    **/
    delete<T extends RolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RolesDeleteArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RolesUpdateArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
    **/
    upsert<T extends RolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RolesUpsertArgs<ExtArgs>>
    ): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles model
   */
  readonly fields: RolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    admin_roles<T extends Roles$admin_rolesArgs<ExtArgs> = {}>(args?: Subset<T, Roles$admin_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRolesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Roles model
   */ 
  interface RolesFieldRefs {
    readonly id: FieldRef<"Roles", 'Int'>
    readonly value: FieldRef<"Roles", 'String'>
    readonly description: FieldRef<"Roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Roles findUnique
   */
  export type RolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findUniqueOrThrow
   */
  export type RolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findFirst
   */
  export type RolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findFirstOrThrow
   */
  export type RolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findMany
   */
  export type RolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles create
   */
  export type RolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles.
     */
    data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }

  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles update
   */
  export type RolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles.
     */
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
  }

  /**
   * Roles upsert
   */
  export type RolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles to update in case it exists.
     */
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     */
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }

  /**
   * Roles delete
   */
  export type RolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter which Roles to delete.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RolesWhereInput
  }

  /**
   * Roles.admin_roles
   */
  export type Roles$admin_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoles
     */
    select?: AdminRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRolesInclude<ExtArgs> | null
    where?: AdminRolesWhereInput
    orderBy?: AdminRolesOrderByWithRelationInput | AdminRolesOrderByWithRelationInput[]
    cursor?: AdminRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminRolesScalarFieldEnum | AdminRolesScalarFieldEnum[]
  }

  /**
   * Roles without action
   */
  export type RolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
  }


  /**
   * Model AdminRoles
   */

  export type AggregateAdminRoles = {
    _count: AdminRolesCountAggregateOutputType | null
    _avg: AdminRolesAvgAggregateOutputType | null
    _sum: AdminRolesSumAggregateOutputType | null
    _min: AdminRolesMinAggregateOutputType | null
    _max: AdminRolesMaxAggregateOutputType | null
  }

  export type AdminRolesAvgAggregateOutputType = {
    id: number | null
    admins_id: number | null
    roles_id: number | null
  }

  export type AdminRolesSumAggregateOutputType = {
    id: number | null
    admins_id: number | null
    roles_id: number | null
  }

  export type AdminRolesMinAggregateOutputType = {
    id: number | null
    admins_id: number | null
    roles_id: number | null
  }

  export type AdminRolesMaxAggregateOutputType = {
    id: number | null
    admins_id: number | null
    roles_id: number | null
  }

  export type AdminRolesCountAggregateOutputType = {
    id: number
    admins_id: number
    roles_id: number
    _all: number
  }


  export type AdminRolesAvgAggregateInputType = {
    id?: true
    admins_id?: true
    roles_id?: true
  }

  export type AdminRolesSumAggregateInputType = {
    id?: true
    admins_id?: true
    roles_id?: true
  }

  export type AdminRolesMinAggregateInputType = {
    id?: true
    admins_id?: true
    roles_id?: true
  }

  export type AdminRolesMaxAggregateInputType = {
    id?: true
    admins_id?: true
    roles_id?: true
  }

  export type AdminRolesCountAggregateInputType = {
    id?: true
    admins_id?: true
    roles_id?: true
    _all?: true
  }

  export type AdminRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminRoles to aggregate.
     */
    where?: AdminRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoles to fetch.
     */
    orderBy?: AdminRolesOrderByWithRelationInput | AdminRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminRoles
    **/
    _count?: true | AdminRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminRolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminRolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminRolesMaxAggregateInputType
  }

  export type GetAdminRolesAggregateType<T extends AdminRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminRoles[P]>
      : GetScalarType<T[P], AggregateAdminRoles[P]>
  }




  export type AdminRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRolesWhereInput
    orderBy?: AdminRolesOrderByWithAggregationInput | AdminRolesOrderByWithAggregationInput[]
    by: AdminRolesScalarFieldEnum[] | AdminRolesScalarFieldEnum
    having?: AdminRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminRolesCountAggregateInputType | true
    _avg?: AdminRolesAvgAggregateInputType
    _sum?: AdminRolesSumAggregateInputType
    _min?: AdminRolesMinAggregateInputType
    _max?: AdminRolesMaxAggregateInputType
  }

  export type AdminRolesGroupByOutputType = {
    id: number
    admins_id: number | null
    roles_id: number | null
    _count: AdminRolesCountAggregateOutputType | null
    _avg: AdminRolesAvgAggregateOutputType | null
    _sum: AdminRolesSumAggregateOutputType | null
    _min: AdminRolesMinAggregateOutputType | null
    _max: AdminRolesMaxAggregateOutputType | null
  }

  type GetAdminRolesGroupByPayload<T extends AdminRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminRolesGroupByOutputType[P]>
            : GetScalarType<T[P], AdminRolesGroupByOutputType[P]>
        }
      >
    >


  export type AdminRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admins_id?: boolean
    roles_id?: boolean
    Admins?: boolean | AdminRoles$AdminsArgs<ExtArgs>
    Roles?: boolean | AdminRoles$RolesArgs<ExtArgs>
  }, ExtArgs["result"]["adminRoles"]>

  export type AdminRolesSelectScalar = {
    id?: boolean
    admins_id?: boolean
    roles_id?: boolean
  }


  export type AdminRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Admins?: boolean | AdminRoles$AdminsArgs<ExtArgs>
    Roles?: boolean | AdminRoles$RolesArgs<ExtArgs>
  }


  export type $AdminRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminRoles"
    objects: {
      Admins: Prisma.$AdminsPayload<ExtArgs> | null
      Roles: Prisma.$RolesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      admins_id: number | null
      roles_id: number | null
    }, ExtArgs["result"]["adminRoles"]>
    composites: {}
  }


  type AdminRolesGetPayload<S extends boolean | null | undefined | AdminRolesDefaultArgs> = $Result.GetResult<Prisma.$AdminRolesPayload, S>

  type AdminRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminRolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminRolesCountAggregateInputType | true
    }

  export interface AdminRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminRoles'], meta: { name: 'AdminRoles' } }
    /**
     * Find zero or one AdminRoles that matches the filter.
     * @param {AdminRolesFindUniqueArgs} args - Arguments to find a AdminRoles
     * @example
     * // Get one AdminRoles
     * const adminRoles = await prisma.adminRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminRolesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminRolesFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminRolesClient<$Result.GetResult<Prisma.$AdminRolesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AdminRoles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminRolesFindUniqueOrThrowArgs} args - Arguments to find a AdminRoles
     * @example
     * // Get one AdminRoles
     * const adminRoles = await prisma.adminRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminRolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminRolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminRolesClient<$Result.GetResult<Prisma.$AdminRolesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AdminRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRolesFindFirstArgs} args - Arguments to find a AdminRoles
     * @example
     * // Get one AdminRoles
     * const adminRoles = await prisma.adminRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminRolesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminRolesFindFirstArgs<ExtArgs>>
    ): Prisma__AdminRolesClient<$Result.GetResult<Prisma.$AdminRolesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AdminRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRolesFindFirstOrThrowArgs} args - Arguments to find a AdminRoles
     * @example
     * // Get one AdminRoles
     * const adminRoles = await prisma.adminRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminRolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminRolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminRolesClient<$Result.GetResult<Prisma.$AdminRolesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AdminRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminRoles
     * const adminRoles = await prisma.adminRoles.findMany()
     * 
     * // Get first 10 AdminRoles
     * const adminRoles = await prisma.adminRoles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminRolesWithIdOnly = await prisma.adminRoles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminRolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminRolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRolesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AdminRoles.
     * @param {AdminRolesCreateArgs} args - Arguments to create a AdminRoles.
     * @example
     * // Create one AdminRoles
     * const AdminRoles = await prisma.adminRoles.create({
     *   data: {
     *     // ... data to create a AdminRoles
     *   }
     * })
     * 
    **/
    create<T extends AdminRolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminRolesCreateArgs<ExtArgs>>
    ): Prisma__AdminRolesClient<$Result.GetResult<Prisma.$AdminRolesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AdminRoles.
     *     @param {AdminRolesCreateManyArgs} args - Arguments to create many AdminRoles.
     *     @example
     *     // Create many AdminRoles
     *     const adminRoles = await prisma.adminRoles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminRolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminRolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdminRoles.
     * @param {AdminRolesDeleteArgs} args - Arguments to delete one AdminRoles.
     * @example
     * // Delete one AdminRoles
     * const AdminRoles = await prisma.adminRoles.delete({
     *   where: {
     *     // ... filter to delete one AdminRoles
     *   }
     * })
     * 
    **/
    delete<T extends AdminRolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminRolesDeleteArgs<ExtArgs>>
    ): Prisma__AdminRolesClient<$Result.GetResult<Prisma.$AdminRolesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AdminRoles.
     * @param {AdminRolesUpdateArgs} args - Arguments to update one AdminRoles.
     * @example
     * // Update one AdminRoles
     * const adminRoles = await prisma.adminRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminRolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminRolesUpdateArgs<ExtArgs>>
    ): Prisma__AdminRolesClient<$Result.GetResult<Prisma.$AdminRolesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AdminRoles.
     * @param {AdminRolesDeleteManyArgs} args - Arguments to filter AdminRoles to delete.
     * @example
     * // Delete a few AdminRoles
     * const { count } = await prisma.adminRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminRolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminRolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminRoles
     * const adminRoles = await prisma.adminRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminRolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminRolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminRoles.
     * @param {AdminRolesUpsertArgs} args - Arguments to update or create a AdminRoles.
     * @example
     * // Update or create a AdminRoles
     * const adminRoles = await prisma.adminRoles.upsert({
     *   create: {
     *     // ... data to create a AdminRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminRoles we want to update
     *   }
     * })
    **/
    upsert<T extends AdminRolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminRolesUpsertArgs<ExtArgs>>
    ): Prisma__AdminRolesClient<$Result.GetResult<Prisma.$AdminRolesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AdminRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRolesCountArgs} args - Arguments to filter AdminRoles to count.
     * @example
     * // Count the number of AdminRoles
     * const count = await prisma.adminRoles.count({
     *   where: {
     *     // ... the filter for the AdminRoles we want to count
     *   }
     * })
    **/
    count<T extends AdminRolesCountArgs>(
      args?: Subset<T, AdminRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminRolesAggregateArgs>(args: Subset<T, AdminRolesAggregateArgs>): Prisma.PrismaPromise<GetAdminRolesAggregateType<T>>

    /**
     * Group by AdminRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminRolesGroupByArgs['orderBy'] }
        : { orderBy?: AdminRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminRoles model
   */
  readonly fields: AdminRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Admins<T extends AdminRoles$AdminsArgs<ExtArgs> = {}>(args?: Subset<T, AdminRoles$AdminsArgs<ExtArgs>>): Prisma__AdminsClient<$Result.GetResult<Prisma.$AdminsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Roles<T extends AdminRoles$RolesArgs<ExtArgs> = {}>(args?: Subset<T, AdminRoles$RolesArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AdminRoles model
   */ 
  interface AdminRolesFieldRefs {
    readonly id: FieldRef<"AdminRoles", 'Int'>
    readonly admins_id: FieldRef<"AdminRoles", 'Int'>
    readonly roles_id: FieldRef<"AdminRoles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AdminRoles findUnique
   */
  export type AdminRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoles
     */
    select?: AdminRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRolesInclude<ExtArgs> | null
    /**
     * Filter, which AdminRoles to fetch.
     */
    where: AdminRolesWhereUniqueInput
  }

  /**
   * AdminRoles findUniqueOrThrow
   */
  export type AdminRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoles
     */
    select?: AdminRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRolesInclude<ExtArgs> | null
    /**
     * Filter, which AdminRoles to fetch.
     */
    where: AdminRolesWhereUniqueInput
  }

  /**
   * AdminRoles findFirst
   */
  export type AdminRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoles
     */
    select?: AdminRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRolesInclude<ExtArgs> | null
    /**
     * Filter, which AdminRoles to fetch.
     */
    where?: AdminRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoles to fetch.
     */
    orderBy?: AdminRolesOrderByWithRelationInput | AdminRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminRoles.
     */
    cursor?: AdminRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminRoles.
     */
    distinct?: AdminRolesScalarFieldEnum | AdminRolesScalarFieldEnum[]
  }

  /**
   * AdminRoles findFirstOrThrow
   */
  export type AdminRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoles
     */
    select?: AdminRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRolesInclude<ExtArgs> | null
    /**
     * Filter, which AdminRoles to fetch.
     */
    where?: AdminRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoles to fetch.
     */
    orderBy?: AdminRolesOrderByWithRelationInput | AdminRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminRoles.
     */
    cursor?: AdminRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminRoles.
     */
    distinct?: AdminRolesScalarFieldEnum | AdminRolesScalarFieldEnum[]
  }

  /**
   * AdminRoles findMany
   */
  export type AdminRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoles
     */
    select?: AdminRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRolesInclude<ExtArgs> | null
    /**
     * Filter, which AdminRoles to fetch.
     */
    where?: AdminRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoles to fetch.
     */
    orderBy?: AdminRolesOrderByWithRelationInput | AdminRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminRoles.
     */
    cursor?: AdminRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoles.
     */
    skip?: number
    distinct?: AdminRolesScalarFieldEnum | AdminRolesScalarFieldEnum[]
  }

  /**
   * AdminRoles create
   */
  export type AdminRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoles
     */
    select?: AdminRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminRoles.
     */
    data?: XOR<AdminRolesCreateInput, AdminRolesUncheckedCreateInput>
  }

  /**
   * AdminRoles createMany
   */
  export type AdminRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminRoles.
     */
    data: AdminRolesCreateManyInput | AdminRolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminRoles update
   */
  export type AdminRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoles
     */
    select?: AdminRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminRoles.
     */
    data: XOR<AdminRolesUpdateInput, AdminRolesUncheckedUpdateInput>
    /**
     * Choose, which AdminRoles to update.
     */
    where: AdminRolesWhereUniqueInput
  }

  /**
   * AdminRoles updateMany
   */
  export type AdminRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminRoles.
     */
    data: XOR<AdminRolesUpdateManyMutationInput, AdminRolesUncheckedUpdateManyInput>
    /**
     * Filter which AdminRoles to update
     */
    where?: AdminRolesWhereInput
  }

  /**
   * AdminRoles upsert
   */
  export type AdminRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoles
     */
    select?: AdminRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminRoles to update in case it exists.
     */
    where: AdminRolesWhereUniqueInput
    /**
     * In case the AdminRoles found by the `where` argument doesn't exist, create a new AdminRoles with this data.
     */
    create: XOR<AdminRolesCreateInput, AdminRolesUncheckedCreateInput>
    /**
     * In case the AdminRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminRolesUpdateInput, AdminRolesUncheckedUpdateInput>
  }

  /**
   * AdminRoles delete
   */
  export type AdminRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoles
     */
    select?: AdminRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRolesInclude<ExtArgs> | null
    /**
     * Filter which AdminRoles to delete.
     */
    where: AdminRolesWhereUniqueInput
  }

  /**
   * AdminRoles deleteMany
   */
  export type AdminRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminRoles to delete
     */
    where?: AdminRolesWhereInput
  }

  /**
   * AdminRoles.Admins
   */
  export type AdminRoles$AdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admins
     */
    select?: AdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminsInclude<ExtArgs> | null
    where?: AdminsWhereInput
  }

  /**
   * AdminRoles.Roles
   */
  export type AdminRoles$RolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    where?: RolesWhereInput
  }

  /**
   * AdminRoles without action
   */
  export type AdminRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoles
     */
    select?: AdminRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRolesInclude<ExtArgs> | null
  }


  /**
   * Model UserCard
   */

  export type AggregateUserCard = {
    _count: UserCardCountAggregateOutputType | null
    _avg: UserCardAvgAggregateOutputType | null
    _sum: UserCardSumAggregateOutputType | null
    _min: UserCardMinAggregateOutputType | null
    _max: UserCardMaxAggregateOutputType | null
  }

  export type UserCardAvgAggregateOutputType = {
    id: number | null
    users_id: number | null
  }

  export type UserCardSumAggregateOutputType = {
    id: number | null
    users_id: number | null
  }

  export type UserCardMinAggregateOutputType = {
    id: number | null
    users_id: number | null
    card_number: string | null
    card_expiration: string | null
    phone_number: string | null
  }

  export type UserCardMaxAggregateOutputType = {
    id: number | null
    users_id: number | null
    card_number: string | null
    card_expiration: string | null
    phone_number: string | null
  }

  export type UserCardCountAggregateOutputType = {
    id: number
    users_id: number
    card_number: number
    card_expiration: number
    phone_number: number
    _all: number
  }


  export type UserCardAvgAggregateInputType = {
    id?: true
    users_id?: true
  }

  export type UserCardSumAggregateInputType = {
    id?: true
    users_id?: true
  }

  export type UserCardMinAggregateInputType = {
    id?: true
    users_id?: true
    card_number?: true
    card_expiration?: true
    phone_number?: true
  }

  export type UserCardMaxAggregateInputType = {
    id?: true
    users_id?: true
    card_number?: true
    card_expiration?: true
    phone_number?: true
  }

  export type UserCardCountAggregateInputType = {
    id?: true
    users_id?: true
    card_number?: true
    card_expiration?: true
    phone_number?: true
    _all?: true
  }

  export type UserCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCard to aggregate.
     */
    where?: UserCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCards to fetch.
     */
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCards
    **/
    _count?: true | UserCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCardMaxAggregateInputType
  }

  export type GetUserCardAggregateType<T extends UserCardAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCard[P]>
      : GetScalarType<T[P], AggregateUserCard[P]>
  }




  export type UserCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCardWhereInput
    orderBy?: UserCardOrderByWithAggregationInput | UserCardOrderByWithAggregationInput[]
    by: UserCardScalarFieldEnum[] | UserCardScalarFieldEnum
    having?: UserCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCardCountAggregateInputType | true
    _avg?: UserCardAvgAggregateInputType
    _sum?: UserCardSumAggregateInputType
    _min?: UserCardMinAggregateInputType
    _max?: UserCardMaxAggregateInputType
  }

  export type UserCardGroupByOutputType = {
    id: number
    users_id: number | null
    card_number: string
    card_expiration: string
    phone_number: string
    _count: UserCardCountAggregateOutputType | null
    _avg: UserCardAvgAggregateOutputType | null
    _sum: UserCardSumAggregateOutputType | null
    _min: UserCardMinAggregateOutputType | null
    _max: UserCardMaxAggregateOutputType | null
  }

  type GetUserCardGroupByPayload<T extends UserCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCardGroupByOutputType[P]>
            : GetScalarType<T[P], UserCardGroupByOutputType[P]>
        }
      >
    >


  export type UserCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    card_number?: boolean
    card_expiration?: boolean
    phone_number?: boolean
    Users?: boolean | UserCard$UsersArgs<ExtArgs>
    payment?: boolean | UserCard$paymentArgs<ExtArgs>
    _count?: boolean | UserCardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCard"]>

  export type UserCardSelectScalar = {
    id?: boolean
    users_id?: boolean
    card_number?: boolean
    card_expiration?: boolean
    phone_number?: boolean
  }


  export type UserCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UserCard$UsersArgs<ExtArgs>
    payment?: boolean | UserCard$paymentArgs<ExtArgs>
    _count?: boolean | UserCardCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCard"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs> | null
      payment: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      users_id: number | null
      card_number: string
      card_expiration: string
      phone_number: string
    }, ExtArgs["result"]["userCard"]>
    composites: {}
  }


  type UserCardGetPayload<S extends boolean | null | undefined | UserCardDefaultArgs> = $Result.GetResult<Prisma.$UserCardPayload, S>

  type UserCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCardCountAggregateInputType | true
    }

  export interface UserCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCard'], meta: { name: 'UserCard' } }
    /**
     * Find zero or one UserCard that matches the filter.
     * @param {UserCardFindUniqueArgs} args - Arguments to find a UserCard
     * @example
     * // Get one UserCard
     * const userCard = await prisma.userCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserCardFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserCardFindUniqueArgs<ExtArgs>>
    ): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserCard that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserCardFindUniqueOrThrowArgs} args - Arguments to find a UserCard
     * @example
     * // Get one UserCard
     * const userCard = await prisma.userCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserCardFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardFindFirstArgs} args - Arguments to find a UserCard
     * @example
     * // Get one UserCard
     * const userCard = await prisma.userCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserCardFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCardFindFirstArgs<ExtArgs>>
    ): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardFindFirstOrThrowArgs} args - Arguments to find a UserCard
     * @example
     * // Get one UserCard
     * const userCard = await prisma.userCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserCardFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCards
     * const userCards = await prisma.userCard.findMany()
     * 
     * // Get first 10 UserCards
     * const userCards = await prisma.userCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCardWithIdOnly = await prisma.userCard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserCardFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserCard.
     * @param {UserCardCreateArgs} args - Arguments to create a UserCard.
     * @example
     * // Create one UserCard
     * const UserCard = await prisma.userCard.create({
     *   data: {
     *     // ... data to create a UserCard
     *   }
     * })
     * 
    **/
    create<T extends UserCardCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCardCreateArgs<ExtArgs>>
    ): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserCards.
     *     @param {UserCardCreateManyArgs} args - Arguments to create many UserCards.
     *     @example
     *     // Create many UserCards
     *     const userCard = await prisma.userCard.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCardCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCardCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserCard.
     * @param {UserCardDeleteArgs} args - Arguments to delete one UserCard.
     * @example
     * // Delete one UserCard
     * const UserCard = await prisma.userCard.delete({
     *   where: {
     *     // ... filter to delete one UserCard
     *   }
     * })
     * 
    **/
    delete<T extends UserCardDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserCardDeleteArgs<ExtArgs>>
    ): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserCard.
     * @param {UserCardUpdateArgs} args - Arguments to update one UserCard.
     * @example
     * // Update one UserCard
     * const userCard = await prisma.userCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserCardUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCardUpdateArgs<ExtArgs>>
    ): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserCards.
     * @param {UserCardDeleteManyArgs} args - Arguments to filter UserCards to delete.
     * @example
     * // Delete a few UserCards
     * const { count } = await prisma.userCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserCardDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCards
     * const userCard = await prisma.userCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserCardUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserCardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCard.
     * @param {UserCardUpsertArgs} args - Arguments to update or create a UserCard.
     * @example
     * // Update or create a UserCard
     * const userCard = await prisma.userCard.upsert({
     *   create: {
     *     // ... data to create a UserCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCard we want to update
     *   }
     * })
    **/
    upsert<T extends UserCardUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserCardUpsertArgs<ExtArgs>>
    ): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardCountArgs} args - Arguments to filter UserCards to count.
     * @example
     * // Count the number of UserCards
     * const count = await prisma.userCard.count({
     *   where: {
     *     // ... the filter for the UserCards we want to count
     *   }
     * })
    **/
    count<T extends UserCardCountArgs>(
      args?: Subset<T, UserCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCardAggregateArgs>(args: Subset<T, UserCardAggregateArgs>): Prisma.PrismaPromise<GetUserCardAggregateType<T>>

    /**
     * Group by UserCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCardGroupByArgs['orderBy'] }
        : { orderBy?: UserCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCard model
   */
  readonly fields: UserCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends UserCard$UsersArgs<ExtArgs> = {}>(args?: Subset<T, UserCard$UsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    payment<T extends UserCard$paymentArgs<ExtArgs> = {}>(args?: Subset<T, UserCard$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserCard model
   */ 
  interface UserCardFieldRefs {
    readonly id: FieldRef<"UserCard", 'Int'>
    readonly users_id: FieldRef<"UserCard", 'Int'>
    readonly card_number: FieldRef<"UserCard", 'String'>
    readonly card_expiration: FieldRef<"UserCard", 'String'>
    readonly phone_number: FieldRef<"UserCard", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserCard findUnique
   */
  export type UserCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCard to fetch.
     */
    where: UserCardWhereUniqueInput
  }

  /**
   * UserCard findUniqueOrThrow
   */
  export type UserCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCard to fetch.
     */
    where: UserCardWhereUniqueInput
  }

  /**
   * UserCard findFirst
   */
  export type UserCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCard to fetch.
     */
    where?: UserCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCards to fetch.
     */
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCards.
     */
    cursor?: UserCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCards.
     */
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * UserCard findFirstOrThrow
   */
  export type UserCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCard to fetch.
     */
    where?: UserCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCards to fetch.
     */
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCards.
     */
    cursor?: UserCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCards.
     */
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * UserCard findMany
   */
  export type UserCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCards to fetch.
     */
    where?: UserCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCards to fetch.
     */
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCards.
     */
    cursor?: UserCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCards.
     */
    skip?: number
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * UserCard create
   */
  export type UserCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCard.
     */
    data: XOR<UserCardCreateInput, UserCardUncheckedCreateInput>
  }

  /**
   * UserCard createMany
   */
  export type UserCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCards.
     */
    data: UserCardCreateManyInput | UserCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCard update
   */
  export type UserCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCard.
     */
    data: XOR<UserCardUpdateInput, UserCardUncheckedUpdateInput>
    /**
     * Choose, which UserCard to update.
     */
    where: UserCardWhereUniqueInput
  }

  /**
   * UserCard updateMany
   */
  export type UserCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCards.
     */
    data: XOR<UserCardUpdateManyMutationInput, UserCardUncheckedUpdateManyInput>
    /**
     * Filter which UserCards to update
     */
    where?: UserCardWhereInput
  }

  /**
   * UserCard upsert
   */
  export type UserCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCard to update in case it exists.
     */
    where: UserCardWhereUniqueInput
    /**
     * In case the UserCard found by the `where` argument doesn't exist, create a new UserCard with this data.
     */
    create: XOR<UserCardCreateInput, UserCardUncheckedCreateInput>
    /**
     * In case the UserCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCardUpdateInput, UserCardUncheckedUpdateInput>
  }

  /**
   * UserCard delete
   */
  export type UserCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter which UserCard to delete.
     */
    where: UserCardWhereUniqueInput
  }

  /**
   * UserCard deleteMany
   */
  export type UserCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCards to delete
     */
    where?: UserCardWhereInput
  }

  /**
   * UserCard.Users
   */
  export type UserCard$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * UserCard.payment
   */
  export type UserCard$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * UserCard without action
   */
  export type UserCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
  }


  /**
   * Model UserAddress
   */

  export type AggregateUserAddress = {
    _count: UserAddressCountAggregateOutputType | null
    _avg: UserAddressAvgAggregateOutputType | null
    _sum: UserAddressSumAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  export type UserAddressAvgAggregateOutputType = {
    id: number | null
    users_id: number | null
    floor: number | null
  }

  export type UserAddressSumAggregateOutputType = {
    id: number | null
    users_id: number | null
    floor: number | null
  }

  export type UserAddressMinAggregateOutputType = {
    id: number | null
    users_id: number | null
    city: string | null
    area: string | null
    street: string | null
    house: string | null
    apartment_or_office: string | null
    entrance: string | null
    floor: number | null
    intercom_code: string | null
  }

  export type UserAddressMaxAggregateOutputType = {
    id: number | null
    users_id: number | null
    city: string | null
    area: string | null
    street: string | null
    house: string | null
    apartment_or_office: string | null
    entrance: string | null
    floor: number | null
    intercom_code: string | null
  }

  export type UserAddressCountAggregateOutputType = {
    id: number
    users_id: number
    city: number
    area: number
    street: number
    house: number
    apartment_or_office: number
    entrance: number
    floor: number
    intercom_code: number
    _all: number
  }


  export type UserAddressAvgAggregateInputType = {
    id?: true
    users_id?: true
    floor?: true
  }

  export type UserAddressSumAggregateInputType = {
    id?: true
    users_id?: true
    floor?: true
  }

  export type UserAddressMinAggregateInputType = {
    id?: true
    users_id?: true
    city?: true
    area?: true
    street?: true
    house?: true
    apartment_or_office?: true
    entrance?: true
    floor?: true
    intercom_code?: true
  }

  export type UserAddressMaxAggregateInputType = {
    id?: true
    users_id?: true
    city?: true
    area?: true
    street?: true
    house?: true
    apartment_or_office?: true
    entrance?: true
    floor?: true
    intercom_code?: true
  }

  export type UserAddressCountAggregateInputType = {
    id?: true
    users_id?: true
    city?: true
    area?: true
    street?: true
    house?: true
    apartment_or_office?: true
    entrance?: true
    floor?: true
    intercom_code?: true
    _all?: true
  }

  export type UserAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAddress to aggregate.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAddresses
    **/
    _count?: true | UserAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAddressMaxAggregateInputType
  }

  export type GetUserAddressAggregateType<T extends UserAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAddress[P]>
      : GetScalarType<T[P], AggregateUserAddress[P]>
  }




  export type UserAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
    orderBy?: UserAddressOrderByWithAggregationInput | UserAddressOrderByWithAggregationInput[]
    by: UserAddressScalarFieldEnum[] | UserAddressScalarFieldEnum
    having?: UserAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAddressCountAggregateInputType | true
    _avg?: UserAddressAvgAggregateInputType
    _sum?: UserAddressSumAggregateInputType
    _min?: UserAddressMinAggregateInputType
    _max?: UserAddressMaxAggregateInputType
  }

  export type UserAddressGroupByOutputType = {
    id: number
    users_id: number
    city: string
    area: string
    street: string
    house: string
    apartment_or_office: string
    entrance: string | null
    floor: number | null
    intercom_code: string | null
    _count: UserAddressCountAggregateOutputType | null
    _avg: UserAddressAvgAggregateOutputType | null
    _sum: UserAddressSumAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  type GetUserAddressGroupByPayload<T extends UserAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
            : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
        }
      >
    >


  export type UserAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    city?: boolean
    area?: boolean
    street?: boolean
    house?: boolean
    apartment_or_office?: boolean
    entrance?: boolean
    floor?: boolean
    intercom_code?: boolean
    Users?: boolean | UserAddress$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["userAddress"]>

  export type UserAddressSelectScalar = {
    id?: boolean
    users_id?: boolean
    city?: boolean
    area?: boolean
    street?: boolean
    house?: boolean
    apartment_or_office?: boolean
    entrance?: boolean
    floor?: boolean
    intercom_code?: boolean
  }


  export type UserAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UserAddress$UsersArgs<ExtArgs>
  }


  export type $UserAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAddress"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      users_id: number
      city: string
      area: string
      street: string
      house: string
      apartment_or_office: string
      entrance: string | null
      floor: number | null
      intercom_code: string | null
    }, ExtArgs["result"]["userAddress"]>
    composites: {}
  }


  type UserAddressGetPayload<S extends boolean | null | undefined | UserAddressDefaultArgs> = $Result.GetResult<Prisma.$UserAddressPayload, S>

  type UserAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAddressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAddressCountAggregateInputType | true
    }

  export interface UserAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAddress'], meta: { name: 'UserAddress' } }
    /**
     * Find zero or one UserAddress that matches the filter.
     * @param {UserAddressFindUniqueArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserAddressFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserAddressFindUniqueArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserAddress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserAddressFindUniqueOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserAddressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAddressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserAddressFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAddressFindFirstArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserAddressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAddressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAddresses
     * const userAddresses = await prisma.userAddress.findMany()
     * 
     * // Get first 10 UserAddresses
     * const userAddresses = await prisma.userAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserAddressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAddressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserAddress.
     * @param {UserAddressCreateArgs} args - Arguments to create a UserAddress.
     * @example
     * // Create one UserAddress
     * const UserAddress = await prisma.userAddress.create({
     *   data: {
     *     // ... data to create a UserAddress
     *   }
     * })
     * 
    **/
    create<T extends UserAddressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAddressCreateArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserAddresses.
     *     @param {UserAddressCreateManyArgs} args - Arguments to create many UserAddresses.
     *     @example
     *     // Create many UserAddresses
     *     const userAddress = await prisma.userAddress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserAddressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAddressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAddress.
     * @param {UserAddressDeleteArgs} args - Arguments to delete one UserAddress.
     * @example
     * // Delete one UserAddress
     * const UserAddress = await prisma.userAddress.delete({
     *   where: {
     *     // ... filter to delete one UserAddress
     *   }
     * })
     * 
    **/
    delete<T extends UserAddressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserAddressDeleteArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserAddress.
     * @param {UserAddressUpdateArgs} args - Arguments to update one UserAddress.
     * @example
     * // Update one UserAddress
     * const userAddress = await prisma.userAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserAddressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAddressUpdateArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserAddresses.
     * @param {UserAddressDeleteManyArgs} args - Arguments to filter UserAddresses to delete.
     * @example
     * // Delete a few UserAddresses
     * const { count } = await prisma.userAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserAddressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAddressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAddresses
     * const userAddress = await prisma.userAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserAddressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserAddressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAddress.
     * @param {UserAddressUpsertArgs} args - Arguments to update or create a UserAddress.
     * @example
     * // Update or create a UserAddress
     * const userAddress = await prisma.userAddress.upsert({
     *   create: {
     *     // ... data to create a UserAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAddress we want to update
     *   }
     * })
    **/
    upsert<T extends UserAddressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserAddressUpsertArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressCountArgs} args - Arguments to filter UserAddresses to count.
     * @example
     * // Count the number of UserAddresses
     * const count = await prisma.userAddress.count({
     *   where: {
     *     // ... the filter for the UserAddresses we want to count
     *   }
     * })
    **/
    count<T extends UserAddressCountArgs>(
      args?: Subset<T, UserAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAddressAggregateArgs>(args: Subset<T, UserAddressAggregateArgs>): Prisma.PrismaPromise<GetUserAddressAggregateType<T>>

    /**
     * Group by UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAddressGroupByArgs['orderBy'] }
        : { orderBy?: UserAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAddress model
   */
  readonly fields: UserAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends UserAddress$UsersArgs<ExtArgs> = {}>(args?: Subset<T, UserAddress$UsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserAddress model
   */ 
  interface UserAddressFieldRefs {
    readonly id: FieldRef<"UserAddress", 'Int'>
    readonly users_id: FieldRef<"UserAddress", 'Int'>
    readonly city: FieldRef<"UserAddress", 'String'>
    readonly area: FieldRef<"UserAddress", 'String'>
    readonly street: FieldRef<"UserAddress", 'String'>
    readonly house: FieldRef<"UserAddress", 'String'>
    readonly apartment_or_office: FieldRef<"UserAddress", 'String'>
    readonly entrance: FieldRef<"UserAddress", 'String'>
    readonly floor: FieldRef<"UserAddress", 'Int'>
    readonly intercom_code: FieldRef<"UserAddress", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserAddress findUnique
   */
  export type UserAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress findUniqueOrThrow
   */
  export type UserAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress findFirst
   */
  export type UserAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress findFirstOrThrow
   */
  export type UserAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress findMany
   */
  export type UserAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddresses to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress create
   */
  export type UserAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAddress.
     */
    data: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
  }

  /**
   * UserAddress createMany
   */
  export type UserAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAddresses.
     */
    data: UserAddressCreateManyInput | UserAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAddress update
   */
  export type UserAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAddress.
     */
    data: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
    /**
     * Choose, which UserAddress to update.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress updateMany
   */
  export type UserAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAddresses.
     */
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyInput>
    /**
     * Filter which UserAddresses to update
     */
    where?: UserAddressWhereInput
  }

  /**
   * UserAddress upsert
   */
  export type UserAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAddress to update in case it exists.
     */
    where: UserAddressWhereUniqueInput
    /**
     * In case the UserAddress found by the `where` argument doesn't exist, create a new UserAddress with this data.
     */
    create: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
    /**
     * In case the UserAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
  }

  /**
   * UserAddress delete
   */
  export type UserAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter which UserAddress to delete.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress deleteMany
   */
  export type UserAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAddresses to delete
     */
    where?: UserAddressWhereInput
  }

  /**
   * UserAddress.Users
   */
  export type UserAddress$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * UserAddress without action
   */
  export type UserAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    phone_number_1: string | null
    phone_number_2: string | null
    email: string | null
    hashed_password: string | null
    hashed_refresh_token: string | null
    car_name: string | null
    car_number: string | null
    car_size: string | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    phone_number_1: string | null
    phone_number_2: string | null
    email: string | null
    hashed_password: string | null
    hashed_refresh_token: string | null
    car_name: string | null
    car_number: string | null
    car_size: string | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    full_name: number
    phone_number_1: number
    phone_number_2: number
    email: number
    hashed_password: number
    hashed_refresh_token: number
    car_name: number
    car_number: number
    car_size: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    full_name?: true
    phone_number_1?: true
    phone_number_2?: true
    email?: true
    hashed_password?: true
    hashed_refresh_token?: true
    car_name?: true
    car_number?: true
    car_size?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    full_name?: true
    phone_number_1?: true
    phone_number_2?: true
    email?: true
    hashed_password?: true
    hashed_refresh_token?: true
    car_name?: true
    car_number?: true
    car_size?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    full_name?: true
    phone_number_1?: true
    phone_number_2?: true
    email?: true
    hashed_password?: true
    hashed_refresh_token?: true
    car_name?: true
    car_number?: true
    car_size?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    full_name: string
    phone_number_1: string
    phone_number_2: string
    email: string
    hashed_password: string
    hashed_refresh_token: string | null
    car_name: string
    car_number: string
    car_size: string
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone_number_1?: boolean
    phone_number_2?: boolean
    email?: boolean
    hashed_password?: boolean
    hashed_refresh_token?: boolean
    car_name?: boolean
    car_number?: boolean
    car_size?: boolean
    contracts?: boolean | Supplier$contractsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    full_name?: boolean
    phone_number_1?: boolean
    phone_number_2?: boolean
    email?: boolean
    hashed_password?: boolean
    hashed_refresh_token?: boolean
    car_name?: boolean
    car_number?: boolean
    car_size?: boolean
  }


  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | Supplier$contractsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      contracts: Prisma.$ContractsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      phone_number_1: string
      phone_number_2: string
      email: string
      hashed_password: string
      hashed_refresh_token: string | null
      car_name: string
      car_number: string
      car_size: string
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }


  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SupplierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SupplierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SupplierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends SupplierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Suppliers.
     *     @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     *     @example
     *     // Create many Suppliers
     *     const supplier = await prisma.supplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SupplierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends SupplierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SupplierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SupplierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SupplierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends SupplierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contracts<T extends Supplier$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'Int'>
    readonly full_name: FieldRef<"Supplier", 'String'>
    readonly phone_number_1: FieldRef<"Supplier", 'String'>
    readonly phone_number_2: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly hashed_password: FieldRef<"Supplier", 'String'>
    readonly hashed_refresh_token: FieldRef<"Supplier", 'String'>
    readonly car_name: FieldRef<"Supplier", 'String'>
    readonly car_number: FieldRef<"Supplier", 'String'>
    readonly car_size: FieldRef<"Supplier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier.contracts
   */
  export type Supplier$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    where?: ContractsWhereInput
    orderBy?: ContractsOrderByWithRelationInput | ContractsOrderByWithRelationInput[]
    cursor?: ContractsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractsScalarFieldEnum | ContractsScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    users_id: number | null
    contracts_id: number | null
    user_card_id: number | null
    payment_amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    users_id: number | null
    contracts_id: number | null
    user_card_id: number | null
    payment_amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    users_id: number | null
    contracts_id: number | null
    user_card_id: number | null
    company_card: string | null
    payment_amount: Decimal | null
    payment_status: string | null
    payment_date: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    users_id: number | null
    contracts_id: number | null
    user_card_id: number | null
    company_card: string | null
    payment_amount: Decimal | null
    payment_status: string | null
    payment_date: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    users_id: number
    contracts_id: number
    user_card_id: number
    company_card: number
    payment_amount: number
    payment_status: number
    payment_date: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    users_id?: true
    contracts_id?: true
    user_card_id?: true
    payment_amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    users_id?: true
    contracts_id?: true
    user_card_id?: true
    payment_amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    users_id?: true
    contracts_id?: true
    user_card_id?: true
    company_card?: true
    payment_amount?: true
    payment_status?: true
    payment_date?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    users_id?: true
    contracts_id?: true
    user_card_id?: true
    company_card?: true
    payment_amount?: true
    payment_status?: true
    payment_date?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    users_id?: true
    contracts_id?: true
    user_card_id?: true
    company_card?: true
    payment_amount?: true
    payment_status?: true
    payment_date?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    users_id: number | null
    contracts_id: number | null
    user_card_id: number | null
    company_card: string
    payment_amount: Decimal
    payment_status: string
    payment_date: string
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    contracts_id?: boolean
    user_card_id?: boolean
    company_card?: boolean
    payment_amount?: boolean
    payment_status?: boolean
    payment_date?: boolean
    Users?: boolean | Payment$UsersArgs<ExtArgs>
    Contracts?: boolean | Payment$ContractsArgs<ExtArgs>
    UserCard?: boolean | Payment$UserCardArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    users_id?: boolean
    contracts_id?: boolean
    user_card_id?: boolean
    company_card?: boolean
    payment_amount?: boolean
    payment_status?: boolean
    payment_date?: boolean
  }


  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Payment$UsersArgs<ExtArgs>
    Contracts?: boolean | Payment$ContractsArgs<ExtArgs>
    UserCard?: boolean | Payment$UserCardArgs<ExtArgs>
  }


  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs> | null
      Contracts: Prisma.$ContractsPayload<ExtArgs> | null
      UserCard: Prisma.$UserCardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      users_id: number | null
      contracts_id: number | null
      user_card_id: number | null
      company_card: string
      payment_amount: Prisma.Decimal
      payment_status: string
      payment_date: string
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }


  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends Payment$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Payment$UsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Contracts<T extends Payment$ContractsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$ContractsArgs<ExtArgs>>): Prisma__ContractsClient<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    UserCard<T extends Payment$UserCardArgs<ExtArgs> = {}>(args?: Subset<T, Payment$UserCardArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly users_id: FieldRef<"Payment", 'Int'>
    readonly contracts_id: FieldRef<"Payment", 'Int'>
    readonly user_card_id: FieldRef<"Payment", 'Int'>
    readonly company_card: FieldRef<"Payment", 'String'>
    readonly payment_amount: FieldRef<"Payment", 'Decimal'>
    readonly payment_status: FieldRef<"Payment", 'String'>
    readonly payment_date: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.Users
   */
  export type Payment$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * Payment.Contracts
   */
  export type Payment$ContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    where?: ContractsWhereInput
  }

  /**
   * Payment.UserCard
   */
  export type Payment$UserCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    where?: UserCardWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Contracts
   */

  export type AggregateContracts = {
    _count: ContractsCountAggregateOutputType | null
    _avg: ContractsAvgAggregateOutputType | null
    _sum: ContractsSumAggregateOutputType | null
    _min: ContractsMinAggregateOutputType | null
    _max: ContractsMaxAggregateOutputType | null
  }

  export type ContractsAvgAggregateOutputType = {
    id: number | null
    users_id: number | null
    supplier_id: number | null
  }

  export type ContractsSumAggregateOutputType = {
    id: number | null
    users_id: number | null
    supplier_id: number | null
  }

  export type ContractsMinAggregateOutputType = {
    id: number | null
    users_id: number | null
    supplier_id: number | null
    delivery_date: string | null
    note_to_supplier: string | null
    hours: string | null
    delivery_status: string | null
  }

  export type ContractsMaxAggregateOutputType = {
    id: number | null
    users_id: number | null
    supplier_id: number | null
    delivery_date: string | null
    note_to_supplier: string | null
    hours: string | null
    delivery_status: string | null
  }

  export type ContractsCountAggregateOutputType = {
    id: number
    users_id: number
    supplier_id: number
    delivery_date: number
    note_to_supplier: number
    hours: number
    delivery_status: number
    _all: number
  }


  export type ContractsAvgAggregateInputType = {
    id?: true
    users_id?: true
    supplier_id?: true
  }

  export type ContractsSumAggregateInputType = {
    id?: true
    users_id?: true
    supplier_id?: true
  }

  export type ContractsMinAggregateInputType = {
    id?: true
    users_id?: true
    supplier_id?: true
    delivery_date?: true
    note_to_supplier?: true
    hours?: true
    delivery_status?: true
  }

  export type ContractsMaxAggregateInputType = {
    id?: true
    users_id?: true
    supplier_id?: true
    delivery_date?: true
    note_to_supplier?: true
    hours?: true
    delivery_status?: true
  }

  export type ContractsCountAggregateInputType = {
    id?: true
    users_id?: true
    supplier_id?: true
    delivery_date?: true
    note_to_supplier?: true
    hours?: true
    delivery_status?: true
    _all?: true
  }

  export type ContractsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to aggregate.
     */
    where?: ContractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractsOrderByWithRelationInput | ContractsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractsMaxAggregateInputType
  }

  export type GetContractsAggregateType<T extends ContractsAggregateArgs> = {
        [P in keyof T & keyof AggregateContracts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContracts[P]>
      : GetScalarType<T[P], AggregateContracts[P]>
  }




  export type ContractsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractsWhereInput
    orderBy?: ContractsOrderByWithAggregationInput | ContractsOrderByWithAggregationInput[]
    by: ContractsScalarFieldEnum[] | ContractsScalarFieldEnum
    having?: ContractsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractsCountAggregateInputType | true
    _avg?: ContractsAvgAggregateInputType
    _sum?: ContractsSumAggregateInputType
    _min?: ContractsMinAggregateInputType
    _max?: ContractsMaxAggregateInputType
  }

  export type ContractsGroupByOutputType = {
    id: number
    users_id: number | null
    supplier_id: number | null
    delivery_date: string
    note_to_supplier: string | null
    hours: string
    delivery_status: string
    _count: ContractsCountAggregateOutputType | null
    _avg: ContractsAvgAggregateOutputType | null
    _sum: ContractsSumAggregateOutputType | null
    _min: ContractsMinAggregateOutputType | null
    _max: ContractsMaxAggregateOutputType | null
  }

  type GetContractsGroupByPayload<T extends ContractsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractsGroupByOutputType[P]>
            : GetScalarType<T[P], ContractsGroupByOutputType[P]>
        }
      >
    >


  export type ContractsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    supplier_id?: boolean
    delivery_date?: boolean
    note_to_supplier?: boolean
    hours?: boolean
    delivery_status?: boolean
    Users?: boolean | Contracts$UsersArgs<ExtArgs>
    Supplier?: boolean | Contracts$SupplierArgs<ExtArgs>
    contracts_detailing?: boolean | Contracts$contracts_detailingArgs<ExtArgs>
    payment?: boolean | Contracts$paymentArgs<ExtArgs>
    _count?: boolean | ContractsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contracts"]>

  export type ContractsSelectScalar = {
    id?: boolean
    users_id?: boolean
    supplier_id?: boolean
    delivery_date?: boolean
    note_to_supplier?: boolean
    hours?: boolean
    delivery_status?: boolean
  }


  export type ContractsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Contracts$UsersArgs<ExtArgs>
    Supplier?: boolean | Contracts$SupplierArgs<ExtArgs>
    contracts_detailing?: boolean | Contracts$contracts_detailingArgs<ExtArgs>
    payment?: boolean | Contracts$paymentArgs<ExtArgs>
    _count?: boolean | ContractsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ContractsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contracts"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs> | null
      Supplier: Prisma.$SupplierPayload<ExtArgs> | null
      contracts_detailing: Prisma.$ContractsDetailingPayload<ExtArgs>[]
      payment: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      users_id: number | null
      supplier_id: number | null
      delivery_date: string
      note_to_supplier: string | null
      hours: string
      delivery_status: string
    }, ExtArgs["result"]["contracts"]>
    composites: {}
  }


  type ContractsGetPayload<S extends boolean | null | undefined | ContractsDefaultArgs> = $Result.GetResult<Prisma.$ContractsPayload, S>

  type ContractsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractsCountAggregateInputType | true
    }

  export interface ContractsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contracts'], meta: { name: 'Contracts' } }
    /**
     * Find zero or one Contracts that matches the filter.
     * @param {ContractsFindUniqueArgs} args - Arguments to find a Contracts
     * @example
     * // Get one Contracts
     * const contracts = await prisma.contracts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContractsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContractsFindUniqueArgs<ExtArgs>>
    ): Prisma__ContractsClient<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contracts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContractsFindUniqueOrThrowArgs} args - Arguments to find a Contracts
     * @example
     * // Get one Contracts
     * const contracts = await prisma.contracts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContractsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContractsClient<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsFindFirstArgs} args - Arguments to find a Contracts
     * @example
     * // Get one Contracts
     * const contracts = await prisma.contracts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContractsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractsFindFirstArgs<ExtArgs>>
    ): Prisma__ContractsClient<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contracts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsFindFirstOrThrowArgs} args - Arguments to find a Contracts
     * @example
     * // Get one Contracts
     * const contracts = await prisma.contracts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContractsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContractsClient<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contracts.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contracts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractsWithIdOnly = await prisma.contracts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContractsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contracts.
     * @param {ContractsCreateArgs} args - Arguments to create a Contracts.
     * @example
     * // Create one Contracts
     * const Contracts = await prisma.contracts.create({
     *   data: {
     *     // ... data to create a Contracts
     *   }
     * })
     * 
    **/
    create<T extends ContractsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContractsCreateArgs<ExtArgs>>
    ): Prisma__ContractsClient<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contracts.
     *     @param {ContractsCreateManyArgs} args - Arguments to create many Contracts.
     *     @example
     *     // Create many Contracts
     *     const contracts = await prisma.contracts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContractsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contracts.
     * @param {ContractsDeleteArgs} args - Arguments to delete one Contracts.
     * @example
     * // Delete one Contracts
     * const Contracts = await prisma.contracts.delete({
     *   where: {
     *     // ... filter to delete one Contracts
     *   }
     * })
     * 
    **/
    delete<T extends ContractsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContractsDeleteArgs<ExtArgs>>
    ): Prisma__ContractsClient<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contracts.
     * @param {ContractsUpdateArgs} args - Arguments to update one Contracts.
     * @example
     * // Update one Contracts
     * const contracts = await prisma.contracts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContractsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContractsUpdateArgs<ExtArgs>>
    ): Prisma__ContractsClient<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contracts.
     * @param {ContractsDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contracts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContractsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contracts = await prisma.contracts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContractsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContractsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contracts.
     * @param {ContractsUpsertArgs} args - Arguments to update or create a Contracts.
     * @example
     * // Update or create a Contracts
     * const contracts = await prisma.contracts.upsert({
     *   create: {
     *     // ... data to create a Contracts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contracts we want to update
     *   }
     * })
    **/
    upsert<T extends ContractsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContractsUpsertArgs<ExtArgs>>
    ): Prisma__ContractsClient<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contracts.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractsCountArgs>(
      args?: Subset<T, ContractsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractsAggregateArgs>(args: Subset<T, ContractsAggregateArgs>): Prisma.PrismaPromise<GetContractsAggregateType<T>>

    /**
     * Group by Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractsGroupByArgs['orderBy'] }
        : { orderBy?: ContractsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contracts model
   */
  readonly fields: ContractsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contracts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends Contracts$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Contracts$UsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Supplier<T extends Contracts$SupplierArgs<ExtArgs> = {}>(args?: Subset<T, Contracts$SupplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    contracts_detailing<T extends Contracts$contracts_detailingArgs<ExtArgs> = {}>(args?: Subset<T, Contracts$contracts_detailingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractsDetailingPayload<ExtArgs>, T, 'findMany'> | Null>;

    payment<T extends Contracts$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Contracts$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Contracts model
   */ 
  interface ContractsFieldRefs {
    readonly id: FieldRef<"Contracts", 'Int'>
    readonly users_id: FieldRef<"Contracts", 'Int'>
    readonly supplier_id: FieldRef<"Contracts", 'Int'>
    readonly delivery_date: FieldRef<"Contracts", 'String'>
    readonly note_to_supplier: FieldRef<"Contracts", 'String'>
    readonly hours: FieldRef<"Contracts", 'String'>
    readonly delivery_status: FieldRef<"Contracts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contracts findUnique
   */
  export type ContractsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where: ContractsWhereUniqueInput
  }

  /**
   * Contracts findUniqueOrThrow
   */
  export type ContractsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where: ContractsWhereUniqueInput
  }

  /**
   * Contracts findFirst
   */
  export type ContractsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractsOrderByWithRelationInput | ContractsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractsScalarFieldEnum | ContractsScalarFieldEnum[]
  }

  /**
   * Contracts findFirstOrThrow
   */
  export type ContractsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractsOrderByWithRelationInput | ContractsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractsScalarFieldEnum | ContractsScalarFieldEnum[]
  }

  /**
   * Contracts findMany
   */
  export type ContractsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractsOrderByWithRelationInput | ContractsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractsScalarFieldEnum | ContractsScalarFieldEnum[]
  }

  /**
   * Contracts create
   */
  export type ContractsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    /**
     * The data needed to create a Contracts.
     */
    data: XOR<ContractsCreateInput, ContractsUncheckedCreateInput>
  }

  /**
   * Contracts createMany
   */
  export type ContractsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractsCreateManyInput | ContractsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contracts update
   */
  export type ContractsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    /**
     * The data needed to update a Contracts.
     */
    data: XOR<ContractsUpdateInput, ContractsUncheckedUpdateInput>
    /**
     * Choose, which Contracts to update.
     */
    where: ContractsWhereUniqueInput
  }

  /**
   * Contracts updateMany
   */
  export type ContractsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractsUpdateManyMutationInput, ContractsUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractsWhereInput
  }

  /**
   * Contracts upsert
   */
  export type ContractsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    /**
     * The filter to search for the Contracts to update in case it exists.
     */
    where: ContractsWhereUniqueInput
    /**
     * In case the Contracts found by the `where` argument doesn't exist, create a new Contracts with this data.
     */
    create: XOR<ContractsCreateInput, ContractsUncheckedCreateInput>
    /**
     * In case the Contracts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractsUpdateInput, ContractsUncheckedUpdateInput>
  }

  /**
   * Contracts delete
   */
  export type ContractsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    /**
     * Filter which Contracts to delete.
     */
    where: ContractsWhereUniqueInput
  }

  /**
   * Contracts deleteMany
   */
  export type ContractsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractsWhereInput
  }

  /**
   * Contracts.Users
   */
  export type Contracts$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * Contracts.Supplier
   */
  export type Contracts$SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * Contracts.contracts_detailing
   */
  export type Contracts$contracts_detailingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
    where?: ContractsDetailingWhereInput
    orderBy?: ContractsDetailingOrderByWithRelationInput | ContractsDetailingOrderByWithRelationInput[]
    cursor?: ContractsDetailingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractsDetailingScalarFieldEnum | ContractsDetailingScalarFieldEnum[]
  }

  /**
   * Contracts.payment
   */
  export type Contracts$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Contracts without action
   */
  export type ContractsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
  }


  /**
   * Model ContractsDetailing
   */

  export type AggregateContractsDetailing = {
    _count: ContractsDetailingCountAggregateOutputType | null
    _avg: ContractsDetailingAvgAggregateOutputType | null
    _sum: ContractsDetailingSumAggregateOutputType | null
    _min: ContractsDetailingMinAggregateOutputType | null
    _max: ContractsDetailingMaxAggregateOutputType | null
  }

  export type ContractsDetailingAvgAggregateOutputType = {
    id: number | null
    users_id: number | null
    furniture_id: number | null
    contracts_id: number | null
    count: number | null
    total_price: Decimal | null
  }

  export type ContractsDetailingSumAggregateOutputType = {
    id: number | null
    users_id: number | null
    furniture_id: number | null
    contracts_id: number | null
    count: number | null
    total_price: Decimal | null
  }

  export type ContractsDetailingMinAggregateOutputType = {
    id: number | null
    users_id: number | null
    furniture_id: number | null
    contracts_id: number | null
    count: number | null
    total_price: Decimal | null
    contract_date: string | null
  }

  export type ContractsDetailingMaxAggregateOutputType = {
    id: number | null
    users_id: number | null
    furniture_id: number | null
    contracts_id: number | null
    count: number | null
    total_price: Decimal | null
    contract_date: string | null
  }

  export type ContractsDetailingCountAggregateOutputType = {
    id: number
    users_id: number
    furniture_id: number
    contracts_id: number
    count: number
    total_price: number
    contract_date: number
    _all: number
  }


  export type ContractsDetailingAvgAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
    contracts_id?: true
    count?: true
    total_price?: true
  }

  export type ContractsDetailingSumAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
    contracts_id?: true
    count?: true
    total_price?: true
  }

  export type ContractsDetailingMinAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
    contracts_id?: true
    count?: true
    total_price?: true
    contract_date?: true
  }

  export type ContractsDetailingMaxAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
    contracts_id?: true
    count?: true
    total_price?: true
    contract_date?: true
  }

  export type ContractsDetailingCountAggregateInputType = {
    id?: true
    users_id?: true
    furniture_id?: true
    contracts_id?: true
    count?: true
    total_price?: true
    contract_date?: true
    _all?: true
  }

  export type ContractsDetailingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractsDetailing to aggregate.
     */
    where?: ContractsDetailingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractsDetailings to fetch.
     */
    orderBy?: ContractsDetailingOrderByWithRelationInput | ContractsDetailingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractsDetailingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractsDetailings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractsDetailings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractsDetailings
    **/
    _count?: true | ContractsDetailingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractsDetailingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractsDetailingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractsDetailingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractsDetailingMaxAggregateInputType
  }

  export type GetContractsDetailingAggregateType<T extends ContractsDetailingAggregateArgs> = {
        [P in keyof T & keyof AggregateContractsDetailing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractsDetailing[P]>
      : GetScalarType<T[P], AggregateContractsDetailing[P]>
  }




  export type ContractsDetailingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractsDetailingWhereInput
    orderBy?: ContractsDetailingOrderByWithAggregationInput | ContractsDetailingOrderByWithAggregationInput[]
    by: ContractsDetailingScalarFieldEnum[] | ContractsDetailingScalarFieldEnum
    having?: ContractsDetailingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractsDetailingCountAggregateInputType | true
    _avg?: ContractsDetailingAvgAggregateInputType
    _sum?: ContractsDetailingSumAggregateInputType
    _min?: ContractsDetailingMinAggregateInputType
    _max?: ContractsDetailingMaxAggregateInputType
  }

  export type ContractsDetailingGroupByOutputType = {
    id: number
    users_id: number | null
    furniture_id: number | null
    contracts_id: number | null
    count: number
    total_price: Decimal
    contract_date: string
    _count: ContractsDetailingCountAggregateOutputType | null
    _avg: ContractsDetailingAvgAggregateOutputType | null
    _sum: ContractsDetailingSumAggregateOutputType | null
    _min: ContractsDetailingMinAggregateOutputType | null
    _max: ContractsDetailingMaxAggregateOutputType | null
  }

  type GetContractsDetailingGroupByPayload<T extends ContractsDetailingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractsDetailingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractsDetailingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractsDetailingGroupByOutputType[P]>
            : GetScalarType<T[P], ContractsDetailingGroupByOutputType[P]>
        }
      >
    >


  export type ContractsDetailingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    furniture_id?: boolean
    contracts_id?: boolean
    count?: boolean
    total_price?: boolean
    contract_date?: boolean
    Users?: boolean | ContractsDetailing$UsersArgs<ExtArgs>
    Furniture?: boolean | ContractsDetailing$FurnitureArgs<ExtArgs>
    Contracts?: boolean | ContractsDetailing$ContractsArgs<ExtArgs>
  }, ExtArgs["result"]["contractsDetailing"]>

  export type ContractsDetailingSelectScalar = {
    id?: boolean
    users_id?: boolean
    furniture_id?: boolean
    contracts_id?: boolean
    count?: boolean
    total_price?: boolean
    contract_date?: boolean
  }


  export type ContractsDetailingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | ContractsDetailing$UsersArgs<ExtArgs>
    Furniture?: boolean | ContractsDetailing$FurnitureArgs<ExtArgs>
    Contracts?: boolean | ContractsDetailing$ContractsArgs<ExtArgs>
  }


  export type $ContractsDetailingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractsDetailing"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs> | null
      Furniture: Prisma.$FurniturePayload<ExtArgs> | null
      Contracts: Prisma.$ContractsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      users_id: number | null
      furniture_id: number | null
      contracts_id: number | null
      count: number
      total_price: Prisma.Decimal
      contract_date: string
    }, ExtArgs["result"]["contractsDetailing"]>
    composites: {}
  }


  type ContractsDetailingGetPayload<S extends boolean | null | undefined | ContractsDetailingDefaultArgs> = $Result.GetResult<Prisma.$ContractsDetailingPayload, S>

  type ContractsDetailingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractsDetailingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractsDetailingCountAggregateInputType | true
    }

  export interface ContractsDetailingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractsDetailing'], meta: { name: 'ContractsDetailing' } }
    /**
     * Find zero or one ContractsDetailing that matches the filter.
     * @param {ContractsDetailingFindUniqueArgs} args - Arguments to find a ContractsDetailing
     * @example
     * // Get one ContractsDetailing
     * const contractsDetailing = await prisma.contractsDetailing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContractsDetailingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContractsDetailingFindUniqueArgs<ExtArgs>>
    ): Prisma__ContractsDetailingClient<$Result.GetResult<Prisma.$ContractsDetailingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContractsDetailing that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContractsDetailingFindUniqueOrThrowArgs} args - Arguments to find a ContractsDetailing
     * @example
     * // Get one ContractsDetailing
     * const contractsDetailing = await prisma.contractsDetailing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContractsDetailingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractsDetailingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContractsDetailingClient<$Result.GetResult<Prisma.$ContractsDetailingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContractsDetailing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsDetailingFindFirstArgs} args - Arguments to find a ContractsDetailing
     * @example
     * // Get one ContractsDetailing
     * const contractsDetailing = await prisma.contractsDetailing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContractsDetailingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractsDetailingFindFirstArgs<ExtArgs>>
    ): Prisma__ContractsDetailingClient<$Result.GetResult<Prisma.$ContractsDetailingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContractsDetailing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsDetailingFindFirstOrThrowArgs} args - Arguments to find a ContractsDetailing
     * @example
     * // Get one ContractsDetailing
     * const contractsDetailing = await prisma.contractsDetailing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContractsDetailingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractsDetailingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContractsDetailingClient<$Result.GetResult<Prisma.$ContractsDetailingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ContractsDetailings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsDetailingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractsDetailings
     * const contractsDetailings = await prisma.contractsDetailing.findMany()
     * 
     * // Get first 10 ContractsDetailings
     * const contractsDetailings = await prisma.contractsDetailing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractsDetailingWithIdOnly = await prisma.contractsDetailing.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContractsDetailingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractsDetailingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractsDetailingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContractsDetailing.
     * @param {ContractsDetailingCreateArgs} args - Arguments to create a ContractsDetailing.
     * @example
     * // Create one ContractsDetailing
     * const ContractsDetailing = await prisma.contractsDetailing.create({
     *   data: {
     *     // ... data to create a ContractsDetailing
     *   }
     * })
     * 
    **/
    create<T extends ContractsDetailingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContractsDetailingCreateArgs<ExtArgs>>
    ): Prisma__ContractsDetailingClient<$Result.GetResult<Prisma.$ContractsDetailingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ContractsDetailings.
     *     @param {ContractsDetailingCreateManyArgs} args - Arguments to create many ContractsDetailings.
     *     @example
     *     // Create many ContractsDetailings
     *     const contractsDetailing = await prisma.contractsDetailing.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContractsDetailingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractsDetailingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContractsDetailing.
     * @param {ContractsDetailingDeleteArgs} args - Arguments to delete one ContractsDetailing.
     * @example
     * // Delete one ContractsDetailing
     * const ContractsDetailing = await prisma.contractsDetailing.delete({
     *   where: {
     *     // ... filter to delete one ContractsDetailing
     *   }
     * })
     * 
    **/
    delete<T extends ContractsDetailingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContractsDetailingDeleteArgs<ExtArgs>>
    ): Prisma__ContractsDetailingClient<$Result.GetResult<Prisma.$ContractsDetailingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContractsDetailing.
     * @param {ContractsDetailingUpdateArgs} args - Arguments to update one ContractsDetailing.
     * @example
     * // Update one ContractsDetailing
     * const contractsDetailing = await prisma.contractsDetailing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContractsDetailingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContractsDetailingUpdateArgs<ExtArgs>>
    ): Prisma__ContractsDetailingClient<$Result.GetResult<Prisma.$ContractsDetailingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ContractsDetailings.
     * @param {ContractsDetailingDeleteManyArgs} args - Arguments to filter ContractsDetailings to delete.
     * @example
     * // Delete a few ContractsDetailings
     * const { count } = await prisma.contractsDetailing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContractsDetailingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractsDetailingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractsDetailings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsDetailingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractsDetailings
     * const contractsDetailing = await prisma.contractsDetailing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContractsDetailingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContractsDetailingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContractsDetailing.
     * @param {ContractsDetailingUpsertArgs} args - Arguments to update or create a ContractsDetailing.
     * @example
     * // Update or create a ContractsDetailing
     * const contractsDetailing = await prisma.contractsDetailing.upsert({
     *   create: {
     *     // ... data to create a ContractsDetailing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractsDetailing we want to update
     *   }
     * })
    **/
    upsert<T extends ContractsDetailingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContractsDetailingUpsertArgs<ExtArgs>>
    ): Prisma__ContractsDetailingClient<$Result.GetResult<Prisma.$ContractsDetailingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ContractsDetailings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsDetailingCountArgs} args - Arguments to filter ContractsDetailings to count.
     * @example
     * // Count the number of ContractsDetailings
     * const count = await prisma.contractsDetailing.count({
     *   where: {
     *     // ... the filter for the ContractsDetailings we want to count
     *   }
     * })
    **/
    count<T extends ContractsDetailingCountArgs>(
      args?: Subset<T, ContractsDetailingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractsDetailingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractsDetailing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsDetailingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractsDetailingAggregateArgs>(args: Subset<T, ContractsDetailingAggregateArgs>): Prisma.PrismaPromise<GetContractsDetailingAggregateType<T>>

    /**
     * Group by ContractsDetailing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractsDetailingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractsDetailingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractsDetailingGroupByArgs['orderBy'] }
        : { orderBy?: ContractsDetailingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractsDetailingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractsDetailingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractsDetailing model
   */
  readonly fields: ContractsDetailingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractsDetailing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractsDetailingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends ContractsDetailing$UsersArgs<ExtArgs> = {}>(args?: Subset<T, ContractsDetailing$UsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Furniture<T extends ContractsDetailing$FurnitureArgs<ExtArgs> = {}>(args?: Subset<T, ContractsDetailing$FurnitureArgs<ExtArgs>>): Prisma__FurnitureClient<$Result.GetResult<Prisma.$FurniturePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Contracts<T extends ContractsDetailing$ContractsArgs<ExtArgs> = {}>(args?: Subset<T, ContractsDetailing$ContractsArgs<ExtArgs>>): Prisma__ContractsClient<$Result.GetResult<Prisma.$ContractsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ContractsDetailing model
   */ 
  interface ContractsDetailingFieldRefs {
    readonly id: FieldRef<"ContractsDetailing", 'Int'>
    readonly users_id: FieldRef<"ContractsDetailing", 'Int'>
    readonly furniture_id: FieldRef<"ContractsDetailing", 'Int'>
    readonly contracts_id: FieldRef<"ContractsDetailing", 'Int'>
    readonly count: FieldRef<"ContractsDetailing", 'Int'>
    readonly total_price: FieldRef<"ContractsDetailing", 'Decimal'>
    readonly contract_date: FieldRef<"ContractsDetailing", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContractsDetailing findUnique
   */
  export type ContractsDetailingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
    /**
     * Filter, which ContractsDetailing to fetch.
     */
    where: ContractsDetailingWhereUniqueInput
  }

  /**
   * ContractsDetailing findUniqueOrThrow
   */
  export type ContractsDetailingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
    /**
     * Filter, which ContractsDetailing to fetch.
     */
    where: ContractsDetailingWhereUniqueInput
  }

  /**
   * ContractsDetailing findFirst
   */
  export type ContractsDetailingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
    /**
     * Filter, which ContractsDetailing to fetch.
     */
    where?: ContractsDetailingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractsDetailings to fetch.
     */
    orderBy?: ContractsDetailingOrderByWithRelationInput | ContractsDetailingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractsDetailings.
     */
    cursor?: ContractsDetailingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractsDetailings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractsDetailings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractsDetailings.
     */
    distinct?: ContractsDetailingScalarFieldEnum | ContractsDetailingScalarFieldEnum[]
  }

  /**
   * ContractsDetailing findFirstOrThrow
   */
  export type ContractsDetailingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
    /**
     * Filter, which ContractsDetailing to fetch.
     */
    where?: ContractsDetailingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractsDetailings to fetch.
     */
    orderBy?: ContractsDetailingOrderByWithRelationInput | ContractsDetailingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractsDetailings.
     */
    cursor?: ContractsDetailingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractsDetailings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractsDetailings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractsDetailings.
     */
    distinct?: ContractsDetailingScalarFieldEnum | ContractsDetailingScalarFieldEnum[]
  }

  /**
   * ContractsDetailing findMany
   */
  export type ContractsDetailingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
    /**
     * Filter, which ContractsDetailings to fetch.
     */
    where?: ContractsDetailingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractsDetailings to fetch.
     */
    orderBy?: ContractsDetailingOrderByWithRelationInput | ContractsDetailingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractsDetailings.
     */
    cursor?: ContractsDetailingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractsDetailings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractsDetailings.
     */
    skip?: number
    distinct?: ContractsDetailingScalarFieldEnum | ContractsDetailingScalarFieldEnum[]
  }

  /**
   * ContractsDetailing create
   */
  export type ContractsDetailingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractsDetailing.
     */
    data: XOR<ContractsDetailingCreateInput, ContractsDetailingUncheckedCreateInput>
  }

  /**
   * ContractsDetailing createMany
   */
  export type ContractsDetailingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractsDetailings.
     */
    data: ContractsDetailingCreateManyInput | ContractsDetailingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractsDetailing update
   */
  export type ContractsDetailingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractsDetailing.
     */
    data: XOR<ContractsDetailingUpdateInput, ContractsDetailingUncheckedUpdateInput>
    /**
     * Choose, which ContractsDetailing to update.
     */
    where: ContractsDetailingWhereUniqueInput
  }

  /**
   * ContractsDetailing updateMany
   */
  export type ContractsDetailingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractsDetailings.
     */
    data: XOR<ContractsDetailingUpdateManyMutationInput, ContractsDetailingUncheckedUpdateManyInput>
    /**
     * Filter which ContractsDetailings to update
     */
    where?: ContractsDetailingWhereInput
  }

  /**
   * ContractsDetailing upsert
   */
  export type ContractsDetailingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractsDetailing to update in case it exists.
     */
    where: ContractsDetailingWhereUniqueInput
    /**
     * In case the ContractsDetailing found by the `where` argument doesn't exist, create a new ContractsDetailing with this data.
     */
    create: XOR<ContractsDetailingCreateInput, ContractsDetailingUncheckedCreateInput>
    /**
     * In case the ContractsDetailing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractsDetailingUpdateInput, ContractsDetailingUncheckedUpdateInput>
  }

  /**
   * ContractsDetailing delete
   */
  export type ContractsDetailingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
    /**
     * Filter which ContractsDetailing to delete.
     */
    where: ContractsDetailingWhereUniqueInput
  }

  /**
   * ContractsDetailing deleteMany
   */
  export type ContractsDetailingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractsDetailings to delete
     */
    where?: ContractsDetailingWhereInput
  }

  /**
   * ContractsDetailing.Users
   */
  export type ContractsDetailing$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * ContractsDetailing.Furniture
   */
  export type ContractsDetailing$FurnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Furniture
     */
    select?: FurnitureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FurnitureInclude<ExtArgs> | null
    where?: FurnitureWhereInput
  }

  /**
   * ContractsDetailing.Contracts
   */
  export type ContractsDetailing$ContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contracts
     */
    select?: ContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsInclude<ExtArgs> | null
    where?: ContractsWhereInput
  }

  /**
   * ContractsDetailing without action
   */
  export type ContractsDetailingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractsDetailing
     */
    select?: ContractsDetailingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractsDetailingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ColorsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ColorsScalarFieldEnum = (typeof ColorsScalarFieldEnum)[keyof typeof ColorsScalarFieldEnum]


  export const MaterialsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type MaterialsScalarFieldEnum = (typeof MaterialsScalarFieldEnum)[keyof typeof MaterialsScalarFieldEnum]


  export const RoomTypesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoomTypesScalarFieldEnum = (typeof RoomTypesScalarFieldEnum)[keyof typeof RoomTypesScalarFieldEnum]


  export const FurnitureTypesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type FurnitureTypesScalarFieldEnum = (typeof FurnitureTypesScalarFieldEnum)[keyof typeof FurnitureTypesScalarFieldEnum]


  export const FurniturePhotosScalarFieldEnum: {
    id: 'id',
    furniture_id: 'furniture_id',
    url: 'url',
    caption: 'caption'
  };

  export type FurniturePhotosScalarFieldEnum = (typeof FurniturePhotosScalarFieldEnum)[keyof typeof FurniturePhotosScalarFieldEnum]


  export const FurnitureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    produced_date: 'produced_date',
    colors_id: 'colors_id',
    materials_id: 'materials_id',
    roomTypes_id: 'roomTypes_id',
    furniture_types_id: 'furniture_types_id',
    description: 'description',
    height: 'height',
    width: 'width',
    price: 'price'
  };

  export type FurnitureScalarFieldEnum = (typeof FurnitureScalarFieldEnum)[keyof typeof FurnitureScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    birth_date: 'birth_date',
    phone_number: 'phone_number',
    email: 'email',
    hashed_password: 'hashed_password',
    hashed_refresh_token: 'hashed_refresh_token',
    activation_link: 'activation_link',
    is_active: 'is_active'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const FurnitureCommentsScalarFieldEnum: {
    id: 'id',
    users_id: 'users_id',
    furniture_id: 'furniture_id',
    user_comment: 'user_comment'
  };

  export type FurnitureCommentsScalarFieldEnum = (typeof FurnitureCommentsScalarFieldEnum)[keyof typeof FurnitureCommentsScalarFieldEnum]


  export const FurnitureLikesScalarFieldEnum: {
    id: 'id',
    users_id: 'users_id',
    furniture_id: 'furniture_id'
  };

  export type FurnitureLikesScalarFieldEnum = (typeof FurnitureLikesScalarFieldEnum)[keyof typeof FurnitureLikesScalarFieldEnum]


  export const AdminsScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    birth_date: 'birth_date',
    phone_number: 'phone_number',
    email: 'email',
    hashed_password: 'hashed_password',
    hashed_refresh_token: 'hashed_refresh_token',
    is_creator: 'is_creator'
  };

  export type AdminsScalarFieldEnum = (typeof AdminsScalarFieldEnum)[keyof typeof AdminsScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    value: 'value',
    description: 'description'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const AdminRolesScalarFieldEnum: {
    id: 'id',
    admins_id: 'admins_id',
    roles_id: 'roles_id'
  };

  export type AdminRolesScalarFieldEnum = (typeof AdminRolesScalarFieldEnum)[keyof typeof AdminRolesScalarFieldEnum]


  export const UserCardScalarFieldEnum: {
    id: 'id',
    users_id: 'users_id',
    card_number: 'card_number',
    card_expiration: 'card_expiration',
    phone_number: 'phone_number'
  };

  export type UserCardScalarFieldEnum = (typeof UserCardScalarFieldEnum)[keyof typeof UserCardScalarFieldEnum]


  export const UserAddressScalarFieldEnum: {
    id: 'id',
    users_id: 'users_id',
    city: 'city',
    area: 'area',
    street: 'street',
    house: 'house',
    apartment_or_office: 'apartment_or_office',
    entrance: 'entrance',
    floor: 'floor',
    intercom_code: 'intercom_code'
  };

  export type UserAddressScalarFieldEnum = (typeof UserAddressScalarFieldEnum)[keyof typeof UserAddressScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    phone_number_1: 'phone_number_1',
    phone_number_2: 'phone_number_2',
    email: 'email',
    hashed_password: 'hashed_password',
    hashed_refresh_token: 'hashed_refresh_token',
    car_name: 'car_name',
    car_number: 'car_number',
    car_size: 'car_size'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    users_id: 'users_id',
    contracts_id: 'contracts_id',
    user_card_id: 'user_card_id',
    company_card: 'company_card',
    payment_amount: 'payment_amount',
    payment_status: 'payment_status',
    payment_date: 'payment_date'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ContractsScalarFieldEnum: {
    id: 'id',
    users_id: 'users_id',
    supplier_id: 'supplier_id',
    delivery_date: 'delivery_date',
    note_to_supplier: 'note_to_supplier',
    hours: 'hours',
    delivery_status: 'delivery_status'
  };

  export type ContractsScalarFieldEnum = (typeof ContractsScalarFieldEnum)[keyof typeof ContractsScalarFieldEnum]


  export const ContractsDetailingScalarFieldEnum: {
    id: 'id',
    users_id: 'users_id',
    furniture_id: 'furniture_id',
    contracts_id: 'contracts_id',
    count: 'count',
    total_price: 'total_price',
    contract_date: 'contract_date'
  };

  export type ContractsDetailingScalarFieldEnum = (typeof ContractsDetailingScalarFieldEnum)[keyof typeof ContractsDetailingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ColorsWhereInput = {
    AND?: ColorsWhereInput | ColorsWhereInput[]
    OR?: ColorsWhereInput[]
    NOT?: ColorsWhereInput | ColorsWhereInput[]
    id?: IntFilter<"Colors"> | number
    name?: StringFilter<"Colors"> | string
    furniture?: FurnitureListRelationFilter
  }

  export type ColorsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    furniture?: FurnitureOrderByRelationAggregateInput
  }

  export type ColorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ColorsWhereInput | ColorsWhereInput[]
    OR?: ColorsWhereInput[]
    NOT?: ColorsWhereInput | ColorsWhereInput[]
    furniture?: FurnitureListRelationFilter
  }, "id" | "name">

  export type ColorsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ColorsCountOrderByAggregateInput
    _avg?: ColorsAvgOrderByAggregateInput
    _max?: ColorsMaxOrderByAggregateInput
    _min?: ColorsMinOrderByAggregateInput
    _sum?: ColorsSumOrderByAggregateInput
  }

  export type ColorsScalarWhereWithAggregatesInput = {
    AND?: ColorsScalarWhereWithAggregatesInput | ColorsScalarWhereWithAggregatesInput[]
    OR?: ColorsScalarWhereWithAggregatesInput[]
    NOT?: ColorsScalarWhereWithAggregatesInput | ColorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Colors"> | number
    name?: StringWithAggregatesFilter<"Colors"> | string
  }

  export type MaterialsWhereInput = {
    AND?: MaterialsWhereInput | MaterialsWhereInput[]
    OR?: MaterialsWhereInput[]
    NOT?: MaterialsWhereInput | MaterialsWhereInput[]
    id?: IntFilter<"Materials"> | number
    name?: StringFilter<"Materials"> | string
    furniture?: FurnitureListRelationFilter
  }

  export type MaterialsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    furniture?: FurnitureOrderByRelationAggregateInput
  }

  export type MaterialsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: MaterialsWhereInput | MaterialsWhereInput[]
    OR?: MaterialsWhereInput[]
    NOT?: MaterialsWhereInput | MaterialsWhereInput[]
    furniture?: FurnitureListRelationFilter
  }, "id" | "name">

  export type MaterialsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: MaterialsCountOrderByAggregateInput
    _avg?: MaterialsAvgOrderByAggregateInput
    _max?: MaterialsMaxOrderByAggregateInput
    _min?: MaterialsMinOrderByAggregateInput
    _sum?: MaterialsSumOrderByAggregateInput
  }

  export type MaterialsScalarWhereWithAggregatesInput = {
    AND?: MaterialsScalarWhereWithAggregatesInput | MaterialsScalarWhereWithAggregatesInput[]
    OR?: MaterialsScalarWhereWithAggregatesInput[]
    NOT?: MaterialsScalarWhereWithAggregatesInput | MaterialsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Materials"> | number
    name?: StringWithAggregatesFilter<"Materials"> | string
  }

  export type RoomTypesWhereInput = {
    AND?: RoomTypesWhereInput | RoomTypesWhereInput[]
    OR?: RoomTypesWhereInput[]
    NOT?: RoomTypesWhereInput | RoomTypesWhereInput[]
    id?: IntFilter<"RoomTypes"> | number
    name?: StringFilter<"RoomTypes"> | string
    furniture?: FurnitureListRelationFilter
  }

  export type RoomTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    furniture?: FurnitureOrderByRelationAggregateInput
  }

  export type RoomTypesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoomTypesWhereInput | RoomTypesWhereInput[]
    OR?: RoomTypesWhereInput[]
    NOT?: RoomTypesWhereInput | RoomTypesWhereInput[]
    furniture?: FurnitureListRelationFilter
  }, "id" | "name">

  export type RoomTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoomTypesCountOrderByAggregateInput
    _avg?: RoomTypesAvgOrderByAggregateInput
    _max?: RoomTypesMaxOrderByAggregateInput
    _min?: RoomTypesMinOrderByAggregateInput
    _sum?: RoomTypesSumOrderByAggregateInput
  }

  export type RoomTypesScalarWhereWithAggregatesInput = {
    AND?: RoomTypesScalarWhereWithAggregatesInput | RoomTypesScalarWhereWithAggregatesInput[]
    OR?: RoomTypesScalarWhereWithAggregatesInput[]
    NOT?: RoomTypesScalarWhereWithAggregatesInput | RoomTypesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoomTypes"> | number
    name?: StringWithAggregatesFilter<"RoomTypes"> | string
  }

  export type FurnitureTypesWhereInput = {
    AND?: FurnitureTypesWhereInput | FurnitureTypesWhereInput[]
    OR?: FurnitureTypesWhereInput[]
    NOT?: FurnitureTypesWhereInput | FurnitureTypesWhereInput[]
    id?: IntFilter<"FurnitureTypes"> | number
    name?: StringFilter<"FurnitureTypes"> | string
    furniture?: FurnitureListRelationFilter
  }

  export type FurnitureTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    furniture?: FurnitureOrderByRelationAggregateInput
  }

  export type FurnitureTypesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: FurnitureTypesWhereInput | FurnitureTypesWhereInput[]
    OR?: FurnitureTypesWhereInput[]
    NOT?: FurnitureTypesWhereInput | FurnitureTypesWhereInput[]
    furniture?: FurnitureListRelationFilter
  }, "id" | "name">

  export type FurnitureTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: FurnitureTypesCountOrderByAggregateInput
    _avg?: FurnitureTypesAvgOrderByAggregateInput
    _max?: FurnitureTypesMaxOrderByAggregateInput
    _min?: FurnitureTypesMinOrderByAggregateInput
    _sum?: FurnitureTypesSumOrderByAggregateInput
  }

  export type FurnitureTypesScalarWhereWithAggregatesInput = {
    AND?: FurnitureTypesScalarWhereWithAggregatesInput | FurnitureTypesScalarWhereWithAggregatesInput[]
    OR?: FurnitureTypesScalarWhereWithAggregatesInput[]
    NOT?: FurnitureTypesScalarWhereWithAggregatesInput | FurnitureTypesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FurnitureTypes"> | number
    name?: StringWithAggregatesFilter<"FurnitureTypes"> | string
  }

  export type FurniturePhotosWhereInput = {
    AND?: FurniturePhotosWhereInput | FurniturePhotosWhereInput[]
    OR?: FurniturePhotosWhereInput[]
    NOT?: FurniturePhotosWhereInput | FurniturePhotosWhereInput[]
    id?: IntFilter<"FurniturePhotos"> | number
    furniture_id?: IntNullableFilter<"FurniturePhotos"> | number | null
    url?: StringFilter<"FurniturePhotos"> | string
    caption?: StringFilter<"FurniturePhotos"> | string
    Furniture?: XOR<FurnitureNullableRelationFilter, FurnitureWhereInput> | null
  }

  export type FurniturePhotosOrderByWithRelationInput = {
    id?: SortOrder
    furniture_id?: SortOrderInput | SortOrder
    url?: SortOrder
    caption?: SortOrder
    Furniture?: FurnitureOrderByWithRelationInput
  }

  export type FurniturePhotosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FurniturePhotosWhereInput | FurniturePhotosWhereInput[]
    OR?: FurniturePhotosWhereInput[]
    NOT?: FurniturePhotosWhereInput | FurniturePhotosWhereInput[]
    furniture_id?: IntNullableFilter<"FurniturePhotos"> | number | null
    url?: StringFilter<"FurniturePhotos"> | string
    caption?: StringFilter<"FurniturePhotos"> | string
    Furniture?: XOR<FurnitureNullableRelationFilter, FurnitureWhereInput> | null
  }, "id">

  export type FurniturePhotosOrderByWithAggregationInput = {
    id?: SortOrder
    furniture_id?: SortOrderInput | SortOrder
    url?: SortOrder
    caption?: SortOrder
    _count?: FurniturePhotosCountOrderByAggregateInput
    _avg?: FurniturePhotosAvgOrderByAggregateInput
    _max?: FurniturePhotosMaxOrderByAggregateInput
    _min?: FurniturePhotosMinOrderByAggregateInput
    _sum?: FurniturePhotosSumOrderByAggregateInput
  }

  export type FurniturePhotosScalarWhereWithAggregatesInput = {
    AND?: FurniturePhotosScalarWhereWithAggregatesInput | FurniturePhotosScalarWhereWithAggregatesInput[]
    OR?: FurniturePhotosScalarWhereWithAggregatesInput[]
    NOT?: FurniturePhotosScalarWhereWithAggregatesInput | FurniturePhotosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FurniturePhotos"> | number
    furniture_id?: IntNullableWithAggregatesFilter<"FurniturePhotos"> | number | null
    url?: StringWithAggregatesFilter<"FurniturePhotos"> | string
    caption?: StringWithAggregatesFilter<"FurniturePhotos"> | string
  }

  export type FurnitureWhereInput = {
    AND?: FurnitureWhereInput | FurnitureWhereInput[]
    OR?: FurnitureWhereInput[]
    NOT?: FurnitureWhereInput | FurnitureWhereInput[]
    id?: IntFilter<"Furniture"> | number
    name?: StringFilter<"Furniture"> | string
    produced_date?: StringFilter<"Furniture"> | string
    colors_id?: IntNullableFilter<"Furniture"> | number | null
    materials_id?: IntNullableFilter<"Furniture"> | number | null
    roomTypes_id?: IntNullableFilter<"Furniture"> | number | null
    furniture_types_id?: IntNullableFilter<"Furniture"> | number | null
    description?: StringFilter<"Furniture"> | string
    height?: DecimalFilter<"Furniture"> | Decimal | DecimalJsLike | number | string
    width?: DecimalFilter<"Furniture"> | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter<"Furniture"> | Decimal | DecimalJsLike | number | string
    Colors?: XOR<ColorsNullableRelationFilter, ColorsWhereInput> | null
    Materials?: XOR<MaterialsNullableRelationFilter, MaterialsWhereInput> | null
    RoomTypes?: XOR<RoomTypesNullableRelationFilter, RoomTypesWhereInput> | null
    FurnitureTypes?: XOR<FurnitureTypesNullableRelationFilter, FurnitureTypesWhereInput> | null
    furniture_photos?: FurniturePhotosListRelationFilter
    furniture_comments?: FurnitureCommentsListRelationFilter
    furniture_likes?: FurnitureLikesListRelationFilter
    contracts_detailing?: ContractsDetailingListRelationFilter
  }

  export type FurnitureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    produced_date?: SortOrder
    colors_id?: SortOrderInput | SortOrder
    materials_id?: SortOrderInput | SortOrder
    roomTypes_id?: SortOrderInput | SortOrder
    furniture_types_id?: SortOrderInput | SortOrder
    description?: SortOrder
    height?: SortOrder
    width?: SortOrder
    price?: SortOrder
    Colors?: ColorsOrderByWithRelationInput
    Materials?: MaterialsOrderByWithRelationInput
    RoomTypes?: RoomTypesOrderByWithRelationInput
    FurnitureTypes?: FurnitureTypesOrderByWithRelationInput
    furniture_photos?: FurniturePhotosOrderByRelationAggregateInput
    furniture_comments?: FurnitureCommentsOrderByRelationAggregateInput
    furniture_likes?: FurnitureLikesOrderByRelationAggregateInput
    contracts_detailing?: ContractsDetailingOrderByRelationAggregateInput
  }

  export type FurnitureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FurnitureWhereInput | FurnitureWhereInput[]
    OR?: FurnitureWhereInput[]
    NOT?: FurnitureWhereInput | FurnitureWhereInput[]
    name?: StringFilter<"Furniture"> | string
    produced_date?: StringFilter<"Furniture"> | string
    colors_id?: IntNullableFilter<"Furniture"> | number | null
    materials_id?: IntNullableFilter<"Furniture"> | number | null
    roomTypes_id?: IntNullableFilter<"Furniture"> | number | null
    furniture_types_id?: IntNullableFilter<"Furniture"> | number | null
    description?: StringFilter<"Furniture"> | string
    height?: DecimalFilter<"Furniture"> | Decimal | DecimalJsLike | number | string
    width?: DecimalFilter<"Furniture"> | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter<"Furniture"> | Decimal | DecimalJsLike | number | string
    Colors?: XOR<ColorsNullableRelationFilter, ColorsWhereInput> | null
    Materials?: XOR<MaterialsNullableRelationFilter, MaterialsWhereInput> | null
    RoomTypes?: XOR<RoomTypesNullableRelationFilter, RoomTypesWhereInput> | null
    FurnitureTypes?: XOR<FurnitureTypesNullableRelationFilter, FurnitureTypesWhereInput> | null
    furniture_photos?: FurniturePhotosListRelationFilter
    furniture_comments?: FurnitureCommentsListRelationFilter
    furniture_likes?: FurnitureLikesListRelationFilter
    contracts_detailing?: ContractsDetailingListRelationFilter
  }, "id">

  export type FurnitureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    produced_date?: SortOrder
    colors_id?: SortOrderInput | SortOrder
    materials_id?: SortOrderInput | SortOrder
    roomTypes_id?: SortOrderInput | SortOrder
    furniture_types_id?: SortOrderInput | SortOrder
    description?: SortOrder
    height?: SortOrder
    width?: SortOrder
    price?: SortOrder
    _count?: FurnitureCountOrderByAggregateInput
    _avg?: FurnitureAvgOrderByAggregateInput
    _max?: FurnitureMaxOrderByAggregateInput
    _min?: FurnitureMinOrderByAggregateInput
    _sum?: FurnitureSumOrderByAggregateInput
  }

  export type FurnitureScalarWhereWithAggregatesInput = {
    AND?: FurnitureScalarWhereWithAggregatesInput | FurnitureScalarWhereWithAggregatesInput[]
    OR?: FurnitureScalarWhereWithAggregatesInput[]
    NOT?: FurnitureScalarWhereWithAggregatesInput | FurnitureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Furniture"> | number
    name?: StringWithAggregatesFilter<"Furniture"> | string
    produced_date?: StringWithAggregatesFilter<"Furniture"> | string
    colors_id?: IntNullableWithAggregatesFilter<"Furniture"> | number | null
    materials_id?: IntNullableWithAggregatesFilter<"Furniture"> | number | null
    roomTypes_id?: IntNullableWithAggregatesFilter<"Furniture"> | number | null
    furniture_types_id?: IntNullableWithAggregatesFilter<"Furniture"> | number | null
    description?: StringWithAggregatesFilter<"Furniture"> | string
    height?: DecimalWithAggregatesFilter<"Furniture"> | Decimal | DecimalJsLike | number | string
    width?: DecimalWithAggregatesFilter<"Furniture"> | Decimal | DecimalJsLike | number | string
    price?: DecimalWithAggregatesFilter<"Furniture"> | Decimal | DecimalJsLike | number | string
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: IntFilter<"Users"> | number
    full_name?: StringFilter<"Users"> | string
    birth_date?: StringNullableFilter<"Users"> | string | null
    phone_number?: StringNullableFilter<"Users"> | string | null
    email?: StringFilter<"Users"> | string
    hashed_password?: StringFilter<"Users"> | string
    hashed_refresh_token?: StringNullableFilter<"Users"> | string | null
    activation_link?: StringFilter<"Users"> | string
    is_active?: BoolFilter<"Users"> | boolean
    furniture_comments?: FurnitureCommentsListRelationFilter
    furniture_likes?: FurnitureLikesListRelationFilter
    user_card?: UserCardListRelationFilter
    user_address?: UserAddressListRelationFilter
    payment?: PaymentListRelationFilter
    contracts?: ContractsListRelationFilter
    contracts_detailing?: ContractsDetailingListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    birth_date?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrderInput | SortOrder
    activation_link?: SortOrder
    is_active?: SortOrder
    furniture_comments?: FurnitureCommentsOrderByRelationAggregateInput
    furniture_likes?: FurnitureLikesOrderByRelationAggregateInput
    user_card?: UserCardOrderByRelationAggregateInput
    user_address?: UserAddressOrderByRelationAggregateInput
    payment?: PaymentOrderByRelationAggregateInput
    contracts?: ContractsOrderByRelationAggregateInput
    contracts_detailing?: ContractsDetailingOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    full_name?: StringFilter<"Users"> | string
    birth_date?: StringNullableFilter<"Users"> | string | null
    phone_number?: StringNullableFilter<"Users"> | string | null
    hashed_password?: StringFilter<"Users"> | string
    hashed_refresh_token?: StringNullableFilter<"Users"> | string | null
    activation_link?: StringFilter<"Users"> | string
    is_active?: BoolFilter<"Users"> | boolean
    furniture_comments?: FurnitureCommentsListRelationFilter
    furniture_likes?: FurnitureLikesListRelationFilter
    user_card?: UserCardListRelationFilter
    user_address?: UserAddressListRelationFilter
    payment?: PaymentListRelationFilter
    contracts?: ContractsListRelationFilter
    contracts_detailing?: ContractsDetailingListRelationFilter
  }, "id" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    birth_date?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrderInput | SortOrder
    activation_link?: SortOrder
    is_active?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Users"> | number
    full_name?: StringWithAggregatesFilter<"Users"> | string
    birth_date?: StringNullableWithAggregatesFilter<"Users"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"Users"> | string | null
    email?: StringWithAggregatesFilter<"Users"> | string
    hashed_password?: StringWithAggregatesFilter<"Users"> | string
    hashed_refresh_token?: StringNullableWithAggregatesFilter<"Users"> | string | null
    activation_link?: StringWithAggregatesFilter<"Users"> | string
    is_active?: BoolWithAggregatesFilter<"Users"> | boolean
  }

  export type FurnitureCommentsWhereInput = {
    AND?: FurnitureCommentsWhereInput | FurnitureCommentsWhereInput[]
    OR?: FurnitureCommentsWhereInput[]
    NOT?: FurnitureCommentsWhereInput | FurnitureCommentsWhereInput[]
    id?: IntFilter<"FurnitureComments"> | number
    users_id?: IntNullableFilter<"FurnitureComments"> | number | null
    furniture_id?: IntNullableFilter<"FurnitureComments"> | number | null
    user_comment?: StringFilter<"FurnitureComments"> | string
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    Furniture?: XOR<FurnitureNullableRelationFilter, FurnitureWhereInput> | null
  }

  export type FurnitureCommentsOrderByWithRelationInput = {
    id?: SortOrder
    users_id?: SortOrderInput | SortOrder
    furniture_id?: SortOrderInput | SortOrder
    user_comment?: SortOrder
    Users?: UsersOrderByWithRelationInput
    Furniture?: FurnitureOrderByWithRelationInput
  }

  export type FurnitureCommentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FurnitureCommentsWhereInput | FurnitureCommentsWhereInput[]
    OR?: FurnitureCommentsWhereInput[]
    NOT?: FurnitureCommentsWhereInput | FurnitureCommentsWhereInput[]
    users_id?: IntNullableFilter<"FurnitureComments"> | number | null
    furniture_id?: IntNullableFilter<"FurnitureComments"> | number | null
    user_comment?: StringFilter<"FurnitureComments"> | string
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    Furniture?: XOR<FurnitureNullableRelationFilter, FurnitureWhereInput> | null
  }, "id">

  export type FurnitureCommentsOrderByWithAggregationInput = {
    id?: SortOrder
    users_id?: SortOrderInput | SortOrder
    furniture_id?: SortOrderInput | SortOrder
    user_comment?: SortOrder
    _count?: FurnitureCommentsCountOrderByAggregateInput
    _avg?: FurnitureCommentsAvgOrderByAggregateInput
    _max?: FurnitureCommentsMaxOrderByAggregateInput
    _min?: FurnitureCommentsMinOrderByAggregateInput
    _sum?: FurnitureCommentsSumOrderByAggregateInput
  }

  export type FurnitureCommentsScalarWhereWithAggregatesInput = {
    AND?: FurnitureCommentsScalarWhereWithAggregatesInput | FurnitureCommentsScalarWhereWithAggregatesInput[]
    OR?: FurnitureCommentsScalarWhereWithAggregatesInput[]
    NOT?: FurnitureCommentsScalarWhereWithAggregatesInput | FurnitureCommentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FurnitureComments"> | number
    users_id?: IntNullableWithAggregatesFilter<"FurnitureComments"> | number | null
    furniture_id?: IntNullableWithAggregatesFilter<"FurnitureComments"> | number | null
    user_comment?: StringWithAggregatesFilter<"FurnitureComments"> | string
  }

  export type FurnitureLikesWhereInput = {
    AND?: FurnitureLikesWhereInput | FurnitureLikesWhereInput[]
    OR?: FurnitureLikesWhereInput[]
    NOT?: FurnitureLikesWhereInput | FurnitureLikesWhereInput[]
    id?: IntFilter<"FurnitureLikes"> | number
    users_id?: IntNullableFilter<"FurnitureLikes"> | number | null
    furniture_id?: IntNullableFilter<"FurnitureLikes"> | number | null
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    Furniture?: XOR<FurnitureNullableRelationFilter, FurnitureWhereInput> | null
  }

  export type FurnitureLikesOrderByWithRelationInput = {
    id?: SortOrder
    users_id?: SortOrderInput | SortOrder
    furniture_id?: SortOrderInput | SortOrder
    Users?: UsersOrderByWithRelationInput
    Furniture?: FurnitureOrderByWithRelationInput
  }

  export type FurnitureLikesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FurnitureLikesWhereInput | FurnitureLikesWhereInput[]
    OR?: FurnitureLikesWhereInput[]
    NOT?: FurnitureLikesWhereInput | FurnitureLikesWhereInput[]
    users_id?: IntNullableFilter<"FurnitureLikes"> | number | null
    furniture_id?: IntNullableFilter<"FurnitureLikes"> | number | null
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    Furniture?: XOR<FurnitureNullableRelationFilter, FurnitureWhereInput> | null
  }, "id">

  export type FurnitureLikesOrderByWithAggregationInput = {
    id?: SortOrder
    users_id?: SortOrderInput | SortOrder
    furniture_id?: SortOrderInput | SortOrder
    _count?: FurnitureLikesCountOrderByAggregateInput
    _avg?: FurnitureLikesAvgOrderByAggregateInput
    _max?: FurnitureLikesMaxOrderByAggregateInput
    _min?: FurnitureLikesMinOrderByAggregateInput
    _sum?: FurnitureLikesSumOrderByAggregateInput
  }

  export type FurnitureLikesScalarWhereWithAggregatesInput = {
    AND?: FurnitureLikesScalarWhereWithAggregatesInput | FurnitureLikesScalarWhereWithAggregatesInput[]
    OR?: FurnitureLikesScalarWhereWithAggregatesInput[]
    NOT?: FurnitureLikesScalarWhereWithAggregatesInput | FurnitureLikesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FurnitureLikes"> | number
    users_id?: IntNullableWithAggregatesFilter<"FurnitureLikes"> | number | null
    furniture_id?: IntNullableWithAggregatesFilter<"FurnitureLikes"> | number | null
  }

  export type AdminsWhereInput = {
    AND?: AdminsWhereInput | AdminsWhereInput[]
    OR?: AdminsWhereInput[]
    NOT?: AdminsWhereInput | AdminsWhereInput[]
    id?: IntFilter<"Admins"> | number
    full_name?: StringFilter<"Admins"> | string
    birth_date?: StringNullableFilter<"Admins"> | string | null
    phone_number?: StringFilter<"Admins"> | string
    email?: StringFilter<"Admins"> | string
    hashed_password?: StringNullableFilter<"Admins"> | string | null
    hashed_refresh_token?: StringNullableFilter<"Admins"> | string | null
    is_creator?: BoolFilter<"Admins"> | boolean
    admin_roles?: AdminRolesListRelationFilter
  }

  export type AdminsOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    birth_date?: SortOrderInput | SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrderInput | SortOrder
    hashed_refresh_token?: SortOrderInput | SortOrder
    is_creator?: SortOrder
    admin_roles?: AdminRolesOrderByRelationAggregateInput
  }

  export type AdminsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    phone_number?: string
    email?: string
    AND?: AdminsWhereInput | AdminsWhereInput[]
    OR?: AdminsWhereInput[]
    NOT?: AdminsWhereInput | AdminsWhereInput[]
    full_name?: StringFilter<"Admins"> | string
    birth_date?: StringNullableFilter<"Admins"> | string | null
    hashed_password?: StringNullableFilter<"Admins"> | string | null
    hashed_refresh_token?: StringNullableFilter<"Admins"> | string | null
    is_creator?: BoolFilter<"Admins"> | boolean
    admin_roles?: AdminRolesListRelationFilter
  }, "id" | "phone_number" | "email">

  export type AdminsOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    birth_date?: SortOrderInput | SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrderInput | SortOrder
    hashed_refresh_token?: SortOrderInput | SortOrder
    is_creator?: SortOrder
    _count?: AdminsCountOrderByAggregateInput
    _avg?: AdminsAvgOrderByAggregateInput
    _max?: AdminsMaxOrderByAggregateInput
    _min?: AdminsMinOrderByAggregateInput
    _sum?: AdminsSumOrderByAggregateInput
  }

  export type AdminsScalarWhereWithAggregatesInput = {
    AND?: AdminsScalarWhereWithAggregatesInput | AdminsScalarWhereWithAggregatesInput[]
    OR?: AdminsScalarWhereWithAggregatesInput[]
    NOT?: AdminsScalarWhereWithAggregatesInput | AdminsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admins"> | number
    full_name?: StringWithAggregatesFilter<"Admins"> | string
    birth_date?: StringNullableWithAggregatesFilter<"Admins"> | string | null
    phone_number?: StringWithAggregatesFilter<"Admins"> | string
    email?: StringWithAggregatesFilter<"Admins"> | string
    hashed_password?: StringNullableWithAggregatesFilter<"Admins"> | string | null
    hashed_refresh_token?: StringNullableWithAggregatesFilter<"Admins"> | string | null
    is_creator?: BoolWithAggregatesFilter<"Admins"> | boolean
  }

  export type RolesWhereInput = {
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    id?: IntFilter<"Roles"> | number
    value?: StringFilter<"Roles"> | string
    description?: StringFilter<"Roles"> | string
    admin_roles?: AdminRolesListRelationFilter
  }

  export type RolesOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    admin_roles?: AdminRolesOrderByRelationAggregateInput
  }

  export type RolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    description?: StringFilter<"Roles"> | string
    admin_roles?: AdminRolesListRelationFilter
  }, "id" | "value">

  export type RolesOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    OR?: RolesScalarWhereWithAggregatesInput[]
    NOT?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Roles"> | number
    value?: StringWithAggregatesFilter<"Roles"> | string
    description?: StringWithAggregatesFilter<"Roles"> | string
  }

  export type AdminRolesWhereInput = {
    AND?: AdminRolesWhereInput | AdminRolesWhereInput[]
    OR?: AdminRolesWhereInput[]
    NOT?: AdminRolesWhereInput | AdminRolesWhereInput[]
    id?: IntFilter<"AdminRoles"> | number
    admins_id?: IntNullableFilter<"AdminRoles"> | number | null
    roles_id?: IntNullableFilter<"AdminRoles"> | number | null
    Admins?: XOR<AdminsNullableRelationFilter, AdminsWhereInput> | null
    Roles?: XOR<RolesNullableRelationFilter, RolesWhereInput> | null
  }

  export type AdminRolesOrderByWithRelationInput = {
    id?: SortOrder
    admins_id?: SortOrderInput | SortOrder
    roles_id?: SortOrderInput | SortOrder
    Admins?: AdminsOrderByWithRelationInput
    Roles?: RolesOrderByWithRelationInput
  }

  export type AdminRolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdminRolesWhereInput | AdminRolesWhereInput[]
    OR?: AdminRolesWhereInput[]
    NOT?: AdminRolesWhereInput | AdminRolesWhereInput[]
    admins_id?: IntNullableFilter<"AdminRoles"> | number | null
    roles_id?: IntNullableFilter<"AdminRoles"> | number | null
    Admins?: XOR<AdminsNullableRelationFilter, AdminsWhereInput> | null
    Roles?: XOR<RolesNullableRelationFilter, RolesWhereInput> | null
  }, "id">

  export type AdminRolesOrderByWithAggregationInput = {
    id?: SortOrder
    admins_id?: SortOrderInput | SortOrder
    roles_id?: SortOrderInput | SortOrder
    _count?: AdminRolesCountOrderByAggregateInput
    _avg?: AdminRolesAvgOrderByAggregateInput
    _max?: AdminRolesMaxOrderByAggregateInput
    _min?: AdminRolesMinOrderByAggregateInput
    _sum?: AdminRolesSumOrderByAggregateInput
  }

  export type AdminRolesScalarWhereWithAggregatesInput = {
    AND?: AdminRolesScalarWhereWithAggregatesInput | AdminRolesScalarWhereWithAggregatesInput[]
    OR?: AdminRolesScalarWhereWithAggregatesInput[]
    NOT?: AdminRolesScalarWhereWithAggregatesInput | AdminRolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdminRoles"> | number
    admins_id?: IntNullableWithAggregatesFilter<"AdminRoles"> | number | null
    roles_id?: IntNullableWithAggregatesFilter<"AdminRoles"> | number | null
  }

  export type UserCardWhereInput = {
    AND?: UserCardWhereInput | UserCardWhereInput[]
    OR?: UserCardWhereInput[]
    NOT?: UserCardWhereInput | UserCardWhereInput[]
    id?: IntFilter<"UserCard"> | number
    users_id?: IntNullableFilter<"UserCard"> | number | null
    card_number?: StringFilter<"UserCard"> | string
    card_expiration?: StringFilter<"UserCard"> | string
    phone_number?: StringFilter<"UserCard"> | string
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    payment?: PaymentListRelationFilter
  }

  export type UserCardOrderByWithRelationInput = {
    id?: SortOrder
    users_id?: SortOrderInput | SortOrder
    card_number?: SortOrder
    card_expiration?: SortOrder
    phone_number?: SortOrder
    Users?: UsersOrderByWithRelationInput
    payment?: PaymentOrderByRelationAggregateInput
  }

  export type UserCardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserCardWhereInput | UserCardWhereInput[]
    OR?: UserCardWhereInput[]
    NOT?: UserCardWhereInput | UserCardWhereInput[]
    users_id?: IntNullableFilter<"UserCard"> | number | null
    card_number?: StringFilter<"UserCard"> | string
    card_expiration?: StringFilter<"UserCard"> | string
    phone_number?: StringFilter<"UserCard"> | string
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    payment?: PaymentListRelationFilter
  }, "id">

  export type UserCardOrderByWithAggregationInput = {
    id?: SortOrder
    users_id?: SortOrderInput | SortOrder
    card_number?: SortOrder
    card_expiration?: SortOrder
    phone_number?: SortOrder
    _count?: UserCardCountOrderByAggregateInput
    _avg?: UserCardAvgOrderByAggregateInput
    _max?: UserCardMaxOrderByAggregateInput
    _min?: UserCardMinOrderByAggregateInput
    _sum?: UserCardSumOrderByAggregateInput
  }

  export type UserCardScalarWhereWithAggregatesInput = {
    AND?: UserCardScalarWhereWithAggregatesInput | UserCardScalarWhereWithAggregatesInput[]
    OR?: UserCardScalarWhereWithAggregatesInput[]
    NOT?: UserCardScalarWhereWithAggregatesInput | UserCardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserCard"> | number
    users_id?: IntNullableWithAggregatesFilter<"UserCard"> | number | null
    card_number?: StringWithAggregatesFilter<"UserCard"> | string
    card_expiration?: StringWithAggregatesFilter<"UserCard"> | string
    phone_number?: StringWithAggregatesFilter<"UserCard"> | string
  }

  export type UserAddressWhereInput = {
    AND?: UserAddressWhereInput | UserAddressWhereInput[]
    OR?: UserAddressWhereInput[]
    NOT?: UserAddressWhereInput | UserAddressWhereInput[]
    id?: IntFilter<"UserAddress"> | number
    users_id?: IntFilter<"UserAddress"> | number
    city?: StringFilter<"UserAddress"> | string
    area?: StringFilter<"UserAddress"> | string
    street?: StringFilter<"UserAddress"> | string
    house?: StringFilter<"UserAddress"> | string
    apartment_or_office?: StringFilter<"UserAddress"> | string
    entrance?: StringNullableFilter<"UserAddress"> | string | null
    floor?: IntNullableFilter<"UserAddress"> | number | null
    intercom_code?: StringNullableFilter<"UserAddress"> | string | null
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
  }

  export type UserAddressOrderByWithRelationInput = {
    id?: SortOrder
    users_id?: SortOrder
    city?: SortOrder
    area?: SortOrder
    street?: SortOrder
    house?: SortOrder
    apartment_or_office?: SortOrder
    entrance?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    intercom_code?: SortOrderInput | SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type UserAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserAddressWhereInput | UserAddressWhereInput[]
    OR?: UserAddressWhereInput[]
    NOT?: UserAddressWhereInput | UserAddressWhereInput[]
    users_id?: IntFilter<"UserAddress"> | number
    city?: StringFilter<"UserAddress"> | string
    area?: StringFilter<"UserAddress"> | string
    street?: StringFilter<"UserAddress"> | string
    house?: StringFilter<"UserAddress"> | string
    apartment_or_office?: StringFilter<"UserAddress"> | string
    entrance?: StringNullableFilter<"UserAddress"> | string | null
    floor?: IntNullableFilter<"UserAddress"> | number | null
    intercom_code?: StringNullableFilter<"UserAddress"> | string | null
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
  }, "id">

  export type UserAddressOrderByWithAggregationInput = {
    id?: SortOrder
    users_id?: SortOrder
    city?: SortOrder
    area?: SortOrder
    street?: SortOrder
    house?: SortOrder
    apartment_or_office?: SortOrder
    entrance?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    intercom_code?: SortOrderInput | SortOrder
    _count?: UserAddressCountOrderByAggregateInput
    _avg?: UserAddressAvgOrderByAggregateInput
    _max?: UserAddressMaxOrderByAggregateInput
    _min?: UserAddressMinOrderByAggregateInput
    _sum?: UserAddressSumOrderByAggregateInput
  }

  export type UserAddressScalarWhereWithAggregatesInput = {
    AND?: UserAddressScalarWhereWithAggregatesInput | UserAddressScalarWhereWithAggregatesInput[]
    OR?: UserAddressScalarWhereWithAggregatesInput[]
    NOT?: UserAddressScalarWhereWithAggregatesInput | UserAddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAddress"> | number
    users_id?: IntWithAggregatesFilter<"UserAddress"> | number
    city?: StringWithAggregatesFilter<"UserAddress"> | string
    area?: StringWithAggregatesFilter<"UserAddress"> | string
    street?: StringWithAggregatesFilter<"UserAddress"> | string
    house?: StringWithAggregatesFilter<"UserAddress"> | string
    apartment_or_office?: StringWithAggregatesFilter<"UserAddress"> | string
    entrance?: StringNullableWithAggregatesFilter<"UserAddress"> | string | null
    floor?: IntNullableWithAggregatesFilter<"UserAddress"> | number | null
    intercom_code?: StringNullableWithAggregatesFilter<"UserAddress"> | string | null
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: IntFilter<"Supplier"> | number
    full_name?: StringFilter<"Supplier"> | string
    phone_number_1?: StringFilter<"Supplier"> | string
    phone_number_2?: StringFilter<"Supplier"> | string
    email?: StringFilter<"Supplier"> | string
    hashed_password?: StringFilter<"Supplier"> | string
    hashed_refresh_token?: StringNullableFilter<"Supplier"> | string | null
    car_name?: StringFilter<"Supplier"> | string
    car_number?: StringFilter<"Supplier"> | string
    car_size?: StringFilter<"Supplier"> | string
    contracts?: ContractsListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number_1?: SortOrder
    phone_number_2?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrderInput | SortOrder
    car_name?: SortOrder
    car_number?: SortOrder
    car_size?: SortOrder
    contracts?: ContractsOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    full_name?: StringFilter<"Supplier"> | string
    phone_number_1?: StringFilter<"Supplier"> | string
    phone_number_2?: StringFilter<"Supplier"> | string
    hashed_password?: StringFilter<"Supplier"> | string
    hashed_refresh_token?: StringNullableFilter<"Supplier"> | string | null
    car_name?: StringFilter<"Supplier"> | string
    car_number?: StringFilter<"Supplier"> | string
    car_size?: StringFilter<"Supplier"> | string
    contracts?: ContractsListRelationFilter
  }, "id" | "email">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number_1?: SortOrder
    phone_number_2?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrderInput | SortOrder
    car_name?: SortOrder
    car_number?: SortOrder
    car_size?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Supplier"> | number
    full_name?: StringWithAggregatesFilter<"Supplier"> | string
    phone_number_1?: StringWithAggregatesFilter<"Supplier"> | string
    phone_number_2?: StringWithAggregatesFilter<"Supplier"> | string
    email?: StringWithAggregatesFilter<"Supplier"> | string
    hashed_password?: StringWithAggregatesFilter<"Supplier"> | string
    hashed_refresh_token?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    car_name?: StringWithAggregatesFilter<"Supplier"> | string
    car_number?: StringWithAggregatesFilter<"Supplier"> | string
    car_size?: StringWithAggregatesFilter<"Supplier"> | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    users_id?: IntNullableFilter<"Payment"> | number | null
    contracts_id?: IntNullableFilter<"Payment"> | number | null
    user_card_id?: IntNullableFilter<"Payment"> | number | null
    company_card?: StringFilter<"Payment"> | string
    payment_amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    payment_status?: StringFilter<"Payment"> | string
    payment_date?: StringFilter<"Payment"> | string
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    Contracts?: XOR<ContractsNullableRelationFilter, ContractsWhereInput> | null
    UserCard?: XOR<UserCardNullableRelationFilter, UserCardWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    users_id?: SortOrderInput | SortOrder
    contracts_id?: SortOrderInput | SortOrder
    user_card_id?: SortOrderInput | SortOrder
    company_card?: SortOrder
    payment_amount?: SortOrder
    payment_status?: SortOrder
    payment_date?: SortOrder
    Users?: UsersOrderByWithRelationInput
    Contracts?: ContractsOrderByWithRelationInput
    UserCard?: UserCardOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    users_id?: IntNullableFilter<"Payment"> | number | null
    contracts_id?: IntNullableFilter<"Payment"> | number | null
    user_card_id?: IntNullableFilter<"Payment"> | number | null
    company_card?: StringFilter<"Payment"> | string
    payment_amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    payment_status?: StringFilter<"Payment"> | string
    payment_date?: StringFilter<"Payment"> | string
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    Contracts?: XOR<ContractsNullableRelationFilter, ContractsWhereInput> | null
    UserCard?: XOR<UserCardNullableRelationFilter, UserCardWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    users_id?: SortOrderInput | SortOrder
    contracts_id?: SortOrderInput | SortOrder
    user_card_id?: SortOrderInput | SortOrder
    company_card?: SortOrder
    payment_amount?: SortOrder
    payment_status?: SortOrder
    payment_date?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    users_id?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    contracts_id?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    user_card_id?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    company_card?: StringWithAggregatesFilter<"Payment"> | string
    payment_amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    payment_status?: StringWithAggregatesFilter<"Payment"> | string
    payment_date?: StringWithAggregatesFilter<"Payment"> | string
  }

  export type ContractsWhereInput = {
    AND?: ContractsWhereInput | ContractsWhereInput[]
    OR?: ContractsWhereInput[]
    NOT?: ContractsWhereInput | ContractsWhereInput[]
    id?: IntFilter<"Contracts"> | number
    users_id?: IntNullableFilter<"Contracts"> | number | null
    supplier_id?: IntNullableFilter<"Contracts"> | number | null
    delivery_date?: StringFilter<"Contracts"> | string
    note_to_supplier?: StringNullableFilter<"Contracts"> | string | null
    hours?: StringFilter<"Contracts"> | string
    delivery_status?: StringFilter<"Contracts"> | string
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    Supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    contracts_detailing?: ContractsDetailingListRelationFilter
    payment?: PaymentListRelationFilter
  }

  export type ContractsOrderByWithRelationInput = {
    id?: SortOrder
    users_id?: SortOrderInput | SortOrder
    supplier_id?: SortOrderInput | SortOrder
    delivery_date?: SortOrder
    note_to_supplier?: SortOrderInput | SortOrder
    hours?: SortOrder
    delivery_status?: SortOrder
    Users?: UsersOrderByWithRelationInput
    Supplier?: SupplierOrderByWithRelationInput
    contracts_detailing?: ContractsDetailingOrderByRelationAggregateInput
    payment?: PaymentOrderByRelationAggregateInput
  }

  export type ContractsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContractsWhereInput | ContractsWhereInput[]
    OR?: ContractsWhereInput[]
    NOT?: ContractsWhereInput | ContractsWhereInput[]
    users_id?: IntNullableFilter<"Contracts"> | number | null
    supplier_id?: IntNullableFilter<"Contracts"> | number | null
    delivery_date?: StringFilter<"Contracts"> | string
    note_to_supplier?: StringNullableFilter<"Contracts"> | string | null
    hours?: StringFilter<"Contracts"> | string
    delivery_status?: StringFilter<"Contracts"> | string
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    Supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    contracts_detailing?: ContractsDetailingListRelationFilter
    payment?: PaymentListRelationFilter
  }, "id">

  export type ContractsOrderByWithAggregationInput = {
    id?: SortOrder
    users_id?: SortOrderInput | SortOrder
    supplier_id?: SortOrderInput | SortOrder
    delivery_date?: SortOrder
    note_to_supplier?: SortOrderInput | SortOrder
    hours?: SortOrder
    delivery_status?: SortOrder
    _count?: ContractsCountOrderByAggregateInput
    _avg?: ContractsAvgOrderByAggregateInput
    _max?: ContractsMaxOrderByAggregateInput
    _min?: ContractsMinOrderByAggregateInput
    _sum?: ContractsSumOrderByAggregateInput
  }

  export type ContractsScalarWhereWithAggregatesInput = {
    AND?: ContractsScalarWhereWithAggregatesInput | ContractsScalarWhereWithAggregatesInput[]
    OR?: ContractsScalarWhereWithAggregatesInput[]
    NOT?: ContractsScalarWhereWithAggregatesInput | ContractsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contracts"> | number
    users_id?: IntNullableWithAggregatesFilter<"Contracts"> | number | null
    supplier_id?: IntNullableWithAggregatesFilter<"Contracts"> | number | null
    delivery_date?: StringWithAggregatesFilter<"Contracts"> | string
    note_to_supplier?: StringNullableWithAggregatesFilter<"Contracts"> | string | null
    hours?: StringWithAggregatesFilter<"Contracts"> | string
    delivery_status?: StringWithAggregatesFilter<"Contracts"> | string
  }

  export type ContractsDetailingWhereInput = {
    AND?: ContractsDetailingWhereInput | ContractsDetailingWhereInput[]
    OR?: ContractsDetailingWhereInput[]
    NOT?: ContractsDetailingWhereInput | ContractsDetailingWhereInput[]
    id?: IntFilter<"ContractsDetailing"> | number
    users_id?: IntNullableFilter<"ContractsDetailing"> | number | null
    furniture_id?: IntNullableFilter<"ContractsDetailing"> | number | null
    contracts_id?: IntNullableFilter<"ContractsDetailing"> | number | null
    count?: IntFilter<"ContractsDetailing"> | number
    total_price?: DecimalFilter<"ContractsDetailing"> | Decimal | DecimalJsLike | number | string
    contract_date?: StringFilter<"ContractsDetailing"> | string
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    Furniture?: XOR<FurnitureNullableRelationFilter, FurnitureWhereInput> | null
    Contracts?: XOR<ContractsNullableRelationFilter, ContractsWhereInput> | null
  }

  export type ContractsDetailingOrderByWithRelationInput = {
    id?: SortOrder
    users_id?: SortOrderInput | SortOrder
    furniture_id?: SortOrderInput | SortOrder
    contracts_id?: SortOrderInput | SortOrder
    count?: SortOrder
    total_price?: SortOrder
    contract_date?: SortOrder
    Users?: UsersOrderByWithRelationInput
    Furniture?: FurnitureOrderByWithRelationInput
    Contracts?: ContractsOrderByWithRelationInput
  }

  export type ContractsDetailingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContractsDetailingWhereInput | ContractsDetailingWhereInput[]
    OR?: ContractsDetailingWhereInput[]
    NOT?: ContractsDetailingWhereInput | ContractsDetailingWhereInput[]
    users_id?: IntNullableFilter<"ContractsDetailing"> | number | null
    furniture_id?: IntNullableFilter<"ContractsDetailing"> | number | null
    contracts_id?: IntNullableFilter<"ContractsDetailing"> | number | null
    count?: IntFilter<"ContractsDetailing"> | number
    total_price?: DecimalFilter<"ContractsDetailing"> | Decimal | DecimalJsLike | number | string
    contract_date?: StringFilter<"ContractsDetailing"> | string
    Users?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    Furniture?: XOR<FurnitureNullableRelationFilter, FurnitureWhereInput> | null
    Contracts?: XOR<ContractsNullableRelationFilter, ContractsWhereInput> | null
  }, "id">

  export type ContractsDetailingOrderByWithAggregationInput = {
    id?: SortOrder
    users_id?: SortOrderInput | SortOrder
    furniture_id?: SortOrderInput | SortOrder
    contracts_id?: SortOrderInput | SortOrder
    count?: SortOrder
    total_price?: SortOrder
    contract_date?: SortOrder
    _count?: ContractsDetailingCountOrderByAggregateInput
    _avg?: ContractsDetailingAvgOrderByAggregateInput
    _max?: ContractsDetailingMaxOrderByAggregateInput
    _min?: ContractsDetailingMinOrderByAggregateInput
    _sum?: ContractsDetailingSumOrderByAggregateInput
  }

  export type ContractsDetailingScalarWhereWithAggregatesInput = {
    AND?: ContractsDetailingScalarWhereWithAggregatesInput | ContractsDetailingScalarWhereWithAggregatesInput[]
    OR?: ContractsDetailingScalarWhereWithAggregatesInput[]
    NOT?: ContractsDetailingScalarWhereWithAggregatesInput | ContractsDetailingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContractsDetailing"> | number
    users_id?: IntNullableWithAggregatesFilter<"ContractsDetailing"> | number | null
    furniture_id?: IntNullableWithAggregatesFilter<"ContractsDetailing"> | number | null
    contracts_id?: IntNullableWithAggregatesFilter<"ContractsDetailing"> | number | null
    count?: IntWithAggregatesFilter<"ContractsDetailing"> | number
    total_price?: DecimalWithAggregatesFilter<"ContractsDetailing"> | Decimal | DecimalJsLike | number | string
    contract_date?: StringWithAggregatesFilter<"ContractsDetailing"> | string
  }

  export type ColorsCreateInput = {
    name: string
    furniture?: FurnitureCreateNestedManyWithoutColorsInput
  }

  export type ColorsUncheckedCreateInput = {
    id?: number
    name: string
    furniture?: FurnitureUncheckedCreateNestedManyWithoutColorsInput
  }

  export type ColorsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    furniture?: FurnitureUpdateManyWithoutColorsNestedInput
  }

  export type ColorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    furniture?: FurnitureUncheckedUpdateManyWithoutColorsNestedInput
  }

  export type ColorsCreateManyInput = {
    id?: number
    name: string
  }

  export type ColorsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ColorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialsCreateInput = {
    name: string
    furniture?: FurnitureCreateNestedManyWithoutMaterialsInput
  }

  export type MaterialsUncheckedCreateInput = {
    id?: number
    name: string
    furniture?: FurnitureUncheckedCreateNestedManyWithoutMaterialsInput
  }

  export type MaterialsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    furniture?: FurnitureUpdateManyWithoutMaterialsNestedInput
  }

  export type MaterialsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    furniture?: FurnitureUncheckedUpdateManyWithoutMaterialsNestedInput
  }

  export type MaterialsCreateManyInput = {
    id?: number
    name: string
  }

  export type MaterialsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoomTypesCreateInput = {
    name: string
    furniture?: FurnitureCreateNestedManyWithoutRoomTypesInput
  }

  export type RoomTypesUncheckedCreateInput = {
    id?: number
    name: string
    furniture?: FurnitureUncheckedCreateNestedManyWithoutRoomTypesInput
  }

  export type RoomTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    furniture?: FurnitureUpdateManyWithoutRoomTypesNestedInput
  }

  export type RoomTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    furniture?: FurnitureUncheckedUpdateManyWithoutRoomTypesNestedInput
  }

  export type RoomTypesCreateManyInput = {
    id?: number
    name: string
  }

  export type RoomTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoomTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureTypesCreateInput = {
    name: string
    furniture?: FurnitureCreateNestedManyWithoutFurnitureTypesInput
  }

  export type FurnitureTypesUncheckedCreateInput = {
    id?: number
    name: string
    furniture?: FurnitureUncheckedCreateNestedManyWithoutFurnitureTypesInput
  }

  export type FurnitureTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    furniture?: FurnitureUpdateManyWithoutFurnitureTypesNestedInput
  }

  export type FurnitureTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    furniture?: FurnitureUncheckedUpdateManyWithoutFurnitureTypesNestedInput
  }

  export type FurnitureTypesCreateManyInput = {
    id?: number
    name: string
  }

  export type FurnitureTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FurniturePhotosCreateInput = {
    url: string
    caption: string
    Furniture?: FurnitureCreateNestedOneWithoutFurniture_photosInput
  }

  export type FurniturePhotosUncheckedCreateInput = {
    id?: number
    furniture_id?: number | null
    url: string
    caption: string
  }

  export type FurniturePhotosUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
    Furniture?: FurnitureUpdateOneWithoutFurniture_photosNestedInput
  }

  export type FurniturePhotosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
  }

  export type FurniturePhotosCreateManyInput = {
    id?: number
    furniture_id?: number | null
    url: string
    caption: string
  }

  export type FurniturePhotosUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
  }

  export type FurniturePhotosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureCreateInput = {
    name: string
    produced_date: string
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    Colors?: ColorsCreateNestedOneWithoutFurnitureInput
    Materials?: MaterialsCreateNestedOneWithoutFurnitureInput
    RoomTypes?: RoomTypesCreateNestedOneWithoutFurnitureInput
    FurnitureTypes?: FurnitureTypesCreateNestedOneWithoutFurnitureInput
    furniture_photos?: FurniturePhotosCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureUncheckedCreateInput = {
    id?: number
    name: string
    produced_date: string
    colors_id?: number | null
    materials_id?: number | null
    roomTypes_id?: number | null
    furniture_types_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Colors?: ColorsUpdateOneWithoutFurnitureNestedInput
    Materials?: MaterialsUpdateOneWithoutFurnitureNestedInput
    RoomTypes?: RoomTypesUpdateOneWithoutFurnitureNestedInput
    FurnitureTypes?: FurnitureTypesUpdateOneWithoutFurnitureNestedInput
    furniture_photos?: FurniturePhotosUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    colors_id?: NullableIntFieldUpdateOperationsInput | number | null
    materials_id?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypes_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_types_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureCreateManyInput = {
    id?: number
    name: string
    produced_date: string
    colors_id?: number | null
    materials_id?: number | null
    roomTypes_id?: number | null
    furniture_types_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
  }

  export type FurnitureUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FurnitureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    colors_id?: NullableIntFieldUpdateOperationsInput | number | null
    materials_id?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypes_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_types_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UsersCreateInput = {
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutUsersInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutUsersInput
    user_card?: UserCardCreateNestedManyWithoutUsersInput
    user_address?: UserAddressCreateNestedManyWithoutUsersInput
    payment?: PaymentCreateNestedManyWithoutUsersInput
    contracts?: ContractsCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    id?: number
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutUsersInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutUsersInput
    user_card?: UserCardUncheckedCreateNestedManyWithoutUsersInput
    user_address?: UserAddressUncheckedCreateNestedManyWithoutUsersInput
    payment?: PaymentUncheckedCreateNestedManyWithoutUsersInput
    contracts?: ContractsUncheckedCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUpdateManyWithoutUsersNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUpdateManyWithoutUsersNestedInput
    payment?: PaymentUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutUsersNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUncheckedUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUncheckedUpdateManyWithoutUsersNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUncheckedUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateManyInput = {
    id?: number
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
  }

  export type UsersUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FurnitureCommentsCreateInput = {
    user_comment: string
    Users?: UsersCreateNestedOneWithoutFurniture_commentsInput
    Furniture?: FurnitureCreateNestedOneWithoutFurniture_commentsInput
  }

  export type FurnitureCommentsUncheckedCreateInput = {
    id?: number
    users_id?: number | null
    furniture_id?: number | null
    user_comment: string
  }

  export type FurnitureCommentsUpdateInput = {
    user_comment?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutFurniture_commentsNestedInput
    Furniture?: FurnitureUpdateOneWithoutFurniture_commentsNestedInput
  }

  export type FurnitureCommentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_comment?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureCommentsCreateManyInput = {
    id?: number
    users_id?: number | null
    furniture_id?: number | null
    user_comment: string
  }

  export type FurnitureCommentsUpdateManyMutationInput = {
    user_comment?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureCommentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_comment?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureLikesCreateInput = {
    Users?: UsersCreateNestedOneWithoutFurniture_likesInput
    Furniture?: FurnitureCreateNestedOneWithoutFurniture_likesInput
  }

  export type FurnitureLikesUncheckedCreateInput = {
    id?: number
    users_id?: number | null
    furniture_id?: number | null
  }

  export type FurnitureLikesUpdateInput = {
    Users?: UsersUpdateOneWithoutFurniture_likesNestedInput
    Furniture?: FurnitureUpdateOneWithoutFurniture_likesNestedInput
  }

  export type FurnitureLikesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FurnitureLikesCreateManyInput = {
    id?: number
    users_id?: number | null
    furniture_id?: number | null
  }

  export type FurnitureLikesUpdateManyMutationInput = {

  }

  export type FurnitureLikesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdminsCreateInput = {
    full_name: string
    birth_date?: string | null
    phone_number: string
    email: string
    hashed_password?: string | null
    hashed_refresh_token?: string | null
    is_creator?: boolean
    admin_roles?: AdminRolesCreateNestedManyWithoutAdminsInput
  }

  export type AdminsUncheckedCreateInput = {
    id?: number
    full_name: string
    birth_date?: string | null
    phone_number: string
    email: string
    hashed_password?: string | null
    hashed_refresh_token?: string | null
    is_creator?: boolean
    admin_roles?: AdminRolesUncheckedCreateNestedManyWithoutAdminsInput
  }

  export type AdminsUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_creator?: BoolFieldUpdateOperationsInput | boolean
    admin_roles?: AdminRolesUpdateManyWithoutAdminsNestedInput
  }

  export type AdminsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_creator?: BoolFieldUpdateOperationsInput | boolean
    admin_roles?: AdminRolesUncheckedUpdateManyWithoutAdminsNestedInput
  }

  export type AdminsCreateManyInput = {
    id?: number
    full_name: string
    birth_date?: string | null
    phone_number: string
    email: string
    hashed_password?: string | null
    hashed_refresh_token?: string | null
    is_creator?: boolean
  }

  export type AdminsUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_creator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_creator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolesCreateInput = {
    value: string
    description: string
    admin_roles?: AdminRolesCreateNestedManyWithoutRolesInput
  }

  export type RolesUncheckedCreateInput = {
    id?: number
    value: string
    description: string
    admin_roles?: AdminRolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RolesUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    admin_roles?: AdminRolesUpdateManyWithoutRolesNestedInput
  }

  export type RolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    admin_roles?: AdminRolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RolesCreateManyInput = {
    id?: number
    value: string
    description: string
  }

  export type RolesUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type AdminRolesCreateInput = {
    Admins?: AdminsCreateNestedOneWithoutAdmin_rolesInput
    Roles?: RolesCreateNestedOneWithoutAdmin_rolesInput
  }

  export type AdminRolesUncheckedCreateInput = {
    id?: number
    admins_id?: number | null
    roles_id?: number | null
  }

  export type AdminRolesUpdateInput = {
    Admins?: AdminsUpdateOneWithoutAdmin_rolesNestedInput
    Roles?: RolesUpdateOneWithoutAdmin_rolesNestedInput
  }

  export type AdminRolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    admins_id?: NullableIntFieldUpdateOperationsInput | number | null
    roles_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdminRolesCreateManyInput = {
    id?: number
    admins_id?: number | null
    roles_id?: number | null
  }

  export type AdminRolesUpdateManyMutationInput = {

  }

  export type AdminRolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    admins_id?: NullableIntFieldUpdateOperationsInput | number | null
    roles_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCardCreateInput = {
    card_number: string
    card_expiration: string
    phone_number: string
    Users?: UsersCreateNestedOneWithoutUser_cardInput
    payment?: PaymentCreateNestedManyWithoutUserCardInput
  }

  export type UserCardUncheckedCreateInput = {
    id?: number
    users_id?: number | null
    card_number: string
    card_expiration: string
    phone_number: string
    payment?: PaymentUncheckedCreateNestedManyWithoutUserCardInput
  }

  export type UserCardUpdateInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    card_expiration?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutUser_cardNestedInput
    payment?: PaymentUpdateManyWithoutUserCardNestedInput
  }

  export type UserCardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    card_number?: StringFieldUpdateOperationsInput | string
    card_expiration?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    payment?: PaymentUncheckedUpdateManyWithoutUserCardNestedInput
  }

  export type UserCardCreateManyInput = {
    id?: number
    users_id?: number | null
    card_number: string
    card_expiration: string
    phone_number: string
  }

  export type UserCardUpdateManyMutationInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    card_expiration?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
  }

  export type UserCardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    card_number?: StringFieldUpdateOperationsInput | string
    card_expiration?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
  }

  export type UserAddressCreateInput = {
    city: string
    area: string
    street: string
    house: string
    apartment_or_office: string
    entrance?: string | null
    floor?: number | null
    intercom_code?: string | null
    Users?: UsersCreateNestedOneWithoutUser_addressInput
  }

  export type UserAddressUncheckedCreateInput = {
    id?: number
    users_id: number
    city: string
    area: string
    street: string
    house: string
    apartment_or_office: string
    entrance?: string | null
    floor?: number | null
    intercom_code?: string | null
  }

  export type UserAddressUpdateInput = {
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    house?: StringFieldUpdateOperationsInput | string
    apartment_or_office?: StringFieldUpdateOperationsInput | string
    entrance?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    intercom_code?: NullableStringFieldUpdateOperationsInput | string | null
    Users?: UsersUpdateOneWithoutUser_addressNestedInput
  }

  export type UserAddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    house?: StringFieldUpdateOperationsInput | string
    apartment_or_office?: StringFieldUpdateOperationsInput | string
    entrance?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    intercom_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAddressCreateManyInput = {
    id?: number
    users_id: number
    city: string
    area: string
    street: string
    house: string
    apartment_or_office: string
    entrance?: string | null
    floor?: number | null
    intercom_code?: string | null
  }

  export type UserAddressUpdateManyMutationInput = {
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    house?: StringFieldUpdateOperationsInput | string
    apartment_or_office?: StringFieldUpdateOperationsInput | string
    entrance?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    intercom_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    house?: StringFieldUpdateOperationsInput | string
    apartment_or_office?: StringFieldUpdateOperationsInput | string
    entrance?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    intercom_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierCreateInput = {
    full_name: string
    phone_number_1: string
    phone_number_2: string
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    car_name: string
    car_number: string
    car_size: string
    contracts?: ContractsCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: number
    full_name: string
    phone_number_1: string
    phone_number_2: string
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    car_name: string
    car_number: string
    car_size: string
    contracts?: ContractsUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number_1?: StringFieldUpdateOperationsInput | string
    phone_number_2?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    car_name?: StringFieldUpdateOperationsInput | string
    car_number?: StringFieldUpdateOperationsInput | string
    car_size?: StringFieldUpdateOperationsInput | string
    contracts?: ContractsUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number_1?: StringFieldUpdateOperationsInput | string
    phone_number_2?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    car_name?: StringFieldUpdateOperationsInput | string
    car_number?: StringFieldUpdateOperationsInput | string
    car_size?: StringFieldUpdateOperationsInput | string
    contracts?: ContractsUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: number
    full_name: string
    phone_number_1: string
    phone_number_2: string
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    car_name: string
    car_number: string
    car_size: string
  }

  export type SupplierUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number_1?: StringFieldUpdateOperationsInput | string
    phone_number_2?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    car_name?: StringFieldUpdateOperationsInput | string
    car_number?: StringFieldUpdateOperationsInput | string
    car_size?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number_1?: StringFieldUpdateOperationsInput | string
    phone_number_2?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    car_name?: StringFieldUpdateOperationsInput | string
    car_number?: StringFieldUpdateOperationsInput | string
    car_size?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateInput = {
    company_card: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_status: string
    payment_date: string
    Users?: UsersCreateNestedOneWithoutPaymentInput
    Contracts?: ContractsCreateNestedOneWithoutPaymentInput
    UserCard?: UserCardCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    users_id?: number | null
    contracts_id?: number | null
    user_card_id?: number | null
    company_card: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_status: string
    payment_date: string
  }

  export type PaymentUpdateInput = {
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutPaymentNestedInput
    Contracts?: ContractsUpdateOneWithoutPaymentNestedInput
    UserCard?: UserCardUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    contracts_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    users_id?: number | null
    contracts_id?: number | null
    user_card_id?: number | null
    company_card: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_status: string
    payment_date: string
  }

  export type PaymentUpdateManyMutationInput = {
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    contracts_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsCreateInput = {
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
    Users?: UsersCreateNestedOneWithoutContractsInput
    Supplier?: SupplierCreateNestedOneWithoutContractsInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutContractsInput
    payment?: PaymentCreateNestedManyWithoutContractsInput
  }

  export type ContractsUncheckedCreateInput = {
    id?: number
    users_id?: number | null
    supplier_id?: number | null
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutContractsInput
    payment?: PaymentUncheckedCreateNestedManyWithoutContractsInput
  }

  export type ContractsUpdateInput = {
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutContractsNestedInput
    Supplier?: SupplierUpdateOneWithoutContractsNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutContractsNestedInput
    payment?: PaymentUpdateManyWithoutContractsNestedInput
  }

  export type ContractsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutContractsNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutContractsNestedInput
  }

  export type ContractsCreateManyInput = {
    id?: number
    users_id?: number | null
    supplier_id?: number | null
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
  }

  export type ContractsUpdateManyMutationInput = {
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsDetailingCreateInput = {
    count: number
    total_price: Decimal | DecimalJsLike | number | string
    contract_date: string
    Users?: UsersCreateNestedOneWithoutContracts_detailingInput
    Furniture?: FurnitureCreateNestedOneWithoutContracts_detailingInput
    Contracts?: ContractsCreateNestedOneWithoutContracts_detailingInput
  }

  export type ContractsDetailingUncheckedCreateInput = {
    id?: number
    users_id?: number | null
    furniture_id?: number | null
    contracts_id?: number | null
    count: number
    total_price: Decimal | DecimalJsLike | number | string
    contract_date: string
  }

  export type ContractsDetailingUpdateInput = {
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutContracts_detailingNestedInput
    Furniture?: FurnitureUpdateOneWithoutContracts_detailingNestedInput
    Contracts?: ContractsUpdateOneWithoutContracts_detailingNestedInput
  }

  export type ContractsDetailingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
    contracts_id?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsDetailingCreateManyInput = {
    id?: number
    users_id?: number | null
    furniture_id?: number | null
    contracts_id?: number | null
    count: number
    total_price: Decimal | DecimalJsLike | number | string
    contract_date: string
  }

  export type ContractsDetailingUpdateManyMutationInput = {
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsDetailingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
    contracts_id?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FurnitureListRelationFilter = {
    every?: FurnitureWhereInput
    some?: FurnitureWhereInput
    none?: FurnitureWhereInput
  }

  export type FurnitureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ColorsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ColorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ColorsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ColorsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ColorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type MaterialsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MaterialsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaterialsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MaterialsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MaterialsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoomTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoomTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoomTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoomTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoomTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FurnitureTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FurnitureTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FurnitureTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FurnitureTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FurnitureTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FurnitureNullableRelationFilter = {
    is?: FurnitureWhereInput | null
    isNot?: FurnitureWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FurniturePhotosCountOrderByAggregateInput = {
    id?: SortOrder
    furniture_id?: SortOrder
    url?: SortOrder
    caption?: SortOrder
  }

  export type FurniturePhotosAvgOrderByAggregateInput = {
    id?: SortOrder
    furniture_id?: SortOrder
  }

  export type FurniturePhotosMaxOrderByAggregateInput = {
    id?: SortOrder
    furniture_id?: SortOrder
    url?: SortOrder
    caption?: SortOrder
  }

  export type FurniturePhotosMinOrderByAggregateInput = {
    id?: SortOrder
    furniture_id?: SortOrder
    url?: SortOrder
    caption?: SortOrder
  }

  export type FurniturePhotosSumOrderByAggregateInput = {
    id?: SortOrder
    furniture_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ColorsNullableRelationFilter = {
    is?: ColorsWhereInput | null
    isNot?: ColorsWhereInput | null
  }

  export type MaterialsNullableRelationFilter = {
    is?: MaterialsWhereInput | null
    isNot?: MaterialsWhereInput | null
  }

  export type RoomTypesNullableRelationFilter = {
    is?: RoomTypesWhereInput | null
    isNot?: RoomTypesWhereInput | null
  }

  export type FurnitureTypesNullableRelationFilter = {
    is?: FurnitureTypesWhereInput | null
    isNot?: FurnitureTypesWhereInput | null
  }

  export type FurniturePhotosListRelationFilter = {
    every?: FurniturePhotosWhereInput
    some?: FurniturePhotosWhereInput
    none?: FurniturePhotosWhereInput
  }

  export type FurnitureCommentsListRelationFilter = {
    every?: FurnitureCommentsWhereInput
    some?: FurnitureCommentsWhereInput
    none?: FurnitureCommentsWhereInput
  }

  export type FurnitureLikesListRelationFilter = {
    every?: FurnitureLikesWhereInput
    some?: FurnitureLikesWhereInput
    none?: FurnitureLikesWhereInput
  }

  export type ContractsDetailingListRelationFilter = {
    every?: ContractsDetailingWhereInput
    some?: ContractsDetailingWhereInput
    none?: ContractsDetailingWhereInput
  }

  export type FurniturePhotosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FurnitureCommentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FurnitureLikesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractsDetailingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FurnitureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    produced_date?: SortOrder
    colors_id?: SortOrder
    materials_id?: SortOrder
    roomTypes_id?: SortOrder
    furniture_types_id?: SortOrder
    description?: SortOrder
    height?: SortOrder
    width?: SortOrder
    price?: SortOrder
  }

  export type FurnitureAvgOrderByAggregateInput = {
    id?: SortOrder
    colors_id?: SortOrder
    materials_id?: SortOrder
    roomTypes_id?: SortOrder
    furniture_types_id?: SortOrder
    height?: SortOrder
    width?: SortOrder
    price?: SortOrder
  }

  export type FurnitureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    produced_date?: SortOrder
    colors_id?: SortOrder
    materials_id?: SortOrder
    roomTypes_id?: SortOrder
    furniture_types_id?: SortOrder
    description?: SortOrder
    height?: SortOrder
    width?: SortOrder
    price?: SortOrder
  }

  export type FurnitureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    produced_date?: SortOrder
    colors_id?: SortOrder
    materials_id?: SortOrder
    roomTypes_id?: SortOrder
    furniture_types_id?: SortOrder
    description?: SortOrder
    height?: SortOrder
    width?: SortOrder
    price?: SortOrder
  }

  export type FurnitureSumOrderByAggregateInput = {
    id?: SortOrder
    colors_id?: SortOrder
    materials_id?: SortOrder
    roomTypes_id?: SortOrder
    furniture_types_id?: SortOrder
    height?: SortOrder
    width?: SortOrder
    price?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserCardListRelationFilter = {
    every?: UserCardWhereInput
    some?: UserCardWhereInput
    none?: UserCardWhereInput
  }

  export type UserAddressListRelationFilter = {
    every?: UserAddressWhereInput
    some?: UserAddressWhereInput
    none?: UserAddressWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ContractsListRelationFilter = {
    every?: ContractsWhereInput
    some?: ContractsWhereInput
    none?: ContractsWhereInput
  }

  export type UserCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    birth_date?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    activation_link?: SortOrder
    is_active?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    birth_date?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    activation_link?: SortOrder
    is_active?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    birth_date?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    activation_link?: SortOrder
    is_active?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UsersNullableRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type FurnitureCommentsCountOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
    user_comment?: SortOrder
  }

  export type FurnitureCommentsAvgOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
  }

  export type FurnitureCommentsMaxOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
    user_comment?: SortOrder
  }

  export type FurnitureCommentsMinOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
    user_comment?: SortOrder
  }

  export type FurnitureCommentsSumOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
  }

  export type FurnitureLikesCountOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
  }

  export type FurnitureLikesAvgOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
  }

  export type FurnitureLikesMaxOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
  }

  export type FurnitureLikesMinOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
  }

  export type FurnitureLikesSumOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
  }

  export type AdminRolesListRelationFilter = {
    every?: AdminRolesWhereInput
    some?: AdminRolesWhereInput
    none?: AdminRolesWhereInput
  }

  export type AdminRolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminsCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    birth_date?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    is_creator?: SortOrder
  }

  export type AdminsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminsMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    birth_date?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    is_creator?: SortOrder
  }

  export type AdminsMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    birth_date?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    is_creator?: SortOrder
  }

  export type AdminsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminsNullableRelationFilter = {
    is?: AdminsWhereInput | null
    isNot?: AdminsWhereInput | null
  }

  export type RolesNullableRelationFilter = {
    is?: RolesWhereInput | null
    isNot?: RolesWhereInput | null
  }

  export type AdminRolesCountOrderByAggregateInput = {
    id?: SortOrder
    admins_id?: SortOrder
    roles_id?: SortOrder
  }

  export type AdminRolesAvgOrderByAggregateInput = {
    id?: SortOrder
    admins_id?: SortOrder
    roles_id?: SortOrder
  }

  export type AdminRolesMaxOrderByAggregateInput = {
    id?: SortOrder
    admins_id?: SortOrder
    roles_id?: SortOrder
  }

  export type AdminRolesMinOrderByAggregateInput = {
    id?: SortOrder
    admins_id?: SortOrder
    roles_id?: SortOrder
  }

  export type AdminRolesSumOrderByAggregateInput = {
    id?: SortOrder
    admins_id?: SortOrder
    roles_id?: SortOrder
  }

  export type UserCardCountOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    card_number?: SortOrder
    card_expiration?: SortOrder
    phone_number?: SortOrder
  }

  export type UserCardAvgOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
  }

  export type UserCardMaxOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    card_number?: SortOrder
    card_expiration?: SortOrder
    phone_number?: SortOrder
  }

  export type UserCardMinOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    card_number?: SortOrder
    card_expiration?: SortOrder
    phone_number?: SortOrder
  }

  export type UserCardSumOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
  }

  export type UserAddressCountOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    city?: SortOrder
    area?: SortOrder
    street?: SortOrder
    house?: SortOrder
    apartment_or_office?: SortOrder
    entrance?: SortOrder
    floor?: SortOrder
    intercom_code?: SortOrder
  }

  export type UserAddressAvgOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    floor?: SortOrder
  }

  export type UserAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    city?: SortOrder
    area?: SortOrder
    street?: SortOrder
    house?: SortOrder
    apartment_or_office?: SortOrder
    entrance?: SortOrder
    floor?: SortOrder
    intercom_code?: SortOrder
  }

  export type UserAddressMinOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    city?: SortOrder
    area?: SortOrder
    street?: SortOrder
    house?: SortOrder
    apartment_or_office?: SortOrder
    entrance?: SortOrder
    floor?: SortOrder
    intercom_code?: SortOrder
  }

  export type UserAddressSumOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    floor?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number_1?: SortOrder
    phone_number_2?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    car_name?: SortOrder
    car_number?: SortOrder
    car_size?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number_1?: SortOrder
    phone_number_2?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    car_name?: SortOrder
    car_number?: SortOrder
    car_size?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number_1?: SortOrder
    phone_number_2?: SortOrder
    email?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    car_name?: SortOrder
    car_number?: SortOrder
    car_size?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContractsNullableRelationFilter = {
    is?: ContractsWhereInput | null
    isNot?: ContractsWhereInput | null
  }

  export type UserCardNullableRelationFilter = {
    is?: UserCardWhereInput | null
    isNot?: UserCardWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    contracts_id?: SortOrder
    user_card_id?: SortOrder
    company_card?: SortOrder
    payment_amount?: SortOrder
    payment_status?: SortOrder
    payment_date?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    contracts_id?: SortOrder
    user_card_id?: SortOrder
    payment_amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    contracts_id?: SortOrder
    user_card_id?: SortOrder
    company_card?: SortOrder
    payment_amount?: SortOrder
    payment_status?: SortOrder
    payment_date?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    contracts_id?: SortOrder
    user_card_id?: SortOrder
    company_card?: SortOrder
    payment_amount?: SortOrder
    payment_status?: SortOrder
    payment_date?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    contracts_id?: SortOrder
    user_card_id?: SortOrder
    payment_amount?: SortOrder
  }

  export type SupplierNullableRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type ContractsCountOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    supplier_id?: SortOrder
    delivery_date?: SortOrder
    note_to_supplier?: SortOrder
    hours?: SortOrder
    delivery_status?: SortOrder
  }

  export type ContractsAvgOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    supplier_id?: SortOrder
  }

  export type ContractsMaxOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    supplier_id?: SortOrder
    delivery_date?: SortOrder
    note_to_supplier?: SortOrder
    hours?: SortOrder
    delivery_status?: SortOrder
  }

  export type ContractsMinOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    supplier_id?: SortOrder
    delivery_date?: SortOrder
    note_to_supplier?: SortOrder
    hours?: SortOrder
    delivery_status?: SortOrder
  }

  export type ContractsSumOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    supplier_id?: SortOrder
  }

  export type ContractsDetailingCountOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
    contracts_id?: SortOrder
    count?: SortOrder
    total_price?: SortOrder
    contract_date?: SortOrder
  }

  export type ContractsDetailingAvgOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
    contracts_id?: SortOrder
    count?: SortOrder
    total_price?: SortOrder
  }

  export type ContractsDetailingMaxOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
    contracts_id?: SortOrder
    count?: SortOrder
    total_price?: SortOrder
    contract_date?: SortOrder
  }

  export type ContractsDetailingMinOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
    contracts_id?: SortOrder
    count?: SortOrder
    total_price?: SortOrder
    contract_date?: SortOrder
  }

  export type ContractsDetailingSumOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    furniture_id?: SortOrder
    contracts_id?: SortOrder
    count?: SortOrder
    total_price?: SortOrder
  }

  export type FurnitureCreateNestedManyWithoutColorsInput = {
    create?: XOR<FurnitureCreateWithoutColorsInput, FurnitureUncheckedCreateWithoutColorsInput> | FurnitureCreateWithoutColorsInput[] | FurnitureUncheckedCreateWithoutColorsInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutColorsInput | FurnitureCreateOrConnectWithoutColorsInput[]
    createMany?: FurnitureCreateManyColorsInputEnvelope
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
  }

  export type FurnitureUncheckedCreateNestedManyWithoutColorsInput = {
    create?: XOR<FurnitureCreateWithoutColorsInput, FurnitureUncheckedCreateWithoutColorsInput> | FurnitureCreateWithoutColorsInput[] | FurnitureUncheckedCreateWithoutColorsInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutColorsInput | FurnitureCreateOrConnectWithoutColorsInput[]
    createMany?: FurnitureCreateManyColorsInputEnvelope
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FurnitureUpdateManyWithoutColorsNestedInput = {
    create?: XOR<FurnitureCreateWithoutColorsInput, FurnitureUncheckedCreateWithoutColorsInput> | FurnitureCreateWithoutColorsInput[] | FurnitureUncheckedCreateWithoutColorsInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutColorsInput | FurnitureCreateOrConnectWithoutColorsInput[]
    upsert?: FurnitureUpsertWithWhereUniqueWithoutColorsInput | FurnitureUpsertWithWhereUniqueWithoutColorsInput[]
    createMany?: FurnitureCreateManyColorsInputEnvelope
    set?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    disconnect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    delete?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    update?: FurnitureUpdateWithWhereUniqueWithoutColorsInput | FurnitureUpdateWithWhereUniqueWithoutColorsInput[]
    updateMany?: FurnitureUpdateManyWithWhereWithoutColorsInput | FurnitureUpdateManyWithWhereWithoutColorsInput[]
    deleteMany?: FurnitureScalarWhereInput | FurnitureScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FurnitureUncheckedUpdateManyWithoutColorsNestedInput = {
    create?: XOR<FurnitureCreateWithoutColorsInput, FurnitureUncheckedCreateWithoutColorsInput> | FurnitureCreateWithoutColorsInput[] | FurnitureUncheckedCreateWithoutColorsInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutColorsInput | FurnitureCreateOrConnectWithoutColorsInput[]
    upsert?: FurnitureUpsertWithWhereUniqueWithoutColorsInput | FurnitureUpsertWithWhereUniqueWithoutColorsInput[]
    createMany?: FurnitureCreateManyColorsInputEnvelope
    set?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    disconnect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    delete?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    update?: FurnitureUpdateWithWhereUniqueWithoutColorsInput | FurnitureUpdateWithWhereUniqueWithoutColorsInput[]
    updateMany?: FurnitureUpdateManyWithWhereWithoutColorsInput | FurnitureUpdateManyWithWhereWithoutColorsInput[]
    deleteMany?: FurnitureScalarWhereInput | FurnitureScalarWhereInput[]
  }

  export type FurnitureCreateNestedManyWithoutMaterialsInput = {
    create?: XOR<FurnitureCreateWithoutMaterialsInput, FurnitureUncheckedCreateWithoutMaterialsInput> | FurnitureCreateWithoutMaterialsInput[] | FurnitureUncheckedCreateWithoutMaterialsInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutMaterialsInput | FurnitureCreateOrConnectWithoutMaterialsInput[]
    createMany?: FurnitureCreateManyMaterialsInputEnvelope
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
  }

  export type FurnitureUncheckedCreateNestedManyWithoutMaterialsInput = {
    create?: XOR<FurnitureCreateWithoutMaterialsInput, FurnitureUncheckedCreateWithoutMaterialsInput> | FurnitureCreateWithoutMaterialsInput[] | FurnitureUncheckedCreateWithoutMaterialsInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutMaterialsInput | FurnitureCreateOrConnectWithoutMaterialsInput[]
    createMany?: FurnitureCreateManyMaterialsInputEnvelope
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
  }

  export type FurnitureUpdateManyWithoutMaterialsNestedInput = {
    create?: XOR<FurnitureCreateWithoutMaterialsInput, FurnitureUncheckedCreateWithoutMaterialsInput> | FurnitureCreateWithoutMaterialsInput[] | FurnitureUncheckedCreateWithoutMaterialsInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutMaterialsInput | FurnitureCreateOrConnectWithoutMaterialsInput[]
    upsert?: FurnitureUpsertWithWhereUniqueWithoutMaterialsInput | FurnitureUpsertWithWhereUniqueWithoutMaterialsInput[]
    createMany?: FurnitureCreateManyMaterialsInputEnvelope
    set?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    disconnect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    delete?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    update?: FurnitureUpdateWithWhereUniqueWithoutMaterialsInput | FurnitureUpdateWithWhereUniqueWithoutMaterialsInput[]
    updateMany?: FurnitureUpdateManyWithWhereWithoutMaterialsInput | FurnitureUpdateManyWithWhereWithoutMaterialsInput[]
    deleteMany?: FurnitureScalarWhereInput | FurnitureScalarWhereInput[]
  }

  export type FurnitureUncheckedUpdateManyWithoutMaterialsNestedInput = {
    create?: XOR<FurnitureCreateWithoutMaterialsInput, FurnitureUncheckedCreateWithoutMaterialsInput> | FurnitureCreateWithoutMaterialsInput[] | FurnitureUncheckedCreateWithoutMaterialsInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutMaterialsInput | FurnitureCreateOrConnectWithoutMaterialsInput[]
    upsert?: FurnitureUpsertWithWhereUniqueWithoutMaterialsInput | FurnitureUpsertWithWhereUniqueWithoutMaterialsInput[]
    createMany?: FurnitureCreateManyMaterialsInputEnvelope
    set?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    disconnect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    delete?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    update?: FurnitureUpdateWithWhereUniqueWithoutMaterialsInput | FurnitureUpdateWithWhereUniqueWithoutMaterialsInput[]
    updateMany?: FurnitureUpdateManyWithWhereWithoutMaterialsInput | FurnitureUpdateManyWithWhereWithoutMaterialsInput[]
    deleteMany?: FurnitureScalarWhereInput | FurnitureScalarWhereInput[]
  }

  export type FurnitureCreateNestedManyWithoutRoomTypesInput = {
    create?: XOR<FurnitureCreateWithoutRoomTypesInput, FurnitureUncheckedCreateWithoutRoomTypesInput> | FurnitureCreateWithoutRoomTypesInput[] | FurnitureUncheckedCreateWithoutRoomTypesInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutRoomTypesInput | FurnitureCreateOrConnectWithoutRoomTypesInput[]
    createMany?: FurnitureCreateManyRoomTypesInputEnvelope
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
  }

  export type FurnitureUncheckedCreateNestedManyWithoutRoomTypesInput = {
    create?: XOR<FurnitureCreateWithoutRoomTypesInput, FurnitureUncheckedCreateWithoutRoomTypesInput> | FurnitureCreateWithoutRoomTypesInput[] | FurnitureUncheckedCreateWithoutRoomTypesInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutRoomTypesInput | FurnitureCreateOrConnectWithoutRoomTypesInput[]
    createMany?: FurnitureCreateManyRoomTypesInputEnvelope
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
  }

  export type FurnitureUpdateManyWithoutRoomTypesNestedInput = {
    create?: XOR<FurnitureCreateWithoutRoomTypesInput, FurnitureUncheckedCreateWithoutRoomTypesInput> | FurnitureCreateWithoutRoomTypesInput[] | FurnitureUncheckedCreateWithoutRoomTypesInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutRoomTypesInput | FurnitureCreateOrConnectWithoutRoomTypesInput[]
    upsert?: FurnitureUpsertWithWhereUniqueWithoutRoomTypesInput | FurnitureUpsertWithWhereUniqueWithoutRoomTypesInput[]
    createMany?: FurnitureCreateManyRoomTypesInputEnvelope
    set?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    disconnect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    delete?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    update?: FurnitureUpdateWithWhereUniqueWithoutRoomTypesInput | FurnitureUpdateWithWhereUniqueWithoutRoomTypesInput[]
    updateMany?: FurnitureUpdateManyWithWhereWithoutRoomTypesInput | FurnitureUpdateManyWithWhereWithoutRoomTypesInput[]
    deleteMany?: FurnitureScalarWhereInput | FurnitureScalarWhereInput[]
  }

  export type FurnitureUncheckedUpdateManyWithoutRoomTypesNestedInput = {
    create?: XOR<FurnitureCreateWithoutRoomTypesInput, FurnitureUncheckedCreateWithoutRoomTypesInput> | FurnitureCreateWithoutRoomTypesInput[] | FurnitureUncheckedCreateWithoutRoomTypesInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutRoomTypesInput | FurnitureCreateOrConnectWithoutRoomTypesInput[]
    upsert?: FurnitureUpsertWithWhereUniqueWithoutRoomTypesInput | FurnitureUpsertWithWhereUniqueWithoutRoomTypesInput[]
    createMany?: FurnitureCreateManyRoomTypesInputEnvelope
    set?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    disconnect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    delete?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    update?: FurnitureUpdateWithWhereUniqueWithoutRoomTypesInput | FurnitureUpdateWithWhereUniqueWithoutRoomTypesInput[]
    updateMany?: FurnitureUpdateManyWithWhereWithoutRoomTypesInput | FurnitureUpdateManyWithWhereWithoutRoomTypesInput[]
    deleteMany?: FurnitureScalarWhereInput | FurnitureScalarWhereInput[]
  }

  export type FurnitureCreateNestedManyWithoutFurnitureTypesInput = {
    create?: XOR<FurnitureCreateWithoutFurnitureTypesInput, FurnitureUncheckedCreateWithoutFurnitureTypesInput> | FurnitureCreateWithoutFurnitureTypesInput[] | FurnitureUncheckedCreateWithoutFurnitureTypesInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutFurnitureTypesInput | FurnitureCreateOrConnectWithoutFurnitureTypesInput[]
    createMany?: FurnitureCreateManyFurnitureTypesInputEnvelope
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
  }

  export type FurnitureUncheckedCreateNestedManyWithoutFurnitureTypesInput = {
    create?: XOR<FurnitureCreateWithoutFurnitureTypesInput, FurnitureUncheckedCreateWithoutFurnitureTypesInput> | FurnitureCreateWithoutFurnitureTypesInput[] | FurnitureUncheckedCreateWithoutFurnitureTypesInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutFurnitureTypesInput | FurnitureCreateOrConnectWithoutFurnitureTypesInput[]
    createMany?: FurnitureCreateManyFurnitureTypesInputEnvelope
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
  }

  export type FurnitureUpdateManyWithoutFurnitureTypesNestedInput = {
    create?: XOR<FurnitureCreateWithoutFurnitureTypesInput, FurnitureUncheckedCreateWithoutFurnitureTypesInput> | FurnitureCreateWithoutFurnitureTypesInput[] | FurnitureUncheckedCreateWithoutFurnitureTypesInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutFurnitureTypesInput | FurnitureCreateOrConnectWithoutFurnitureTypesInput[]
    upsert?: FurnitureUpsertWithWhereUniqueWithoutFurnitureTypesInput | FurnitureUpsertWithWhereUniqueWithoutFurnitureTypesInput[]
    createMany?: FurnitureCreateManyFurnitureTypesInputEnvelope
    set?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    disconnect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    delete?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    update?: FurnitureUpdateWithWhereUniqueWithoutFurnitureTypesInput | FurnitureUpdateWithWhereUniqueWithoutFurnitureTypesInput[]
    updateMany?: FurnitureUpdateManyWithWhereWithoutFurnitureTypesInput | FurnitureUpdateManyWithWhereWithoutFurnitureTypesInput[]
    deleteMany?: FurnitureScalarWhereInput | FurnitureScalarWhereInput[]
  }

  export type FurnitureUncheckedUpdateManyWithoutFurnitureTypesNestedInput = {
    create?: XOR<FurnitureCreateWithoutFurnitureTypesInput, FurnitureUncheckedCreateWithoutFurnitureTypesInput> | FurnitureCreateWithoutFurnitureTypesInput[] | FurnitureUncheckedCreateWithoutFurnitureTypesInput[]
    connectOrCreate?: FurnitureCreateOrConnectWithoutFurnitureTypesInput | FurnitureCreateOrConnectWithoutFurnitureTypesInput[]
    upsert?: FurnitureUpsertWithWhereUniqueWithoutFurnitureTypesInput | FurnitureUpsertWithWhereUniqueWithoutFurnitureTypesInput[]
    createMany?: FurnitureCreateManyFurnitureTypesInputEnvelope
    set?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    disconnect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    delete?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    connect?: FurnitureWhereUniqueInput | FurnitureWhereUniqueInput[]
    update?: FurnitureUpdateWithWhereUniqueWithoutFurnitureTypesInput | FurnitureUpdateWithWhereUniqueWithoutFurnitureTypesInput[]
    updateMany?: FurnitureUpdateManyWithWhereWithoutFurnitureTypesInput | FurnitureUpdateManyWithWhereWithoutFurnitureTypesInput[]
    deleteMany?: FurnitureScalarWhereInput | FurnitureScalarWhereInput[]
  }

  export type FurnitureCreateNestedOneWithoutFurniture_photosInput = {
    create?: XOR<FurnitureCreateWithoutFurniture_photosInput, FurnitureUncheckedCreateWithoutFurniture_photosInput>
    connectOrCreate?: FurnitureCreateOrConnectWithoutFurniture_photosInput
    connect?: FurnitureWhereUniqueInput
  }

  export type FurnitureUpdateOneWithoutFurniture_photosNestedInput = {
    create?: XOR<FurnitureCreateWithoutFurniture_photosInput, FurnitureUncheckedCreateWithoutFurniture_photosInput>
    connectOrCreate?: FurnitureCreateOrConnectWithoutFurniture_photosInput
    upsert?: FurnitureUpsertWithoutFurniture_photosInput
    disconnect?: FurnitureWhereInput | boolean
    delete?: FurnitureWhereInput | boolean
    connect?: FurnitureWhereUniqueInput
    update?: XOR<XOR<FurnitureUpdateToOneWithWhereWithoutFurniture_photosInput, FurnitureUpdateWithoutFurniture_photosInput>, FurnitureUncheckedUpdateWithoutFurniture_photosInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ColorsCreateNestedOneWithoutFurnitureInput = {
    create?: XOR<ColorsCreateWithoutFurnitureInput, ColorsUncheckedCreateWithoutFurnitureInput>
    connectOrCreate?: ColorsCreateOrConnectWithoutFurnitureInput
    connect?: ColorsWhereUniqueInput
  }

  export type MaterialsCreateNestedOneWithoutFurnitureInput = {
    create?: XOR<MaterialsCreateWithoutFurnitureInput, MaterialsUncheckedCreateWithoutFurnitureInput>
    connectOrCreate?: MaterialsCreateOrConnectWithoutFurnitureInput
    connect?: MaterialsWhereUniqueInput
  }

  export type RoomTypesCreateNestedOneWithoutFurnitureInput = {
    create?: XOR<RoomTypesCreateWithoutFurnitureInput, RoomTypesUncheckedCreateWithoutFurnitureInput>
    connectOrCreate?: RoomTypesCreateOrConnectWithoutFurnitureInput
    connect?: RoomTypesWhereUniqueInput
  }

  export type FurnitureTypesCreateNestedOneWithoutFurnitureInput = {
    create?: XOR<FurnitureTypesCreateWithoutFurnitureInput, FurnitureTypesUncheckedCreateWithoutFurnitureInput>
    connectOrCreate?: FurnitureTypesCreateOrConnectWithoutFurnitureInput
    connect?: FurnitureTypesWhereUniqueInput
  }

  export type FurniturePhotosCreateNestedManyWithoutFurnitureInput = {
    create?: XOR<FurniturePhotosCreateWithoutFurnitureInput, FurniturePhotosUncheckedCreateWithoutFurnitureInput> | FurniturePhotosCreateWithoutFurnitureInput[] | FurniturePhotosUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: FurniturePhotosCreateOrConnectWithoutFurnitureInput | FurniturePhotosCreateOrConnectWithoutFurnitureInput[]
    createMany?: FurniturePhotosCreateManyFurnitureInputEnvelope
    connect?: FurniturePhotosWhereUniqueInput | FurniturePhotosWhereUniqueInput[]
  }

  export type FurnitureCommentsCreateNestedManyWithoutFurnitureInput = {
    create?: XOR<FurnitureCommentsCreateWithoutFurnitureInput, FurnitureCommentsUncheckedCreateWithoutFurnitureInput> | FurnitureCommentsCreateWithoutFurnitureInput[] | FurnitureCommentsUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: FurnitureCommentsCreateOrConnectWithoutFurnitureInput | FurnitureCommentsCreateOrConnectWithoutFurnitureInput[]
    createMany?: FurnitureCommentsCreateManyFurnitureInputEnvelope
    connect?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
  }

  export type FurnitureLikesCreateNestedManyWithoutFurnitureInput = {
    create?: XOR<FurnitureLikesCreateWithoutFurnitureInput, FurnitureLikesUncheckedCreateWithoutFurnitureInput> | FurnitureLikesCreateWithoutFurnitureInput[] | FurnitureLikesUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: FurnitureLikesCreateOrConnectWithoutFurnitureInput | FurnitureLikesCreateOrConnectWithoutFurnitureInput[]
    createMany?: FurnitureLikesCreateManyFurnitureInputEnvelope
    connect?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
  }

  export type ContractsDetailingCreateNestedManyWithoutFurnitureInput = {
    create?: XOR<ContractsDetailingCreateWithoutFurnitureInput, ContractsDetailingUncheckedCreateWithoutFurnitureInput> | ContractsDetailingCreateWithoutFurnitureInput[] | ContractsDetailingUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: ContractsDetailingCreateOrConnectWithoutFurnitureInput | ContractsDetailingCreateOrConnectWithoutFurnitureInput[]
    createMany?: ContractsDetailingCreateManyFurnitureInputEnvelope
    connect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
  }

  export type FurniturePhotosUncheckedCreateNestedManyWithoutFurnitureInput = {
    create?: XOR<FurniturePhotosCreateWithoutFurnitureInput, FurniturePhotosUncheckedCreateWithoutFurnitureInput> | FurniturePhotosCreateWithoutFurnitureInput[] | FurniturePhotosUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: FurniturePhotosCreateOrConnectWithoutFurnitureInput | FurniturePhotosCreateOrConnectWithoutFurnitureInput[]
    createMany?: FurniturePhotosCreateManyFurnitureInputEnvelope
    connect?: FurniturePhotosWhereUniqueInput | FurniturePhotosWhereUniqueInput[]
  }

  export type FurnitureCommentsUncheckedCreateNestedManyWithoutFurnitureInput = {
    create?: XOR<FurnitureCommentsCreateWithoutFurnitureInput, FurnitureCommentsUncheckedCreateWithoutFurnitureInput> | FurnitureCommentsCreateWithoutFurnitureInput[] | FurnitureCommentsUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: FurnitureCommentsCreateOrConnectWithoutFurnitureInput | FurnitureCommentsCreateOrConnectWithoutFurnitureInput[]
    createMany?: FurnitureCommentsCreateManyFurnitureInputEnvelope
    connect?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
  }

  export type FurnitureLikesUncheckedCreateNestedManyWithoutFurnitureInput = {
    create?: XOR<FurnitureLikesCreateWithoutFurnitureInput, FurnitureLikesUncheckedCreateWithoutFurnitureInput> | FurnitureLikesCreateWithoutFurnitureInput[] | FurnitureLikesUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: FurnitureLikesCreateOrConnectWithoutFurnitureInput | FurnitureLikesCreateOrConnectWithoutFurnitureInput[]
    createMany?: FurnitureLikesCreateManyFurnitureInputEnvelope
    connect?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
  }

  export type ContractsDetailingUncheckedCreateNestedManyWithoutFurnitureInput = {
    create?: XOR<ContractsDetailingCreateWithoutFurnitureInput, ContractsDetailingUncheckedCreateWithoutFurnitureInput> | ContractsDetailingCreateWithoutFurnitureInput[] | ContractsDetailingUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: ContractsDetailingCreateOrConnectWithoutFurnitureInput | ContractsDetailingCreateOrConnectWithoutFurnitureInput[]
    createMany?: ContractsDetailingCreateManyFurnitureInputEnvelope
    connect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ColorsUpdateOneWithoutFurnitureNestedInput = {
    create?: XOR<ColorsCreateWithoutFurnitureInput, ColorsUncheckedCreateWithoutFurnitureInput>
    connectOrCreate?: ColorsCreateOrConnectWithoutFurnitureInput
    upsert?: ColorsUpsertWithoutFurnitureInput
    disconnect?: ColorsWhereInput | boolean
    delete?: ColorsWhereInput | boolean
    connect?: ColorsWhereUniqueInput
    update?: XOR<XOR<ColorsUpdateToOneWithWhereWithoutFurnitureInput, ColorsUpdateWithoutFurnitureInput>, ColorsUncheckedUpdateWithoutFurnitureInput>
  }

  export type MaterialsUpdateOneWithoutFurnitureNestedInput = {
    create?: XOR<MaterialsCreateWithoutFurnitureInput, MaterialsUncheckedCreateWithoutFurnitureInput>
    connectOrCreate?: MaterialsCreateOrConnectWithoutFurnitureInput
    upsert?: MaterialsUpsertWithoutFurnitureInput
    disconnect?: MaterialsWhereInput | boolean
    delete?: MaterialsWhereInput | boolean
    connect?: MaterialsWhereUniqueInput
    update?: XOR<XOR<MaterialsUpdateToOneWithWhereWithoutFurnitureInput, MaterialsUpdateWithoutFurnitureInput>, MaterialsUncheckedUpdateWithoutFurnitureInput>
  }

  export type RoomTypesUpdateOneWithoutFurnitureNestedInput = {
    create?: XOR<RoomTypesCreateWithoutFurnitureInput, RoomTypesUncheckedCreateWithoutFurnitureInput>
    connectOrCreate?: RoomTypesCreateOrConnectWithoutFurnitureInput
    upsert?: RoomTypesUpsertWithoutFurnitureInput
    disconnect?: RoomTypesWhereInput | boolean
    delete?: RoomTypesWhereInput | boolean
    connect?: RoomTypesWhereUniqueInput
    update?: XOR<XOR<RoomTypesUpdateToOneWithWhereWithoutFurnitureInput, RoomTypesUpdateWithoutFurnitureInput>, RoomTypesUncheckedUpdateWithoutFurnitureInput>
  }

  export type FurnitureTypesUpdateOneWithoutFurnitureNestedInput = {
    create?: XOR<FurnitureTypesCreateWithoutFurnitureInput, FurnitureTypesUncheckedCreateWithoutFurnitureInput>
    connectOrCreate?: FurnitureTypesCreateOrConnectWithoutFurnitureInput
    upsert?: FurnitureTypesUpsertWithoutFurnitureInput
    disconnect?: FurnitureTypesWhereInput | boolean
    delete?: FurnitureTypesWhereInput | boolean
    connect?: FurnitureTypesWhereUniqueInput
    update?: XOR<XOR<FurnitureTypesUpdateToOneWithWhereWithoutFurnitureInput, FurnitureTypesUpdateWithoutFurnitureInput>, FurnitureTypesUncheckedUpdateWithoutFurnitureInput>
  }

  export type FurniturePhotosUpdateManyWithoutFurnitureNestedInput = {
    create?: XOR<FurniturePhotosCreateWithoutFurnitureInput, FurniturePhotosUncheckedCreateWithoutFurnitureInput> | FurniturePhotosCreateWithoutFurnitureInput[] | FurniturePhotosUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: FurniturePhotosCreateOrConnectWithoutFurnitureInput | FurniturePhotosCreateOrConnectWithoutFurnitureInput[]
    upsert?: FurniturePhotosUpsertWithWhereUniqueWithoutFurnitureInput | FurniturePhotosUpsertWithWhereUniqueWithoutFurnitureInput[]
    createMany?: FurniturePhotosCreateManyFurnitureInputEnvelope
    set?: FurniturePhotosWhereUniqueInput | FurniturePhotosWhereUniqueInput[]
    disconnect?: FurniturePhotosWhereUniqueInput | FurniturePhotosWhereUniqueInput[]
    delete?: FurniturePhotosWhereUniqueInput | FurniturePhotosWhereUniqueInput[]
    connect?: FurniturePhotosWhereUniqueInput | FurniturePhotosWhereUniqueInput[]
    update?: FurniturePhotosUpdateWithWhereUniqueWithoutFurnitureInput | FurniturePhotosUpdateWithWhereUniqueWithoutFurnitureInput[]
    updateMany?: FurniturePhotosUpdateManyWithWhereWithoutFurnitureInput | FurniturePhotosUpdateManyWithWhereWithoutFurnitureInput[]
    deleteMany?: FurniturePhotosScalarWhereInput | FurniturePhotosScalarWhereInput[]
  }

  export type FurnitureCommentsUpdateManyWithoutFurnitureNestedInput = {
    create?: XOR<FurnitureCommentsCreateWithoutFurnitureInput, FurnitureCommentsUncheckedCreateWithoutFurnitureInput> | FurnitureCommentsCreateWithoutFurnitureInput[] | FurnitureCommentsUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: FurnitureCommentsCreateOrConnectWithoutFurnitureInput | FurnitureCommentsCreateOrConnectWithoutFurnitureInput[]
    upsert?: FurnitureCommentsUpsertWithWhereUniqueWithoutFurnitureInput | FurnitureCommentsUpsertWithWhereUniqueWithoutFurnitureInput[]
    createMany?: FurnitureCommentsCreateManyFurnitureInputEnvelope
    set?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    disconnect?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    delete?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    connect?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    update?: FurnitureCommentsUpdateWithWhereUniqueWithoutFurnitureInput | FurnitureCommentsUpdateWithWhereUniqueWithoutFurnitureInput[]
    updateMany?: FurnitureCommentsUpdateManyWithWhereWithoutFurnitureInput | FurnitureCommentsUpdateManyWithWhereWithoutFurnitureInput[]
    deleteMany?: FurnitureCommentsScalarWhereInput | FurnitureCommentsScalarWhereInput[]
  }

  export type FurnitureLikesUpdateManyWithoutFurnitureNestedInput = {
    create?: XOR<FurnitureLikesCreateWithoutFurnitureInput, FurnitureLikesUncheckedCreateWithoutFurnitureInput> | FurnitureLikesCreateWithoutFurnitureInput[] | FurnitureLikesUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: FurnitureLikesCreateOrConnectWithoutFurnitureInput | FurnitureLikesCreateOrConnectWithoutFurnitureInput[]
    upsert?: FurnitureLikesUpsertWithWhereUniqueWithoutFurnitureInput | FurnitureLikesUpsertWithWhereUniqueWithoutFurnitureInput[]
    createMany?: FurnitureLikesCreateManyFurnitureInputEnvelope
    set?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    disconnect?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    delete?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    connect?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    update?: FurnitureLikesUpdateWithWhereUniqueWithoutFurnitureInput | FurnitureLikesUpdateWithWhereUniqueWithoutFurnitureInput[]
    updateMany?: FurnitureLikesUpdateManyWithWhereWithoutFurnitureInput | FurnitureLikesUpdateManyWithWhereWithoutFurnitureInput[]
    deleteMany?: FurnitureLikesScalarWhereInput | FurnitureLikesScalarWhereInput[]
  }

  export type ContractsDetailingUpdateManyWithoutFurnitureNestedInput = {
    create?: XOR<ContractsDetailingCreateWithoutFurnitureInput, ContractsDetailingUncheckedCreateWithoutFurnitureInput> | ContractsDetailingCreateWithoutFurnitureInput[] | ContractsDetailingUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: ContractsDetailingCreateOrConnectWithoutFurnitureInput | ContractsDetailingCreateOrConnectWithoutFurnitureInput[]
    upsert?: ContractsDetailingUpsertWithWhereUniqueWithoutFurnitureInput | ContractsDetailingUpsertWithWhereUniqueWithoutFurnitureInput[]
    createMany?: ContractsDetailingCreateManyFurnitureInputEnvelope
    set?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    disconnect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    delete?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    connect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    update?: ContractsDetailingUpdateWithWhereUniqueWithoutFurnitureInput | ContractsDetailingUpdateWithWhereUniqueWithoutFurnitureInput[]
    updateMany?: ContractsDetailingUpdateManyWithWhereWithoutFurnitureInput | ContractsDetailingUpdateManyWithWhereWithoutFurnitureInput[]
    deleteMany?: ContractsDetailingScalarWhereInput | ContractsDetailingScalarWhereInput[]
  }

  export type FurniturePhotosUncheckedUpdateManyWithoutFurnitureNestedInput = {
    create?: XOR<FurniturePhotosCreateWithoutFurnitureInput, FurniturePhotosUncheckedCreateWithoutFurnitureInput> | FurniturePhotosCreateWithoutFurnitureInput[] | FurniturePhotosUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: FurniturePhotosCreateOrConnectWithoutFurnitureInput | FurniturePhotosCreateOrConnectWithoutFurnitureInput[]
    upsert?: FurniturePhotosUpsertWithWhereUniqueWithoutFurnitureInput | FurniturePhotosUpsertWithWhereUniqueWithoutFurnitureInput[]
    createMany?: FurniturePhotosCreateManyFurnitureInputEnvelope
    set?: FurniturePhotosWhereUniqueInput | FurniturePhotosWhereUniqueInput[]
    disconnect?: FurniturePhotosWhereUniqueInput | FurniturePhotosWhereUniqueInput[]
    delete?: FurniturePhotosWhereUniqueInput | FurniturePhotosWhereUniqueInput[]
    connect?: FurniturePhotosWhereUniqueInput | FurniturePhotosWhereUniqueInput[]
    update?: FurniturePhotosUpdateWithWhereUniqueWithoutFurnitureInput | FurniturePhotosUpdateWithWhereUniqueWithoutFurnitureInput[]
    updateMany?: FurniturePhotosUpdateManyWithWhereWithoutFurnitureInput | FurniturePhotosUpdateManyWithWhereWithoutFurnitureInput[]
    deleteMany?: FurniturePhotosScalarWhereInput | FurniturePhotosScalarWhereInput[]
  }

  export type FurnitureCommentsUncheckedUpdateManyWithoutFurnitureNestedInput = {
    create?: XOR<FurnitureCommentsCreateWithoutFurnitureInput, FurnitureCommentsUncheckedCreateWithoutFurnitureInput> | FurnitureCommentsCreateWithoutFurnitureInput[] | FurnitureCommentsUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: FurnitureCommentsCreateOrConnectWithoutFurnitureInput | FurnitureCommentsCreateOrConnectWithoutFurnitureInput[]
    upsert?: FurnitureCommentsUpsertWithWhereUniqueWithoutFurnitureInput | FurnitureCommentsUpsertWithWhereUniqueWithoutFurnitureInput[]
    createMany?: FurnitureCommentsCreateManyFurnitureInputEnvelope
    set?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    disconnect?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    delete?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    connect?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    update?: FurnitureCommentsUpdateWithWhereUniqueWithoutFurnitureInput | FurnitureCommentsUpdateWithWhereUniqueWithoutFurnitureInput[]
    updateMany?: FurnitureCommentsUpdateManyWithWhereWithoutFurnitureInput | FurnitureCommentsUpdateManyWithWhereWithoutFurnitureInput[]
    deleteMany?: FurnitureCommentsScalarWhereInput | FurnitureCommentsScalarWhereInput[]
  }

  export type FurnitureLikesUncheckedUpdateManyWithoutFurnitureNestedInput = {
    create?: XOR<FurnitureLikesCreateWithoutFurnitureInput, FurnitureLikesUncheckedCreateWithoutFurnitureInput> | FurnitureLikesCreateWithoutFurnitureInput[] | FurnitureLikesUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: FurnitureLikesCreateOrConnectWithoutFurnitureInput | FurnitureLikesCreateOrConnectWithoutFurnitureInput[]
    upsert?: FurnitureLikesUpsertWithWhereUniqueWithoutFurnitureInput | FurnitureLikesUpsertWithWhereUniqueWithoutFurnitureInput[]
    createMany?: FurnitureLikesCreateManyFurnitureInputEnvelope
    set?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    disconnect?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    delete?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    connect?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    update?: FurnitureLikesUpdateWithWhereUniqueWithoutFurnitureInput | FurnitureLikesUpdateWithWhereUniqueWithoutFurnitureInput[]
    updateMany?: FurnitureLikesUpdateManyWithWhereWithoutFurnitureInput | FurnitureLikesUpdateManyWithWhereWithoutFurnitureInput[]
    deleteMany?: FurnitureLikesScalarWhereInput | FurnitureLikesScalarWhereInput[]
  }

  export type ContractsDetailingUncheckedUpdateManyWithoutFurnitureNestedInput = {
    create?: XOR<ContractsDetailingCreateWithoutFurnitureInput, ContractsDetailingUncheckedCreateWithoutFurnitureInput> | ContractsDetailingCreateWithoutFurnitureInput[] | ContractsDetailingUncheckedCreateWithoutFurnitureInput[]
    connectOrCreate?: ContractsDetailingCreateOrConnectWithoutFurnitureInput | ContractsDetailingCreateOrConnectWithoutFurnitureInput[]
    upsert?: ContractsDetailingUpsertWithWhereUniqueWithoutFurnitureInput | ContractsDetailingUpsertWithWhereUniqueWithoutFurnitureInput[]
    createMany?: ContractsDetailingCreateManyFurnitureInputEnvelope
    set?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    disconnect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    delete?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    connect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    update?: ContractsDetailingUpdateWithWhereUniqueWithoutFurnitureInput | ContractsDetailingUpdateWithWhereUniqueWithoutFurnitureInput[]
    updateMany?: ContractsDetailingUpdateManyWithWhereWithoutFurnitureInput | ContractsDetailingUpdateManyWithWhereWithoutFurnitureInput[]
    deleteMany?: ContractsDetailingScalarWhereInput | ContractsDetailingScalarWhereInput[]
  }

  export type FurnitureCommentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<FurnitureCommentsCreateWithoutUsersInput, FurnitureCommentsUncheckedCreateWithoutUsersInput> | FurnitureCommentsCreateWithoutUsersInput[] | FurnitureCommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FurnitureCommentsCreateOrConnectWithoutUsersInput | FurnitureCommentsCreateOrConnectWithoutUsersInput[]
    createMany?: FurnitureCommentsCreateManyUsersInputEnvelope
    connect?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
  }

  export type FurnitureLikesCreateNestedManyWithoutUsersInput = {
    create?: XOR<FurnitureLikesCreateWithoutUsersInput, FurnitureLikesUncheckedCreateWithoutUsersInput> | FurnitureLikesCreateWithoutUsersInput[] | FurnitureLikesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FurnitureLikesCreateOrConnectWithoutUsersInput | FurnitureLikesCreateOrConnectWithoutUsersInput[]
    createMany?: FurnitureLikesCreateManyUsersInputEnvelope
    connect?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
  }

  export type UserCardCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserCardCreateWithoutUsersInput, UserCardUncheckedCreateWithoutUsersInput> | UserCardCreateWithoutUsersInput[] | UserCardUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutUsersInput | UserCardCreateOrConnectWithoutUsersInput[]
    createMany?: UserCardCreateManyUsersInputEnvelope
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
  }

  export type UserAddressCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserAddressCreateWithoutUsersInput, UserAddressUncheckedCreateWithoutUsersInput> | UserAddressCreateWithoutUsersInput[] | UserAddressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUsersInput | UserAddressCreateOrConnectWithoutUsersInput[]
    createMany?: UserAddressCreateManyUsersInputEnvelope
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUsersInput = {
    create?: XOR<PaymentCreateWithoutUsersInput, PaymentUncheckedCreateWithoutUsersInput> | PaymentCreateWithoutUsersInput[] | PaymentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUsersInput | PaymentCreateOrConnectWithoutUsersInput[]
    createMany?: PaymentCreateManyUsersInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ContractsCreateNestedManyWithoutUsersInput = {
    create?: XOR<ContractsCreateWithoutUsersInput, ContractsUncheckedCreateWithoutUsersInput> | ContractsCreateWithoutUsersInput[] | ContractsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ContractsCreateOrConnectWithoutUsersInput | ContractsCreateOrConnectWithoutUsersInput[]
    createMany?: ContractsCreateManyUsersInputEnvelope
    connect?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
  }

  export type ContractsDetailingCreateNestedManyWithoutUsersInput = {
    create?: XOR<ContractsDetailingCreateWithoutUsersInput, ContractsDetailingUncheckedCreateWithoutUsersInput> | ContractsDetailingCreateWithoutUsersInput[] | ContractsDetailingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ContractsDetailingCreateOrConnectWithoutUsersInput | ContractsDetailingCreateOrConnectWithoutUsersInput[]
    createMany?: ContractsDetailingCreateManyUsersInputEnvelope
    connect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
  }

  export type FurnitureCommentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<FurnitureCommentsCreateWithoutUsersInput, FurnitureCommentsUncheckedCreateWithoutUsersInput> | FurnitureCommentsCreateWithoutUsersInput[] | FurnitureCommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FurnitureCommentsCreateOrConnectWithoutUsersInput | FurnitureCommentsCreateOrConnectWithoutUsersInput[]
    createMany?: FurnitureCommentsCreateManyUsersInputEnvelope
    connect?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
  }

  export type FurnitureLikesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<FurnitureLikesCreateWithoutUsersInput, FurnitureLikesUncheckedCreateWithoutUsersInput> | FurnitureLikesCreateWithoutUsersInput[] | FurnitureLikesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FurnitureLikesCreateOrConnectWithoutUsersInput | FurnitureLikesCreateOrConnectWithoutUsersInput[]
    createMany?: FurnitureLikesCreateManyUsersInputEnvelope
    connect?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
  }

  export type UserCardUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserCardCreateWithoutUsersInput, UserCardUncheckedCreateWithoutUsersInput> | UserCardCreateWithoutUsersInput[] | UserCardUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutUsersInput | UserCardCreateOrConnectWithoutUsersInput[]
    createMany?: UserCardCreateManyUsersInputEnvelope
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
  }

  export type UserAddressUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserAddressCreateWithoutUsersInput, UserAddressUncheckedCreateWithoutUsersInput> | UserAddressCreateWithoutUsersInput[] | UserAddressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUsersInput | UserAddressCreateOrConnectWithoutUsersInput[]
    createMany?: UserAddressCreateManyUsersInputEnvelope
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<PaymentCreateWithoutUsersInput, PaymentUncheckedCreateWithoutUsersInput> | PaymentCreateWithoutUsersInput[] | PaymentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUsersInput | PaymentCreateOrConnectWithoutUsersInput[]
    createMany?: PaymentCreateManyUsersInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ContractsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ContractsCreateWithoutUsersInput, ContractsUncheckedCreateWithoutUsersInput> | ContractsCreateWithoutUsersInput[] | ContractsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ContractsCreateOrConnectWithoutUsersInput | ContractsCreateOrConnectWithoutUsersInput[]
    createMany?: ContractsCreateManyUsersInputEnvelope
    connect?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
  }

  export type ContractsDetailingUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ContractsDetailingCreateWithoutUsersInput, ContractsDetailingUncheckedCreateWithoutUsersInput> | ContractsDetailingCreateWithoutUsersInput[] | ContractsDetailingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ContractsDetailingCreateOrConnectWithoutUsersInput | ContractsDetailingCreateOrConnectWithoutUsersInput[]
    createMany?: ContractsDetailingCreateManyUsersInputEnvelope
    connect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FurnitureCommentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FurnitureCommentsCreateWithoutUsersInput, FurnitureCommentsUncheckedCreateWithoutUsersInput> | FurnitureCommentsCreateWithoutUsersInput[] | FurnitureCommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FurnitureCommentsCreateOrConnectWithoutUsersInput | FurnitureCommentsCreateOrConnectWithoutUsersInput[]
    upsert?: FurnitureCommentsUpsertWithWhereUniqueWithoutUsersInput | FurnitureCommentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FurnitureCommentsCreateManyUsersInputEnvelope
    set?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    disconnect?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    delete?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    connect?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    update?: FurnitureCommentsUpdateWithWhereUniqueWithoutUsersInput | FurnitureCommentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FurnitureCommentsUpdateManyWithWhereWithoutUsersInput | FurnitureCommentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FurnitureCommentsScalarWhereInput | FurnitureCommentsScalarWhereInput[]
  }

  export type FurnitureLikesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FurnitureLikesCreateWithoutUsersInput, FurnitureLikesUncheckedCreateWithoutUsersInput> | FurnitureLikesCreateWithoutUsersInput[] | FurnitureLikesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FurnitureLikesCreateOrConnectWithoutUsersInput | FurnitureLikesCreateOrConnectWithoutUsersInput[]
    upsert?: FurnitureLikesUpsertWithWhereUniqueWithoutUsersInput | FurnitureLikesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FurnitureLikesCreateManyUsersInputEnvelope
    set?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    disconnect?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    delete?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    connect?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    update?: FurnitureLikesUpdateWithWhereUniqueWithoutUsersInput | FurnitureLikesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FurnitureLikesUpdateManyWithWhereWithoutUsersInput | FurnitureLikesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FurnitureLikesScalarWhereInput | FurnitureLikesScalarWhereInput[]
  }

  export type UserCardUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserCardCreateWithoutUsersInput, UserCardUncheckedCreateWithoutUsersInput> | UserCardCreateWithoutUsersInput[] | UserCardUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutUsersInput | UserCardCreateOrConnectWithoutUsersInput[]
    upsert?: UserCardUpsertWithWhereUniqueWithoutUsersInput | UserCardUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserCardCreateManyUsersInputEnvelope
    set?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    disconnect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    delete?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    update?: UserCardUpdateWithWhereUniqueWithoutUsersInput | UserCardUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserCardUpdateManyWithWhereWithoutUsersInput | UserCardUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
  }

  export type UserAddressUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserAddressCreateWithoutUsersInput, UserAddressUncheckedCreateWithoutUsersInput> | UserAddressCreateWithoutUsersInput[] | UserAddressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUsersInput | UserAddressCreateOrConnectWithoutUsersInput[]
    upsert?: UserAddressUpsertWithWhereUniqueWithoutUsersInput | UserAddressUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserAddressCreateManyUsersInputEnvelope
    set?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    disconnect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    delete?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    update?: UserAddressUpdateWithWhereUniqueWithoutUsersInput | UserAddressUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserAddressUpdateManyWithWhereWithoutUsersInput | UserAddressUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PaymentCreateWithoutUsersInput, PaymentUncheckedCreateWithoutUsersInput> | PaymentCreateWithoutUsersInput[] | PaymentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUsersInput | PaymentCreateOrConnectWithoutUsersInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUsersInput | PaymentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PaymentCreateManyUsersInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUsersInput | PaymentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUsersInput | PaymentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ContractsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ContractsCreateWithoutUsersInput, ContractsUncheckedCreateWithoutUsersInput> | ContractsCreateWithoutUsersInput[] | ContractsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ContractsCreateOrConnectWithoutUsersInput | ContractsCreateOrConnectWithoutUsersInput[]
    upsert?: ContractsUpsertWithWhereUniqueWithoutUsersInput | ContractsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ContractsCreateManyUsersInputEnvelope
    set?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    disconnect?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    delete?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    connect?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    update?: ContractsUpdateWithWhereUniqueWithoutUsersInput | ContractsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ContractsUpdateManyWithWhereWithoutUsersInput | ContractsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ContractsScalarWhereInput | ContractsScalarWhereInput[]
  }

  export type ContractsDetailingUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ContractsDetailingCreateWithoutUsersInput, ContractsDetailingUncheckedCreateWithoutUsersInput> | ContractsDetailingCreateWithoutUsersInput[] | ContractsDetailingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ContractsDetailingCreateOrConnectWithoutUsersInput | ContractsDetailingCreateOrConnectWithoutUsersInput[]
    upsert?: ContractsDetailingUpsertWithWhereUniqueWithoutUsersInput | ContractsDetailingUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ContractsDetailingCreateManyUsersInputEnvelope
    set?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    disconnect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    delete?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    connect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    update?: ContractsDetailingUpdateWithWhereUniqueWithoutUsersInput | ContractsDetailingUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ContractsDetailingUpdateManyWithWhereWithoutUsersInput | ContractsDetailingUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ContractsDetailingScalarWhereInput | ContractsDetailingScalarWhereInput[]
  }

  export type FurnitureCommentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FurnitureCommentsCreateWithoutUsersInput, FurnitureCommentsUncheckedCreateWithoutUsersInput> | FurnitureCommentsCreateWithoutUsersInput[] | FurnitureCommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FurnitureCommentsCreateOrConnectWithoutUsersInput | FurnitureCommentsCreateOrConnectWithoutUsersInput[]
    upsert?: FurnitureCommentsUpsertWithWhereUniqueWithoutUsersInput | FurnitureCommentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FurnitureCommentsCreateManyUsersInputEnvelope
    set?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    disconnect?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    delete?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    connect?: FurnitureCommentsWhereUniqueInput | FurnitureCommentsWhereUniqueInput[]
    update?: FurnitureCommentsUpdateWithWhereUniqueWithoutUsersInput | FurnitureCommentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FurnitureCommentsUpdateManyWithWhereWithoutUsersInput | FurnitureCommentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FurnitureCommentsScalarWhereInput | FurnitureCommentsScalarWhereInput[]
  }

  export type FurnitureLikesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FurnitureLikesCreateWithoutUsersInput, FurnitureLikesUncheckedCreateWithoutUsersInput> | FurnitureLikesCreateWithoutUsersInput[] | FurnitureLikesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FurnitureLikesCreateOrConnectWithoutUsersInput | FurnitureLikesCreateOrConnectWithoutUsersInput[]
    upsert?: FurnitureLikesUpsertWithWhereUniqueWithoutUsersInput | FurnitureLikesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FurnitureLikesCreateManyUsersInputEnvelope
    set?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    disconnect?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    delete?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    connect?: FurnitureLikesWhereUniqueInput | FurnitureLikesWhereUniqueInput[]
    update?: FurnitureLikesUpdateWithWhereUniqueWithoutUsersInput | FurnitureLikesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FurnitureLikesUpdateManyWithWhereWithoutUsersInput | FurnitureLikesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FurnitureLikesScalarWhereInput | FurnitureLikesScalarWhereInput[]
  }

  export type UserCardUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserCardCreateWithoutUsersInput, UserCardUncheckedCreateWithoutUsersInput> | UserCardCreateWithoutUsersInput[] | UserCardUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutUsersInput | UserCardCreateOrConnectWithoutUsersInput[]
    upsert?: UserCardUpsertWithWhereUniqueWithoutUsersInput | UserCardUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserCardCreateManyUsersInputEnvelope
    set?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    disconnect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    delete?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    update?: UserCardUpdateWithWhereUniqueWithoutUsersInput | UserCardUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserCardUpdateManyWithWhereWithoutUsersInput | UserCardUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
  }

  export type UserAddressUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserAddressCreateWithoutUsersInput, UserAddressUncheckedCreateWithoutUsersInput> | UserAddressCreateWithoutUsersInput[] | UserAddressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUsersInput | UserAddressCreateOrConnectWithoutUsersInput[]
    upsert?: UserAddressUpsertWithWhereUniqueWithoutUsersInput | UserAddressUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserAddressCreateManyUsersInputEnvelope
    set?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    disconnect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    delete?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    update?: UserAddressUpdateWithWhereUniqueWithoutUsersInput | UserAddressUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserAddressUpdateManyWithWhereWithoutUsersInput | UserAddressUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PaymentCreateWithoutUsersInput, PaymentUncheckedCreateWithoutUsersInput> | PaymentCreateWithoutUsersInput[] | PaymentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUsersInput | PaymentCreateOrConnectWithoutUsersInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUsersInput | PaymentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PaymentCreateManyUsersInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUsersInput | PaymentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUsersInput | PaymentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ContractsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ContractsCreateWithoutUsersInput, ContractsUncheckedCreateWithoutUsersInput> | ContractsCreateWithoutUsersInput[] | ContractsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ContractsCreateOrConnectWithoutUsersInput | ContractsCreateOrConnectWithoutUsersInput[]
    upsert?: ContractsUpsertWithWhereUniqueWithoutUsersInput | ContractsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ContractsCreateManyUsersInputEnvelope
    set?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    disconnect?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    delete?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    connect?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    update?: ContractsUpdateWithWhereUniqueWithoutUsersInput | ContractsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ContractsUpdateManyWithWhereWithoutUsersInput | ContractsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ContractsScalarWhereInput | ContractsScalarWhereInput[]
  }

  export type ContractsDetailingUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ContractsDetailingCreateWithoutUsersInput, ContractsDetailingUncheckedCreateWithoutUsersInput> | ContractsDetailingCreateWithoutUsersInput[] | ContractsDetailingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ContractsDetailingCreateOrConnectWithoutUsersInput | ContractsDetailingCreateOrConnectWithoutUsersInput[]
    upsert?: ContractsDetailingUpsertWithWhereUniqueWithoutUsersInput | ContractsDetailingUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ContractsDetailingCreateManyUsersInputEnvelope
    set?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    disconnect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    delete?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    connect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    update?: ContractsDetailingUpdateWithWhereUniqueWithoutUsersInput | ContractsDetailingUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ContractsDetailingUpdateManyWithWhereWithoutUsersInput | ContractsDetailingUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ContractsDetailingScalarWhereInput | ContractsDetailingScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutFurniture_commentsInput = {
    create?: XOR<UsersCreateWithoutFurniture_commentsInput, UsersUncheckedCreateWithoutFurniture_commentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFurniture_commentsInput
    connect?: UsersWhereUniqueInput
  }

  export type FurnitureCreateNestedOneWithoutFurniture_commentsInput = {
    create?: XOR<FurnitureCreateWithoutFurniture_commentsInput, FurnitureUncheckedCreateWithoutFurniture_commentsInput>
    connectOrCreate?: FurnitureCreateOrConnectWithoutFurniture_commentsInput
    connect?: FurnitureWhereUniqueInput
  }

  export type UsersUpdateOneWithoutFurniture_commentsNestedInput = {
    create?: XOR<UsersCreateWithoutFurniture_commentsInput, UsersUncheckedCreateWithoutFurniture_commentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFurniture_commentsInput
    upsert?: UsersUpsertWithoutFurniture_commentsInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFurniture_commentsInput, UsersUpdateWithoutFurniture_commentsInput>, UsersUncheckedUpdateWithoutFurniture_commentsInput>
  }

  export type FurnitureUpdateOneWithoutFurniture_commentsNestedInput = {
    create?: XOR<FurnitureCreateWithoutFurniture_commentsInput, FurnitureUncheckedCreateWithoutFurniture_commentsInput>
    connectOrCreate?: FurnitureCreateOrConnectWithoutFurniture_commentsInput
    upsert?: FurnitureUpsertWithoutFurniture_commentsInput
    disconnect?: FurnitureWhereInput | boolean
    delete?: FurnitureWhereInput | boolean
    connect?: FurnitureWhereUniqueInput
    update?: XOR<XOR<FurnitureUpdateToOneWithWhereWithoutFurniture_commentsInput, FurnitureUpdateWithoutFurniture_commentsInput>, FurnitureUncheckedUpdateWithoutFurniture_commentsInput>
  }

  export type UsersCreateNestedOneWithoutFurniture_likesInput = {
    create?: XOR<UsersCreateWithoutFurniture_likesInput, UsersUncheckedCreateWithoutFurniture_likesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFurniture_likesInput
    connect?: UsersWhereUniqueInput
  }

  export type FurnitureCreateNestedOneWithoutFurniture_likesInput = {
    create?: XOR<FurnitureCreateWithoutFurniture_likesInput, FurnitureUncheckedCreateWithoutFurniture_likesInput>
    connectOrCreate?: FurnitureCreateOrConnectWithoutFurniture_likesInput
    connect?: FurnitureWhereUniqueInput
  }

  export type UsersUpdateOneWithoutFurniture_likesNestedInput = {
    create?: XOR<UsersCreateWithoutFurniture_likesInput, UsersUncheckedCreateWithoutFurniture_likesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFurniture_likesInput
    upsert?: UsersUpsertWithoutFurniture_likesInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFurniture_likesInput, UsersUpdateWithoutFurniture_likesInput>, UsersUncheckedUpdateWithoutFurniture_likesInput>
  }

  export type FurnitureUpdateOneWithoutFurniture_likesNestedInput = {
    create?: XOR<FurnitureCreateWithoutFurniture_likesInput, FurnitureUncheckedCreateWithoutFurniture_likesInput>
    connectOrCreate?: FurnitureCreateOrConnectWithoutFurniture_likesInput
    upsert?: FurnitureUpsertWithoutFurniture_likesInput
    disconnect?: FurnitureWhereInput | boolean
    delete?: FurnitureWhereInput | boolean
    connect?: FurnitureWhereUniqueInput
    update?: XOR<XOR<FurnitureUpdateToOneWithWhereWithoutFurniture_likesInput, FurnitureUpdateWithoutFurniture_likesInput>, FurnitureUncheckedUpdateWithoutFurniture_likesInput>
  }

  export type AdminRolesCreateNestedManyWithoutAdminsInput = {
    create?: XOR<AdminRolesCreateWithoutAdminsInput, AdminRolesUncheckedCreateWithoutAdminsInput> | AdminRolesCreateWithoutAdminsInput[] | AdminRolesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: AdminRolesCreateOrConnectWithoutAdminsInput | AdminRolesCreateOrConnectWithoutAdminsInput[]
    createMany?: AdminRolesCreateManyAdminsInputEnvelope
    connect?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
  }

  export type AdminRolesUncheckedCreateNestedManyWithoutAdminsInput = {
    create?: XOR<AdminRolesCreateWithoutAdminsInput, AdminRolesUncheckedCreateWithoutAdminsInput> | AdminRolesCreateWithoutAdminsInput[] | AdminRolesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: AdminRolesCreateOrConnectWithoutAdminsInput | AdminRolesCreateOrConnectWithoutAdminsInput[]
    createMany?: AdminRolesCreateManyAdminsInputEnvelope
    connect?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
  }

  export type AdminRolesUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<AdminRolesCreateWithoutAdminsInput, AdminRolesUncheckedCreateWithoutAdminsInput> | AdminRolesCreateWithoutAdminsInput[] | AdminRolesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: AdminRolesCreateOrConnectWithoutAdminsInput | AdminRolesCreateOrConnectWithoutAdminsInput[]
    upsert?: AdminRolesUpsertWithWhereUniqueWithoutAdminsInput | AdminRolesUpsertWithWhereUniqueWithoutAdminsInput[]
    createMany?: AdminRolesCreateManyAdminsInputEnvelope
    set?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    disconnect?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    delete?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    connect?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    update?: AdminRolesUpdateWithWhereUniqueWithoutAdminsInput | AdminRolesUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: AdminRolesUpdateManyWithWhereWithoutAdminsInput | AdminRolesUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: AdminRolesScalarWhereInput | AdminRolesScalarWhereInput[]
  }

  export type AdminRolesUncheckedUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<AdminRolesCreateWithoutAdminsInput, AdminRolesUncheckedCreateWithoutAdminsInput> | AdminRolesCreateWithoutAdminsInput[] | AdminRolesUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: AdminRolesCreateOrConnectWithoutAdminsInput | AdminRolesCreateOrConnectWithoutAdminsInput[]
    upsert?: AdminRolesUpsertWithWhereUniqueWithoutAdminsInput | AdminRolesUpsertWithWhereUniqueWithoutAdminsInput[]
    createMany?: AdminRolesCreateManyAdminsInputEnvelope
    set?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    disconnect?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    delete?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    connect?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    update?: AdminRolesUpdateWithWhereUniqueWithoutAdminsInput | AdminRolesUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: AdminRolesUpdateManyWithWhereWithoutAdminsInput | AdminRolesUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: AdminRolesScalarWhereInput | AdminRolesScalarWhereInput[]
  }

  export type AdminRolesCreateNestedManyWithoutRolesInput = {
    create?: XOR<AdminRolesCreateWithoutRolesInput, AdminRolesUncheckedCreateWithoutRolesInput> | AdminRolesCreateWithoutRolesInput[] | AdminRolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: AdminRolesCreateOrConnectWithoutRolesInput | AdminRolesCreateOrConnectWithoutRolesInput[]
    createMany?: AdminRolesCreateManyRolesInputEnvelope
    connect?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
  }

  export type AdminRolesUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<AdminRolesCreateWithoutRolesInput, AdminRolesUncheckedCreateWithoutRolesInput> | AdminRolesCreateWithoutRolesInput[] | AdminRolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: AdminRolesCreateOrConnectWithoutRolesInput | AdminRolesCreateOrConnectWithoutRolesInput[]
    createMany?: AdminRolesCreateManyRolesInputEnvelope
    connect?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
  }

  export type AdminRolesUpdateManyWithoutRolesNestedInput = {
    create?: XOR<AdminRolesCreateWithoutRolesInput, AdminRolesUncheckedCreateWithoutRolesInput> | AdminRolesCreateWithoutRolesInput[] | AdminRolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: AdminRolesCreateOrConnectWithoutRolesInput | AdminRolesCreateOrConnectWithoutRolesInput[]
    upsert?: AdminRolesUpsertWithWhereUniqueWithoutRolesInput | AdminRolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: AdminRolesCreateManyRolesInputEnvelope
    set?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    disconnect?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    delete?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    connect?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    update?: AdminRolesUpdateWithWhereUniqueWithoutRolesInput | AdminRolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: AdminRolesUpdateManyWithWhereWithoutRolesInput | AdminRolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: AdminRolesScalarWhereInput | AdminRolesScalarWhereInput[]
  }

  export type AdminRolesUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<AdminRolesCreateWithoutRolesInput, AdminRolesUncheckedCreateWithoutRolesInput> | AdminRolesCreateWithoutRolesInput[] | AdminRolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: AdminRolesCreateOrConnectWithoutRolesInput | AdminRolesCreateOrConnectWithoutRolesInput[]
    upsert?: AdminRolesUpsertWithWhereUniqueWithoutRolesInput | AdminRolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: AdminRolesCreateManyRolesInputEnvelope
    set?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    disconnect?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    delete?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    connect?: AdminRolesWhereUniqueInput | AdminRolesWhereUniqueInput[]
    update?: AdminRolesUpdateWithWhereUniqueWithoutRolesInput | AdminRolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: AdminRolesUpdateManyWithWhereWithoutRolesInput | AdminRolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: AdminRolesScalarWhereInput | AdminRolesScalarWhereInput[]
  }

  export type AdminsCreateNestedOneWithoutAdmin_rolesInput = {
    create?: XOR<AdminsCreateWithoutAdmin_rolesInput, AdminsUncheckedCreateWithoutAdmin_rolesInput>
    connectOrCreate?: AdminsCreateOrConnectWithoutAdmin_rolesInput
    connect?: AdminsWhereUniqueInput
  }

  export type RolesCreateNestedOneWithoutAdmin_rolesInput = {
    create?: XOR<RolesCreateWithoutAdmin_rolesInput, RolesUncheckedCreateWithoutAdmin_rolesInput>
    connectOrCreate?: RolesCreateOrConnectWithoutAdmin_rolesInput
    connect?: RolesWhereUniqueInput
  }

  export type AdminsUpdateOneWithoutAdmin_rolesNestedInput = {
    create?: XOR<AdminsCreateWithoutAdmin_rolesInput, AdminsUncheckedCreateWithoutAdmin_rolesInput>
    connectOrCreate?: AdminsCreateOrConnectWithoutAdmin_rolesInput
    upsert?: AdminsUpsertWithoutAdmin_rolesInput
    disconnect?: AdminsWhereInput | boolean
    delete?: AdminsWhereInput | boolean
    connect?: AdminsWhereUniqueInput
    update?: XOR<XOR<AdminsUpdateToOneWithWhereWithoutAdmin_rolesInput, AdminsUpdateWithoutAdmin_rolesInput>, AdminsUncheckedUpdateWithoutAdmin_rolesInput>
  }

  export type RolesUpdateOneWithoutAdmin_rolesNestedInput = {
    create?: XOR<RolesCreateWithoutAdmin_rolesInput, RolesUncheckedCreateWithoutAdmin_rolesInput>
    connectOrCreate?: RolesCreateOrConnectWithoutAdmin_rolesInput
    upsert?: RolesUpsertWithoutAdmin_rolesInput
    disconnect?: RolesWhereInput | boolean
    delete?: RolesWhereInput | boolean
    connect?: RolesWhereUniqueInput
    update?: XOR<XOR<RolesUpdateToOneWithWhereWithoutAdmin_rolesInput, RolesUpdateWithoutAdmin_rolesInput>, RolesUncheckedUpdateWithoutAdmin_rolesInput>
  }

  export type UsersCreateNestedOneWithoutUser_cardInput = {
    create?: XOR<UsersCreateWithoutUser_cardInput, UsersUncheckedCreateWithoutUser_cardInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUser_cardInput
    connect?: UsersWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutUserCardInput = {
    create?: XOR<PaymentCreateWithoutUserCardInput, PaymentUncheckedCreateWithoutUserCardInput> | PaymentCreateWithoutUserCardInput[] | PaymentUncheckedCreateWithoutUserCardInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserCardInput | PaymentCreateOrConnectWithoutUserCardInput[]
    createMany?: PaymentCreateManyUserCardInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserCardInput = {
    create?: XOR<PaymentCreateWithoutUserCardInput, PaymentUncheckedCreateWithoutUserCardInput> | PaymentCreateWithoutUserCardInput[] | PaymentUncheckedCreateWithoutUserCardInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserCardInput | PaymentCreateOrConnectWithoutUserCardInput[]
    createMany?: PaymentCreateManyUserCardInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type UsersUpdateOneWithoutUser_cardNestedInput = {
    create?: XOR<UsersCreateWithoutUser_cardInput, UsersUncheckedCreateWithoutUser_cardInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUser_cardInput
    upsert?: UsersUpsertWithoutUser_cardInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUser_cardInput, UsersUpdateWithoutUser_cardInput>, UsersUncheckedUpdateWithoutUser_cardInput>
  }

  export type PaymentUpdateManyWithoutUserCardNestedInput = {
    create?: XOR<PaymentCreateWithoutUserCardInput, PaymentUncheckedCreateWithoutUserCardInput> | PaymentCreateWithoutUserCardInput[] | PaymentUncheckedCreateWithoutUserCardInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserCardInput | PaymentCreateOrConnectWithoutUserCardInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserCardInput | PaymentUpsertWithWhereUniqueWithoutUserCardInput[]
    createMany?: PaymentCreateManyUserCardInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserCardInput | PaymentUpdateWithWhereUniqueWithoutUserCardInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserCardInput | PaymentUpdateManyWithWhereWithoutUserCardInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserCardNestedInput = {
    create?: XOR<PaymentCreateWithoutUserCardInput, PaymentUncheckedCreateWithoutUserCardInput> | PaymentCreateWithoutUserCardInput[] | PaymentUncheckedCreateWithoutUserCardInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserCardInput | PaymentCreateOrConnectWithoutUserCardInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserCardInput | PaymentUpsertWithWhereUniqueWithoutUserCardInput[]
    createMany?: PaymentCreateManyUserCardInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserCardInput | PaymentUpdateWithWhereUniqueWithoutUserCardInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserCardInput | PaymentUpdateManyWithWhereWithoutUserCardInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutUser_addressInput = {
    create?: XOR<UsersCreateWithoutUser_addressInput, UsersUncheckedCreateWithoutUser_addressInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUser_addressInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneWithoutUser_addressNestedInput = {
    create?: XOR<UsersCreateWithoutUser_addressInput, UsersUncheckedCreateWithoutUser_addressInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUser_addressInput
    upsert?: UsersUpsertWithoutUser_addressInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUser_addressInput, UsersUpdateWithoutUser_addressInput>, UsersUncheckedUpdateWithoutUser_addressInput>
  }

  export type ContractsCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ContractsCreateWithoutSupplierInput, ContractsUncheckedCreateWithoutSupplierInput> | ContractsCreateWithoutSupplierInput[] | ContractsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ContractsCreateOrConnectWithoutSupplierInput | ContractsCreateOrConnectWithoutSupplierInput[]
    createMany?: ContractsCreateManySupplierInputEnvelope
    connect?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
  }

  export type ContractsUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ContractsCreateWithoutSupplierInput, ContractsUncheckedCreateWithoutSupplierInput> | ContractsCreateWithoutSupplierInput[] | ContractsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ContractsCreateOrConnectWithoutSupplierInput | ContractsCreateOrConnectWithoutSupplierInput[]
    createMany?: ContractsCreateManySupplierInputEnvelope
    connect?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
  }

  export type ContractsUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ContractsCreateWithoutSupplierInput, ContractsUncheckedCreateWithoutSupplierInput> | ContractsCreateWithoutSupplierInput[] | ContractsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ContractsCreateOrConnectWithoutSupplierInput | ContractsCreateOrConnectWithoutSupplierInput[]
    upsert?: ContractsUpsertWithWhereUniqueWithoutSupplierInput | ContractsUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ContractsCreateManySupplierInputEnvelope
    set?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    disconnect?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    delete?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    connect?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    update?: ContractsUpdateWithWhereUniqueWithoutSupplierInput | ContractsUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ContractsUpdateManyWithWhereWithoutSupplierInput | ContractsUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ContractsScalarWhereInput | ContractsScalarWhereInput[]
  }

  export type ContractsUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ContractsCreateWithoutSupplierInput, ContractsUncheckedCreateWithoutSupplierInput> | ContractsCreateWithoutSupplierInput[] | ContractsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ContractsCreateOrConnectWithoutSupplierInput | ContractsCreateOrConnectWithoutSupplierInput[]
    upsert?: ContractsUpsertWithWhereUniqueWithoutSupplierInput | ContractsUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ContractsCreateManySupplierInputEnvelope
    set?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    disconnect?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    delete?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    connect?: ContractsWhereUniqueInput | ContractsWhereUniqueInput[]
    update?: ContractsUpdateWithWhereUniqueWithoutSupplierInput | ContractsUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ContractsUpdateManyWithWhereWithoutSupplierInput | ContractsUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ContractsScalarWhereInput | ContractsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutPaymentInput = {
    create?: XOR<UsersCreateWithoutPaymentInput, UsersUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPaymentInput
    connect?: UsersWhereUniqueInput
  }

  export type ContractsCreateNestedOneWithoutPaymentInput = {
    create?: XOR<ContractsCreateWithoutPaymentInput, ContractsUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ContractsCreateOrConnectWithoutPaymentInput
    connect?: ContractsWhereUniqueInput
  }

  export type UserCardCreateNestedOneWithoutPaymentInput = {
    create?: XOR<UserCardCreateWithoutPaymentInput, UserCardUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: UserCardCreateOrConnectWithoutPaymentInput
    connect?: UserCardWhereUniqueInput
  }

  export type UsersUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<UsersCreateWithoutPaymentInput, UsersUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPaymentInput
    upsert?: UsersUpsertWithoutPaymentInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPaymentInput, UsersUpdateWithoutPaymentInput>, UsersUncheckedUpdateWithoutPaymentInput>
  }

  export type ContractsUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<ContractsCreateWithoutPaymentInput, ContractsUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ContractsCreateOrConnectWithoutPaymentInput
    upsert?: ContractsUpsertWithoutPaymentInput
    disconnect?: ContractsWhereInput | boolean
    delete?: ContractsWhereInput | boolean
    connect?: ContractsWhereUniqueInput
    update?: XOR<XOR<ContractsUpdateToOneWithWhereWithoutPaymentInput, ContractsUpdateWithoutPaymentInput>, ContractsUncheckedUpdateWithoutPaymentInput>
  }

  export type UserCardUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<UserCardCreateWithoutPaymentInput, UserCardUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: UserCardCreateOrConnectWithoutPaymentInput
    upsert?: UserCardUpsertWithoutPaymentInput
    disconnect?: UserCardWhereInput | boolean
    delete?: UserCardWhereInput | boolean
    connect?: UserCardWhereUniqueInput
    update?: XOR<XOR<UserCardUpdateToOneWithWhereWithoutPaymentInput, UserCardUpdateWithoutPaymentInput>, UserCardUncheckedUpdateWithoutPaymentInput>
  }

  export type UsersCreateNestedOneWithoutContractsInput = {
    create?: XOR<UsersCreateWithoutContractsInput, UsersUncheckedCreateWithoutContractsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutContractsInput
    connect?: UsersWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutContractsInput = {
    create?: XOR<SupplierCreateWithoutContractsInput, SupplierUncheckedCreateWithoutContractsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutContractsInput
    connect?: SupplierWhereUniqueInput
  }

  export type ContractsDetailingCreateNestedManyWithoutContractsInput = {
    create?: XOR<ContractsDetailingCreateWithoutContractsInput, ContractsDetailingUncheckedCreateWithoutContractsInput> | ContractsDetailingCreateWithoutContractsInput[] | ContractsDetailingUncheckedCreateWithoutContractsInput[]
    connectOrCreate?: ContractsDetailingCreateOrConnectWithoutContractsInput | ContractsDetailingCreateOrConnectWithoutContractsInput[]
    createMany?: ContractsDetailingCreateManyContractsInputEnvelope
    connect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutContractsInput = {
    create?: XOR<PaymentCreateWithoutContractsInput, PaymentUncheckedCreateWithoutContractsInput> | PaymentCreateWithoutContractsInput[] | PaymentUncheckedCreateWithoutContractsInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContractsInput | PaymentCreateOrConnectWithoutContractsInput[]
    createMany?: PaymentCreateManyContractsInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ContractsDetailingUncheckedCreateNestedManyWithoutContractsInput = {
    create?: XOR<ContractsDetailingCreateWithoutContractsInput, ContractsDetailingUncheckedCreateWithoutContractsInput> | ContractsDetailingCreateWithoutContractsInput[] | ContractsDetailingUncheckedCreateWithoutContractsInput[]
    connectOrCreate?: ContractsDetailingCreateOrConnectWithoutContractsInput | ContractsDetailingCreateOrConnectWithoutContractsInput[]
    createMany?: ContractsDetailingCreateManyContractsInputEnvelope
    connect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutContractsInput = {
    create?: XOR<PaymentCreateWithoutContractsInput, PaymentUncheckedCreateWithoutContractsInput> | PaymentCreateWithoutContractsInput[] | PaymentUncheckedCreateWithoutContractsInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContractsInput | PaymentCreateOrConnectWithoutContractsInput[]
    createMany?: PaymentCreateManyContractsInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type UsersUpdateOneWithoutContractsNestedInput = {
    create?: XOR<UsersCreateWithoutContractsInput, UsersUncheckedCreateWithoutContractsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutContractsInput
    upsert?: UsersUpsertWithoutContractsInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutContractsInput, UsersUpdateWithoutContractsInput>, UsersUncheckedUpdateWithoutContractsInput>
  }

  export type SupplierUpdateOneWithoutContractsNestedInput = {
    create?: XOR<SupplierCreateWithoutContractsInput, SupplierUncheckedCreateWithoutContractsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutContractsInput
    upsert?: SupplierUpsertWithoutContractsInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutContractsInput, SupplierUpdateWithoutContractsInput>, SupplierUncheckedUpdateWithoutContractsInput>
  }

  export type ContractsDetailingUpdateManyWithoutContractsNestedInput = {
    create?: XOR<ContractsDetailingCreateWithoutContractsInput, ContractsDetailingUncheckedCreateWithoutContractsInput> | ContractsDetailingCreateWithoutContractsInput[] | ContractsDetailingUncheckedCreateWithoutContractsInput[]
    connectOrCreate?: ContractsDetailingCreateOrConnectWithoutContractsInput | ContractsDetailingCreateOrConnectWithoutContractsInput[]
    upsert?: ContractsDetailingUpsertWithWhereUniqueWithoutContractsInput | ContractsDetailingUpsertWithWhereUniqueWithoutContractsInput[]
    createMany?: ContractsDetailingCreateManyContractsInputEnvelope
    set?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    disconnect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    delete?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    connect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    update?: ContractsDetailingUpdateWithWhereUniqueWithoutContractsInput | ContractsDetailingUpdateWithWhereUniqueWithoutContractsInput[]
    updateMany?: ContractsDetailingUpdateManyWithWhereWithoutContractsInput | ContractsDetailingUpdateManyWithWhereWithoutContractsInput[]
    deleteMany?: ContractsDetailingScalarWhereInput | ContractsDetailingScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutContractsNestedInput = {
    create?: XOR<PaymentCreateWithoutContractsInput, PaymentUncheckedCreateWithoutContractsInput> | PaymentCreateWithoutContractsInput[] | PaymentUncheckedCreateWithoutContractsInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContractsInput | PaymentCreateOrConnectWithoutContractsInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutContractsInput | PaymentUpsertWithWhereUniqueWithoutContractsInput[]
    createMany?: PaymentCreateManyContractsInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutContractsInput | PaymentUpdateWithWhereUniqueWithoutContractsInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutContractsInput | PaymentUpdateManyWithWhereWithoutContractsInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ContractsDetailingUncheckedUpdateManyWithoutContractsNestedInput = {
    create?: XOR<ContractsDetailingCreateWithoutContractsInput, ContractsDetailingUncheckedCreateWithoutContractsInput> | ContractsDetailingCreateWithoutContractsInput[] | ContractsDetailingUncheckedCreateWithoutContractsInput[]
    connectOrCreate?: ContractsDetailingCreateOrConnectWithoutContractsInput | ContractsDetailingCreateOrConnectWithoutContractsInput[]
    upsert?: ContractsDetailingUpsertWithWhereUniqueWithoutContractsInput | ContractsDetailingUpsertWithWhereUniqueWithoutContractsInput[]
    createMany?: ContractsDetailingCreateManyContractsInputEnvelope
    set?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    disconnect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    delete?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    connect?: ContractsDetailingWhereUniqueInput | ContractsDetailingWhereUniqueInput[]
    update?: ContractsDetailingUpdateWithWhereUniqueWithoutContractsInput | ContractsDetailingUpdateWithWhereUniqueWithoutContractsInput[]
    updateMany?: ContractsDetailingUpdateManyWithWhereWithoutContractsInput | ContractsDetailingUpdateManyWithWhereWithoutContractsInput[]
    deleteMany?: ContractsDetailingScalarWhereInput | ContractsDetailingScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutContractsNestedInput = {
    create?: XOR<PaymentCreateWithoutContractsInput, PaymentUncheckedCreateWithoutContractsInput> | PaymentCreateWithoutContractsInput[] | PaymentUncheckedCreateWithoutContractsInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContractsInput | PaymentCreateOrConnectWithoutContractsInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutContractsInput | PaymentUpsertWithWhereUniqueWithoutContractsInput[]
    createMany?: PaymentCreateManyContractsInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutContractsInput | PaymentUpdateWithWhereUniqueWithoutContractsInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutContractsInput | PaymentUpdateManyWithWhereWithoutContractsInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutContracts_detailingInput = {
    create?: XOR<UsersCreateWithoutContracts_detailingInput, UsersUncheckedCreateWithoutContracts_detailingInput>
    connectOrCreate?: UsersCreateOrConnectWithoutContracts_detailingInput
    connect?: UsersWhereUniqueInput
  }

  export type FurnitureCreateNestedOneWithoutContracts_detailingInput = {
    create?: XOR<FurnitureCreateWithoutContracts_detailingInput, FurnitureUncheckedCreateWithoutContracts_detailingInput>
    connectOrCreate?: FurnitureCreateOrConnectWithoutContracts_detailingInput
    connect?: FurnitureWhereUniqueInput
  }

  export type ContractsCreateNestedOneWithoutContracts_detailingInput = {
    create?: XOR<ContractsCreateWithoutContracts_detailingInput, ContractsUncheckedCreateWithoutContracts_detailingInput>
    connectOrCreate?: ContractsCreateOrConnectWithoutContracts_detailingInput
    connect?: ContractsWhereUniqueInput
  }

  export type UsersUpdateOneWithoutContracts_detailingNestedInput = {
    create?: XOR<UsersCreateWithoutContracts_detailingInput, UsersUncheckedCreateWithoutContracts_detailingInput>
    connectOrCreate?: UsersCreateOrConnectWithoutContracts_detailingInput
    upsert?: UsersUpsertWithoutContracts_detailingInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutContracts_detailingInput, UsersUpdateWithoutContracts_detailingInput>, UsersUncheckedUpdateWithoutContracts_detailingInput>
  }

  export type FurnitureUpdateOneWithoutContracts_detailingNestedInput = {
    create?: XOR<FurnitureCreateWithoutContracts_detailingInput, FurnitureUncheckedCreateWithoutContracts_detailingInput>
    connectOrCreate?: FurnitureCreateOrConnectWithoutContracts_detailingInput
    upsert?: FurnitureUpsertWithoutContracts_detailingInput
    disconnect?: FurnitureWhereInput | boolean
    delete?: FurnitureWhereInput | boolean
    connect?: FurnitureWhereUniqueInput
    update?: XOR<XOR<FurnitureUpdateToOneWithWhereWithoutContracts_detailingInput, FurnitureUpdateWithoutContracts_detailingInput>, FurnitureUncheckedUpdateWithoutContracts_detailingInput>
  }

  export type ContractsUpdateOneWithoutContracts_detailingNestedInput = {
    create?: XOR<ContractsCreateWithoutContracts_detailingInput, ContractsUncheckedCreateWithoutContracts_detailingInput>
    connectOrCreate?: ContractsCreateOrConnectWithoutContracts_detailingInput
    upsert?: ContractsUpsertWithoutContracts_detailingInput
    disconnect?: ContractsWhereInput | boolean
    delete?: ContractsWhereInput | boolean
    connect?: ContractsWhereUniqueInput
    update?: XOR<XOR<ContractsUpdateToOneWithWhereWithoutContracts_detailingInput, ContractsUpdateWithoutContracts_detailingInput>, ContractsUncheckedUpdateWithoutContracts_detailingInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FurnitureCreateWithoutColorsInput = {
    name: string
    produced_date: string
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    Materials?: MaterialsCreateNestedOneWithoutFurnitureInput
    RoomTypes?: RoomTypesCreateNestedOneWithoutFurnitureInput
    FurnitureTypes?: FurnitureTypesCreateNestedOneWithoutFurnitureInput
    furniture_photos?: FurniturePhotosCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureUncheckedCreateWithoutColorsInput = {
    id?: number
    name: string
    produced_date: string
    materials_id?: number | null
    roomTypes_id?: number | null
    furniture_types_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureCreateOrConnectWithoutColorsInput = {
    where: FurnitureWhereUniqueInput
    create: XOR<FurnitureCreateWithoutColorsInput, FurnitureUncheckedCreateWithoutColorsInput>
  }

  export type FurnitureCreateManyColorsInputEnvelope = {
    data: FurnitureCreateManyColorsInput | FurnitureCreateManyColorsInput[]
    skipDuplicates?: boolean
  }

  export type FurnitureUpsertWithWhereUniqueWithoutColorsInput = {
    where: FurnitureWhereUniqueInput
    update: XOR<FurnitureUpdateWithoutColorsInput, FurnitureUncheckedUpdateWithoutColorsInput>
    create: XOR<FurnitureCreateWithoutColorsInput, FurnitureUncheckedCreateWithoutColorsInput>
  }

  export type FurnitureUpdateWithWhereUniqueWithoutColorsInput = {
    where: FurnitureWhereUniqueInput
    data: XOR<FurnitureUpdateWithoutColorsInput, FurnitureUncheckedUpdateWithoutColorsInput>
  }

  export type FurnitureUpdateManyWithWhereWithoutColorsInput = {
    where: FurnitureScalarWhereInput
    data: XOR<FurnitureUpdateManyMutationInput, FurnitureUncheckedUpdateManyWithoutColorsInput>
  }

  export type FurnitureScalarWhereInput = {
    AND?: FurnitureScalarWhereInput | FurnitureScalarWhereInput[]
    OR?: FurnitureScalarWhereInput[]
    NOT?: FurnitureScalarWhereInput | FurnitureScalarWhereInput[]
    id?: IntFilter<"Furniture"> | number
    name?: StringFilter<"Furniture"> | string
    produced_date?: StringFilter<"Furniture"> | string
    colors_id?: IntNullableFilter<"Furniture"> | number | null
    materials_id?: IntNullableFilter<"Furniture"> | number | null
    roomTypes_id?: IntNullableFilter<"Furniture"> | number | null
    furniture_types_id?: IntNullableFilter<"Furniture"> | number | null
    description?: StringFilter<"Furniture"> | string
    height?: DecimalFilter<"Furniture"> | Decimal | DecimalJsLike | number | string
    width?: DecimalFilter<"Furniture"> | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter<"Furniture"> | Decimal | DecimalJsLike | number | string
  }

  export type FurnitureCreateWithoutMaterialsInput = {
    name: string
    produced_date: string
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    Colors?: ColorsCreateNestedOneWithoutFurnitureInput
    RoomTypes?: RoomTypesCreateNestedOneWithoutFurnitureInput
    FurnitureTypes?: FurnitureTypesCreateNestedOneWithoutFurnitureInput
    furniture_photos?: FurniturePhotosCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureUncheckedCreateWithoutMaterialsInput = {
    id?: number
    name: string
    produced_date: string
    colors_id?: number | null
    roomTypes_id?: number | null
    furniture_types_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureCreateOrConnectWithoutMaterialsInput = {
    where: FurnitureWhereUniqueInput
    create: XOR<FurnitureCreateWithoutMaterialsInput, FurnitureUncheckedCreateWithoutMaterialsInput>
  }

  export type FurnitureCreateManyMaterialsInputEnvelope = {
    data: FurnitureCreateManyMaterialsInput | FurnitureCreateManyMaterialsInput[]
    skipDuplicates?: boolean
  }

  export type FurnitureUpsertWithWhereUniqueWithoutMaterialsInput = {
    where: FurnitureWhereUniqueInput
    update: XOR<FurnitureUpdateWithoutMaterialsInput, FurnitureUncheckedUpdateWithoutMaterialsInput>
    create: XOR<FurnitureCreateWithoutMaterialsInput, FurnitureUncheckedCreateWithoutMaterialsInput>
  }

  export type FurnitureUpdateWithWhereUniqueWithoutMaterialsInput = {
    where: FurnitureWhereUniqueInput
    data: XOR<FurnitureUpdateWithoutMaterialsInput, FurnitureUncheckedUpdateWithoutMaterialsInput>
  }

  export type FurnitureUpdateManyWithWhereWithoutMaterialsInput = {
    where: FurnitureScalarWhereInput
    data: XOR<FurnitureUpdateManyMutationInput, FurnitureUncheckedUpdateManyWithoutMaterialsInput>
  }

  export type FurnitureCreateWithoutRoomTypesInput = {
    name: string
    produced_date: string
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    Colors?: ColorsCreateNestedOneWithoutFurnitureInput
    Materials?: MaterialsCreateNestedOneWithoutFurnitureInput
    FurnitureTypes?: FurnitureTypesCreateNestedOneWithoutFurnitureInput
    furniture_photos?: FurniturePhotosCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureUncheckedCreateWithoutRoomTypesInput = {
    id?: number
    name: string
    produced_date: string
    colors_id?: number | null
    materials_id?: number | null
    furniture_types_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureCreateOrConnectWithoutRoomTypesInput = {
    where: FurnitureWhereUniqueInput
    create: XOR<FurnitureCreateWithoutRoomTypesInput, FurnitureUncheckedCreateWithoutRoomTypesInput>
  }

  export type FurnitureCreateManyRoomTypesInputEnvelope = {
    data: FurnitureCreateManyRoomTypesInput | FurnitureCreateManyRoomTypesInput[]
    skipDuplicates?: boolean
  }

  export type FurnitureUpsertWithWhereUniqueWithoutRoomTypesInput = {
    where: FurnitureWhereUniqueInput
    update: XOR<FurnitureUpdateWithoutRoomTypesInput, FurnitureUncheckedUpdateWithoutRoomTypesInput>
    create: XOR<FurnitureCreateWithoutRoomTypesInput, FurnitureUncheckedCreateWithoutRoomTypesInput>
  }

  export type FurnitureUpdateWithWhereUniqueWithoutRoomTypesInput = {
    where: FurnitureWhereUniqueInput
    data: XOR<FurnitureUpdateWithoutRoomTypesInput, FurnitureUncheckedUpdateWithoutRoomTypesInput>
  }

  export type FurnitureUpdateManyWithWhereWithoutRoomTypesInput = {
    where: FurnitureScalarWhereInput
    data: XOR<FurnitureUpdateManyMutationInput, FurnitureUncheckedUpdateManyWithoutRoomTypesInput>
  }

  export type FurnitureCreateWithoutFurnitureTypesInput = {
    name: string
    produced_date: string
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    Colors?: ColorsCreateNestedOneWithoutFurnitureInput
    Materials?: MaterialsCreateNestedOneWithoutFurnitureInput
    RoomTypes?: RoomTypesCreateNestedOneWithoutFurnitureInput
    furniture_photos?: FurniturePhotosCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureUncheckedCreateWithoutFurnitureTypesInput = {
    id?: number
    name: string
    produced_date: string
    colors_id?: number | null
    materials_id?: number | null
    roomTypes_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureCreateOrConnectWithoutFurnitureTypesInput = {
    where: FurnitureWhereUniqueInput
    create: XOR<FurnitureCreateWithoutFurnitureTypesInput, FurnitureUncheckedCreateWithoutFurnitureTypesInput>
  }

  export type FurnitureCreateManyFurnitureTypesInputEnvelope = {
    data: FurnitureCreateManyFurnitureTypesInput | FurnitureCreateManyFurnitureTypesInput[]
    skipDuplicates?: boolean
  }

  export type FurnitureUpsertWithWhereUniqueWithoutFurnitureTypesInput = {
    where: FurnitureWhereUniqueInput
    update: XOR<FurnitureUpdateWithoutFurnitureTypesInput, FurnitureUncheckedUpdateWithoutFurnitureTypesInput>
    create: XOR<FurnitureCreateWithoutFurnitureTypesInput, FurnitureUncheckedCreateWithoutFurnitureTypesInput>
  }

  export type FurnitureUpdateWithWhereUniqueWithoutFurnitureTypesInput = {
    where: FurnitureWhereUniqueInput
    data: XOR<FurnitureUpdateWithoutFurnitureTypesInput, FurnitureUncheckedUpdateWithoutFurnitureTypesInput>
  }

  export type FurnitureUpdateManyWithWhereWithoutFurnitureTypesInput = {
    where: FurnitureScalarWhereInput
    data: XOR<FurnitureUpdateManyMutationInput, FurnitureUncheckedUpdateManyWithoutFurnitureTypesInput>
  }

  export type FurnitureCreateWithoutFurniture_photosInput = {
    name: string
    produced_date: string
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    Colors?: ColorsCreateNestedOneWithoutFurnitureInput
    Materials?: MaterialsCreateNestedOneWithoutFurnitureInput
    RoomTypes?: RoomTypesCreateNestedOneWithoutFurnitureInput
    FurnitureTypes?: FurnitureTypesCreateNestedOneWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureUncheckedCreateWithoutFurniture_photosInput = {
    id?: number
    name: string
    produced_date: string
    colors_id?: number | null
    materials_id?: number | null
    roomTypes_id?: number | null
    furniture_types_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureCreateOrConnectWithoutFurniture_photosInput = {
    where: FurnitureWhereUniqueInput
    create: XOR<FurnitureCreateWithoutFurniture_photosInput, FurnitureUncheckedCreateWithoutFurniture_photosInput>
  }

  export type FurnitureUpsertWithoutFurniture_photosInput = {
    update: XOR<FurnitureUpdateWithoutFurniture_photosInput, FurnitureUncheckedUpdateWithoutFurniture_photosInput>
    create: XOR<FurnitureCreateWithoutFurniture_photosInput, FurnitureUncheckedCreateWithoutFurniture_photosInput>
    where?: FurnitureWhereInput
  }

  export type FurnitureUpdateToOneWithWhereWithoutFurniture_photosInput = {
    where?: FurnitureWhereInput
    data: XOR<FurnitureUpdateWithoutFurniture_photosInput, FurnitureUncheckedUpdateWithoutFurniture_photosInput>
  }

  export type FurnitureUpdateWithoutFurniture_photosInput = {
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Colors?: ColorsUpdateOneWithoutFurnitureNestedInput
    Materials?: MaterialsUpdateOneWithoutFurnitureNestedInput
    RoomTypes?: RoomTypesUpdateOneWithoutFurnitureNestedInput
    FurnitureTypes?: FurnitureTypesUpdateOneWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateWithoutFurniture_photosInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    colors_id?: NullableIntFieldUpdateOperationsInput | number | null
    materials_id?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypes_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_types_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutFurnitureNestedInput
  }

  export type ColorsCreateWithoutFurnitureInput = {
    name: string
  }

  export type ColorsUncheckedCreateWithoutFurnitureInput = {
    id?: number
    name: string
  }

  export type ColorsCreateOrConnectWithoutFurnitureInput = {
    where: ColorsWhereUniqueInput
    create: XOR<ColorsCreateWithoutFurnitureInput, ColorsUncheckedCreateWithoutFurnitureInput>
  }

  export type MaterialsCreateWithoutFurnitureInput = {
    name: string
  }

  export type MaterialsUncheckedCreateWithoutFurnitureInput = {
    id?: number
    name: string
  }

  export type MaterialsCreateOrConnectWithoutFurnitureInput = {
    where: MaterialsWhereUniqueInput
    create: XOR<MaterialsCreateWithoutFurnitureInput, MaterialsUncheckedCreateWithoutFurnitureInput>
  }

  export type RoomTypesCreateWithoutFurnitureInput = {
    name: string
  }

  export type RoomTypesUncheckedCreateWithoutFurnitureInput = {
    id?: number
    name: string
  }

  export type RoomTypesCreateOrConnectWithoutFurnitureInput = {
    where: RoomTypesWhereUniqueInput
    create: XOR<RoomTypesCreateWithoutFurnitureInput, RoomTypesUncheckedCreateWithoutFurnitureInput>
  }

  export type FurnitureTypesCreateWithoutFurnitureInput = {
    name: string
  }

  export type FurnitureTypesUncheckedCreateWithoutFurnitureInput = {
    id?: number
    name: string
  }

  export type FurnitureTypesCreateOrConnectWithoutFurnitureInput = {
    where: FurnitureTypesWhereUniqueInput
    create: XOR<FurnitureTypesCreateWithoutFurnitureInput, FurnitureTypesUncheckedCreateWithoutFurnitureInput>
  }

  export type FurniturePhotosCreateWithoutFurnitureInput = {
    url: string
    caption: string
  }

  export type FurniturePhotosUncheckedCreateWithoutFurnitureInput = {
    id?: number
    url: string
    caption: string
  }

  export type FurniturePhotosCreateOrConnectWithoutFurnitureInput = {
    where: FurniturePhotosWhereUniqueInput
    create: XOR<FurniturePhotosCreateWithoutFurnitureInput, FurniturePhotosUncheckedCreateWithoutFurnitureInput>
  }

  export type FurniturePhotosCreateManyFurnitureInputEnvelope = {
    data: FurniturePhotosCreateManyFurnitureInput | FurniturePhotosCreateManyFurnitureInput[]
    skipDuplicates?: boolean
  }

  export type FurnitureCommentsCreateWithoutFurnitureInput = {
    user_comment: string
    Users?: UsersCreateNestedOneWithoutFurniture_commentsInput
  }

  export type FurnitureCommentsUncheckedCreateWithoutFurnitureInput = {
    id?: number
    users_id?: number | null
    user_comment: string
  }

  export type FurnitureCommentsCreateOrConnectWithoutFurnitureInput = {
    where: FurnitureCommentsWhereUniqueInput
    create: XOR<FurnitureCommentsCreateWithoutFurnitureInput, FurnitureCommentsUncheckedCreateWithoutFurnitureInput>
  }

  export type FurnitureCommentsCreateManyFurnitureInputEnvelope = {
    data: FurnitureCommentsCreateManyFurnitureInput | FurnitureCommentsCreateManyFurnitureInput[]
    skipDuplicates?: boolean
  }

  export type FurnitureLikesCreateWithoutFurnitureInput = {
    Users?: UsersCreateNestedOneWithoutFurniture_likesInput
  }

  export type FurnitureLikesUncheckedCreateWithoutFurnitureInput = {
    id?: number
    users_id?: number | null
  }

  export type FurnitureLikesCreateOrConnectWithoutFurnitureInput = {
    where: FurnitureLikesWhereUniqueInput
    create: XOR<FurnitureLikesCreateWithoutFurnitureInput, FurnitureLikesUncheckedCreateWithoutFurnitureInput>
  }

  export type FurnitureLikesCreateManyFurnitureInputEnvelope = {
    data: FurnitureLikesCreateManyFurnitureInput | FurnitureLikesCreateManyFurnitureInput[]
    skipDuplicates?: boolean
  }

  export type ContractsDetailingCreateWithoutFurnitureInput = {
    count: number
    total_price: Decimal | DecimalJsLike | number | string
    contract_date: string
    Users?: UsersCreateNestedOneWithoutContracts_detailingInput
    Contracts?: ContractsCreateNestedOneWithoutContracts_detailingInput
  }

  export type ContractsDetailingUncheckedCreateWithoutFurnitureInput = {
    id?: number
    users_id?: number | null
    contracts_id?: number | null
    count: number
    total_price: Decimal | DecimalJsLike | number | string
    contract_date: string
  }

  export type ContractsDetailingCreateOrConnectWithoutFurnitureInput = {
    where: ContractsDetailingWhereUniqueInput
    create: XOR<ContractsDetailingCreateWithoutFurnitureInput, ContractsDetailingUncheckedCreateWithoutFurnitureInput>
  }

  export type ContractsDetailingCreateManyFurnitureInputEnvelope = {
    data: ContractsDetailingCreateManyFurnitureInput | ContractsDetailingCreateManyFurnitureInput[]
    skipDuplicates?: boolean
  }

  export type ColorsUpsertWithoutFurnitureInput = {
    update: XOR<ColorsUpdateWithoutFurnitureInput, ColorsUncheckedUpdateWithoutFurnitureInput>
    create: XOR<ColorsCreateWithoutFurnitureInput, ColorsUncheckedCreateWithoutFurnitureInput>
    where?: ColorsWhereInput
  }

  export type ColorsUpdateToOneWithWhereWithoutFurnitureInput = {
    where?: ColorsWhereInput
    data: XOR<ColorsUpdateWithoutFurnitureInput, ColorsUncheckedUpdateWithoutFurnitureInput>
  }

  export type ColorsUpdateWithoutFurnitureInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ColorsUncheckedUpdateWithoutFurnitureInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialsUpsertWithoutFurnitureInput = {
    update: XOR<MaterialsUpdateWithoutFurnitureInput, MaterialsUncheckedUpdateWithoutFurnitureInput>
    create: XOR<MaterialsCreateWithoutFurnitureInput, MaterialsUncheckedCreateWithoutFurnitureInput>
    where?: MaterialsWhereInput
  }

  export type MaterialsUpdateToOneWithWhereWithoutFurnitureInput = {
    where?: MaterialsWhereInput
    data: XOR<MaterialsUpdateWithoutFurnitureInput, MaterialsUncheckedUpdateWithoutFurnitureInput>
  }

  export type MaterialsUpdateWithoutFurnitureInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialsUncheckedUpdateWithoutFurnitureInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoomTypesUpsertWithoutFurnitureInput = {
    update: XOR<RoomTypesUpdateWithoutFurnitureInput, RoomTypesUncheckedUpdateWithoutFurnitureInput>
    create: XOR<RoomTypesCreateWithoutFurnitureInput, RoomTypesUncheckedCreateWithoutFurnitureInput>
    where?: RoomTypesWhereInput
  }

  export type RoomTypesUpdateToOneWithWhereWithoutFurnitureInput = {
    where?: RoomTypesWhereInput
    data: XOR<RoomTypesUpdateWithoutFurnitureInput, RoomTypesUncheckedUpdateWithoutFurnitureInput>
  }

  export type RoomTypesUpdateWithoutFurnitureInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoomTypesUncheckedUpdateWithoutFurnitureInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureTypesUpsertWithoutFurnitureInput = {
    update: XOR<FurnitureTypesUpdateWithoutFurnitureInput, FurnitureTypesUncheckedUpdateWithoutFurnitureInput>
    create: XOR<FurnitureTypesCreateWithoutFurnitureInput, FurnitureTypesUncheckedCreateWithoutFurnitureInput>
    where?: FurnitureTypesWhereInput
  }

  export type FurnitureTypesUpdateToOneWithWhereWithoutFurnitureInput = {
    where?: FurnitureTypesWhereInput
    data: XOR<FurnitureTypesUpdateWithoutFurnitureInput, FurnitureTypesUncheckedUpdateWithoutFurnitureInput>
  }

  export type FurnitureTypesUpdateWithoutFurnitureInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureTypesUncheckedUpdateWithoutFurnitureInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FurniturePhotosUpsertWithWhereUniqueWithoutFurnitureInput = {
    where: FurniturePhotosWhereUniqueInput
    update: XOR<FurniturePhotosUpdateWithoutFurnitureInput, FurniturePhotosUncheckedUpdateWithoutFurnitureInput>
    create: XOR<FurniturePhotosCreateWithoutFurnitureInput, FurniturePhotosUncheckedCreateWithoutFurnitureInput>
  }

  export type FurniturePhotosUpdateWithWhereUniqueWithoutFurnitureInput = {
    where: FurniturePhotosWhereUniqueInput
    data: XOR<FurniturePhotosUpdateWithoutFurnitureInput, FurniturePhotosUncheckedUpdateWithoutFurnitureInput>
  }

  export type FurniturePhotosUpdateManyWithWhereWithoutFurnitureInput = {
    where: FurniturePhotosScalarWhereInput
    data: XOR<FurniturePhotosUpdateManyMutationInput, FurniturePhotosUncheckedUpdateManyWithoutFurnitureInput>
  }

  export type FurniturePhotosScalarWhereInput = {
    AND?: FurniturePhotosScalarWhereInput | FurniturePhotosScalarWhereInput[]
    OR?: FurniturePhotosScalarWhereInput[]
    NOT?: FurniturePhotosScalarWhereInput | FurniturePhotosScalarWhereInput[]
    id?: IntFilter<"FurniturePhotos"> | number
    furniture_id?: IntNullableFilter<"FurniturePhotos"> | number | null
    url?: StringFilter<"FurniturePhotos"> | string
    caption?: StringFilter<"FurniturePhotos"> | string
  }

  export type FurnitureCommentsUpsertWithWhereUniqueWithoutFurnitureInput = {
    where: FurnitureCommentsWhereUniqueInput
    update: XOR<FurnitureCommentsUpdateWithoutFurnitureInput, FurnitureCommentsUncheckedUpdateWithoutFurnitureInput>
    create: XOR<FurnitureCommentsCreateWithoutFurnitureInput, FurnitureCommentsUncheckedCreateWithoutFurnitureInput>
  }

  export type FurnitureCommentsUpdateWithWhereUniqueWithoutFurnitureInput = {
    where: FurnitureCommentsWhereUniqueInput
    data: XOR<FurnitureCommentsUpdateWithoutFurnitureInput, FurnitureCommentsUncheckedUpdateWithoutFurnitureInput>
  }

  export type FurnitureCommentsUpdateManyWithWhereWithoutFurnitureInput = {
    where: FurnitureCommentsScalarWhereInput
    data: XOR<FurnitureCommentsUpdateManyMutationInput, FurnitureCommentsUncheckedUpdateManyWithoutFurnitureInput>
  }

  export type FurnitureCommentsScalarWhereInput = {
    AND?: FurnitureCommentsScalarWhereInput | FurnitureCommentsScalarWhereInput[]
    OR?: FurnitureCommentsScalarWhereInput[]
    NOT?: FurnitureCommentsScalarWhereInput | FurnitureCommentsScalarWhereInput[]
    id?: IntFilter<"FurnitureComments"> | number
    users_id?: IntNullableFilter<"FurnitureComments"> | number | null
    furniture_id?: IntNullableFilter<"FurnitureComments"> | number | null
    user_comment?: StringFilter<"FurnitureComments"> | string
  }

  export type FurnitureLikesUpsertWithWhereUniqueWithoutFurnitureInput = {
    where: FurnitureLikesWhereUniqueInput
    update: XOR<FurnitureLikesUpdateWithoutFurnitureInput, FurnitureLikesUncheckedUpdateWithoutFurnitureInput>
    create: XOR<FurnitureLikesCreateWithoutFurnitureInput, FurnitureLikesUncheckedCreateWithoutFurnitureInput>
  }

  export type FurnitureLikesUpdateWithWhereUniqueWithoutFurnitureInput = {
    where: FurnitureLikesWhereUniqueInput
    data: XOR<FurnitureLikesUpdateWithoutFurnitureInput, FurnitureLikesUncheckedUpdateWithoutFurnitureInput>
  }

  export type FurnitureLikesUpdateManyWithWhereWithoutFurnitureInput = {
    where: FurnitureLikesScalarWhereInput
    data: XOR<FurnitureLikesUpdateManyMutationInput, FurnitureLikesUncheckedUpdateManyWithoutFurnitureInput>
  }

  export type FurnitureLikesScalarWhereInput = {
    AND?: FurnitureLikesScalarWhereInput | FurnitureLikesScalarWhereInput[]
    OR?: FurnitureLikesScalarWhereInput[]
    NOT?: FurnitureLikesScalarWhereInput | FurnitureLikesScalarWhereInput[]
    id?: IntFilter<"FurnitureLikes"> | number
    users_id?: IntNullableFilter<"FurnitureLikes"> | number | null
    furniture_id?: IntNullableFilter<"FurnitureLikes"> | number | null
  }

  export type ContractsDetailingUpsertWithWhereUniqueWithoutFurnitureInput = {
    where: ContractsDetailingWhereUniqueInput
    update: XOR<ContractsDetailingUpdateWithoutFurnitureInput, ContractsDetailingUncheckedUpdateWithoutFurnitureInput>
    create: XOR<ContractsDetailingCreateWithoutFurnitureInput, ContractsDetailingUncheckedCreateWithoutFurnitureInput>
  }

  export type ContractsDetailingUpdateWithWhereUniqueWithoutFurnitureInput = {
    where: ContractsDetailingWhereUniqueInput
    data: XOR<ContractsDetailingUpdateWithoutFurnitureInput, ContractsDetailingUncheckedUpdateWithoutFurnitureInput>
  }

  export type ContractsDetailingUpdateManyWithWhereWithoutFurnitureInput = {
    where: ContractsDetailingScalarWhereInput
    data: XOR<ContractsDetailingUpdateManyMutationInput, ContractsDetailingUncheckedUpdateManyWithoutFurnitureInput>
  }

  export type ContractsDetailingScalarWhereInput = {
    AND?: ContractsDetailingScalarWhereInput | ContractsDetailingScalarWhereInput[]
    OR?: ContractsDetailingScalarWhereInput[]
    NOT?: ContractsDetailingScalarWhereInput | ContractsDetailingScalarWhereInput[]
    id?: IntFilter<"ContractsDetailing"> | number
    users_id?: IntNullableFilter<"ContractsDetailing"> | number | null
    furniture_id?: IntNullableFilter<"ContractsDetailing"> | number | null
    contracts_id?: IntNullableFilter<"ContractsDetailing"> | number | null
    count?: IntFilter<"ContractsDetailing"> | number
    total_price?: DecimalFilter<"ContractsDetailing"> | Decimal | DecimalJsLike | number | string
    contract_date?: StringFilter<"ContractsDetailing"> | string
  }

  export type FurnitureCommentsCreateWithoutUsersInput = {
    user_comment: string
    Furniture?: FurnitureCreateNestedOneWithoutFurniture_commentsInput
  }

  export type FurnitureCommentsUncheckedCreateWithoutUsersInput = {
    id?: number
    furniture_id?: number | null
    user_comment: string
  }

  export type FurnitureCommentsCreateOrConnectWithoutUsersInput = {
    where: FurnitureCommentsWhereUniqueInput
    create: XOR<FurnitureCommentsCreateWithoutUsersInput, FurnitureCommentsUncheckedCreateWithoutUsersInput>
  }

  export type FurnitureCommentsCreateManyUsersInputEnvelope = {
    data: FurnitureCommentsCreateManyUsersInput | FurnitureCommentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type FurnitureLikesCreateWithoutUsersInput = {
    Furniture?: FurnitureCreateNestedOneWithoutFurniture_likesInput
  }

  export type FurnitureLikesUncheckedCreateWithoutUsersInput = {
    id?: number
    furniture_id?: number | null
  }

  export type FurnitureLikesCreateOrConnectWithoutUsersInput = {
    where: FurnitureLikesWhereUniqueInput
    create: XOR<FurnitureLikesCreateWithoutUsersInput, FurnitureLikesUncheckedCreateWithoutUsersInput>
  }

  export type FurnitureLikesCreateManyUsersInputEnvelope = {
    data: FurnitureLikesCreateManyUsersInput | FurnitureLikesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type UserCardCreateWithoutUsersInput = {
    card_number: string
    card_expiration: string
    phone_number: string
    payment?: PaymentCreateNestedManyWithoutUserCardInput
  }

  export type UserCardUncheckedCreateWithoutUsersInput = {
    id?: number
    card_number: string
    card_expiration: string
    phone_number: string
    payment?: PaymentUncheckedCreateNestedManyWithoutUserCardInput
  }

  export type UserCardCreateOrConnectWithoutUsersInput = {
    where: UserCardWhereUniqueInput
    create: XOR<UserCardCreateWithoutUsersInput, UserCardUncheckedCreateWithoutUsersInput>
  }

  export type UserCardCreateManyUsersInputEnvelope = {
    data: UserCardCreateManyUsersInput | UserCardCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type UserAddressCreateWithoutUsersInput = {
    city: string
    area: string
    street: string
    house: string
    apartment_or_office: string
    entrance?: string | null
    floor?: number | null
    intercom_code?: string | null
  }

  export type UserAddressUncheckedCreateWithoutUsersInput = {
    id?: number
    city: string
    area: string
    street: string
    house: string
    apartment_or_office: string
    entrance?: string | null
    floor?: number | null
    intercom_code?: string | null
  }

  export type UserAddressCreateOrConnectWithoutUsersInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutUsersInput, UserAddressUncheckedCreateWithoutUsersInput>
  }

  export type UserAddressCreateManyUsersInputEnvelope = {
    data: UserAddressCreateManyUsersInput | UserAddressCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUsersInput = {
    company_card: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_status: string
    payment_date: string
    Contracts?: ContractsCreateNestedOneWithoutPaymentInput
    UserCard?: UserCardCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutUsersInput = {
    id?: number
    contracts_id?: number | null
    user_card_id?: number | null
    company_card: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_status: string
    payment_date: string
  }

  export type PaymentCreateOrConnectWithoutUsersInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUsersInput, PaymentUncheckedCreateWithoutUsersInput>
  }

  export type PaymentCreateManyUsersInputEnvelope = {
    data: PaymentCreateManyUsersInput | PaymentCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ContractsCreateWithoutUsersInput = {
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
    Supplier?: SupplierCreateNestedOneWithoutContractsInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutContractsInput
    payment?: PaymentCreateNestedManyWithoutContractsInput
  }

  export type ContractsUncheckedCreateWithoutUsersInput = {
    id?: number
    supplier_id?: number | null
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutContractsInput
    payment?: PaymentUncheckedCreateNestedManyWithoutContractsInput
  }

  export type ContractsCreateOrConnectWithoutUsersInput = {
    where: ContractsWhereUniqueInput
    create: XOR<ContractsCreateWithoutUsersInput, ContractsUncheckedCreateWithoutUsersInput>
  }

  export type ContractsCreateManyUsersInputEnvelope = {
    data: ContractsCreateManyUsersInput | ContractsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ContractsDetailingCreateWithoutUsersInput = {
    count: number
    total_price: Decimal | DecimalJsLike | number | string
    contract_date: string
    Furniture?: FurnitureCreateNestedOneWithoutContracts_detailingInput
    Contracts?: ContractsCreateNestedOneWithoutContracts_detailingInput
  }

  export type ContractsDetailingUncheckedCreateWithoutUsersInput = {
    id?: number
    furniture_id?: number | null
    contracts_id?: number | null
    count: number
    total_price: Decimal | DecimalJsLike | number | string
    contract_date: string
  }

  export type ContractsDetailingCreateOrConnectWithoutUsersInput = {
    where: ContractsDetailingWhereUniqueInput
    create: XOR<ContractsDetailingCreateWithoutUsersInput, ContractsDetailingUncheckedCreateWithoutUsersInput>
  }

  export type ContractsDetailingCreateManyUsersInputEnvelope = {
    data: ContractsDetailingCreateManyUsersInput | ContractsDetailingCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type FurnitureCommentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: FurnitureCommentsWhereUniqueInput
    update: XOR<FurnitureCommentsUpdateWithoutUsersInput, FurnitureCommentsUncheckedUpdateWithoutUsersInput>
    create: XOR<FurnitureCommentsCreateWithoutUsersInput, FurnitureCommentsUncheckedCreateWithoutUsersInput>
  }

  export type FurnitureCommentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: FurnitureCommentsWhereUniqueInput
    data: XOR<FurnitureCommentsUpdateWithoutUsersInput, FurnitureCommentsUncheckedUpdateWithoutUsersInput>
  }

  export type FurnitureCommentsUpdateManyWithWhereWithoutUsersInput = {
    where: FurnitureCommentsScalarWhereInput
    data: XOR<FurnitureCommentsUpdateManyMutationInput, FurnitureCommentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type FurnitureLikesUpsertWithWhereUniqueWithoutUsersInput = {
    where: FurnitureLikesWhereUniqueInput
    update: XOR<FurnitureLikesUpdateWithoutUsersInput, FurnitureLikesUncheckedUpdateWithoutUsersInput>
    create: XOR<FurnitureLikesCreateWithoutUsersInput, FurnitureLikesUncheckedCreateWithoutUsersInput>
  }

  export type FurnitureLikesUpdateWithWhereUniqueWithoutUsersInput = {
    where: FurnitureLikesWhereUniqueInput
    data: XOR<FurnitureLikesUpdateWithoutUsersInput, FurnitureLikesUncheckedUpdateWithoutUsersInput>
  }

  export type FurnitureLikesUpdateManyWithWhereWithoutUsersInput = {
    where: FurnitureLikesScalarWhereInput
    data: XOR<FurnitureLikesUpdateManyMutationInput, FurnitureLikesUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserCardUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserCardWhereUniqueInput
    update: XOR<UserCardUpdateWithoutUsersInput, UserCardUncheckedUpdateWithoutUsersInput>
    create: XOR<UserCardCreateWithoutUsersInput, UserCardUncheckedCreateWithoutUsersInput>
  }

  export type UserCardUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserCardWhereUniqueInput
    data: XOR<UserCardUpdateWithoutUsersInput, UserCardUncheckedUpdateWithoutUsersInput>
  }

  export type UserCardUpdateManyWithWhereWithoutUsersInput = {
    where: UserCardScalarWhereInput
    data: XOR<UserCardUpdateManyMutationInput, UserCardUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserCardScalarWhereInput = {
    AND?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
    OR?: UserCardScalarWhereInput[]
    NOT?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
    id?: IntFilter<"UserCard"> | number
    users_id?: IntNullableFilter<"UserCard"> | number | null
    card_number?: StringFilter<"UserCard"> | string
    card_expiration?: StringFilter<"UserCard"> | string
    phone_number?: StringFilter<"UserCard"> | string
  }

  export type UserAddressUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserAddressWhereUniqueInput
    update: XOR<UserAddressUpdateWithoutUsersInput, UserAddressUncheckedUpdateWithoutUsersInput>
    create: XOR<UserAddressCreateWithoutUsersInput, UserAddressUncheckedCreateWithoutUsersInput>
  }

  export type UserAddressUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserAddressWhereUniqueInput
    data: XOR<UserAddressUpdateWithoutUsersInput, UserAddressUncheckedUpdateWithoutUsersInput>
  }

  export type UserAddressUpdateManyWithWhereWithoutUsersInput = {
    where: UserAddressScalarWhereInput
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserAddressScalarWhereInput = {
    AND?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
    OR?: UserAddressScalarWhereInput[]
    NOT?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
    id?: IntFilter<"UserAddress"> | number
    users_id?: IntFilter<"UserAddress"> | number
    city?: StringFilter<"UserAddress"> | string
    area?: StringFilter<"UserAddress"> | string
    street?: StringFilter<"UserAddress"> | string
    house?: StringFilter<"UserAddress"> | string
    apartment_or_office?: StringFilter<"UserAddress"> | string
    entrance?: StringNullableFilter<"UserAddress"> | string | null
    floor?: IntNullableFilter<"UserAddress"> | number | null
    intercom_code?: StringNullableFilter<"UserAddress"> | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutUsersInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUsersInput, PaymentUncheckedUpdateWithoutUsersInput>
    create: XOR<PaymentCreateWithoutUsersInput, PaymentUncheckedCreateWithoutUsersInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUsersInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUsersInput, PaymentUncheckedUpdateWithoutUsersInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUsersInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUsersInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    users_id?: IntNullableFilter<"Payment"> | number | null
    contracts_id?: IntNullableFilter<"Payment"> | number | null
    user_card_id?: IntNullableFilter<"Payment"> | number | null
    company_card?: StringFilter<"Payment"> | string
    payment_amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    payment_status?: StringFilter<"Payment"> | string
    payment_date?: StringFilter<"Payment"> | string
  }

  export type ContractsUpsertWithWhereUniqueWithoutUsersInput = {
    where: ContractsWhereUniqueInput
    update: XOR<ContractsUpdateWithoutUsersInput, ContractsUncheckedUpdateWithoutUsersInput>
    create: XOR<ContractsCreateWithoutUsersInput, ContractsUncheckedCreateWithoutUsersInput>
  }

  export type ContractsUpdateWithWhereUniqueWithoutUsersInput = {
    where: ContractsWhereUniqueInput
    data: XOR<ContractsUpdateWithoutUsersInput, ContractsUncheckedUpdateWithoutUsersInput>
  }

  export type ContractsUpdateManyWithWhereWithoutUsersInput = {
    where: ContractsScalarWhereInput
    data: XOR<ContractsUpdateManyMutationInput, ContractsUncheckedUpdateManyWithoutUsersInput>
  }

  export type ContractsScalarWhereInput = {
    AND?: ContractsScalarWhereInput | ContractsScalarWhereInput[]
    OR?: ContractsScalarWhereInput[]
    NOT?: ContractsScalarWhereInput | ContractsScalarWhereInput[]
    id?: IntFilter<"Contracts"> | number
    users_id?: IntNullableFilter<"Contracts"> | number | null
    supplier_id?: IntNullableFilter<"Contracts"> | number | null
    delivery_date?: StringFilter<"Contracts"> | string
    note_to_supplier?: StringNullableFilter<"Contracts"> | string | null
    hours?: StringFilter<"Contracts"> | string
    delivery_status?: StringFilter<"Contracts"> | string
  }

  export type ContractsDetailingUpsertWithWhereUniqueWithoutUsersInput = {
    where: ContractsDetailingWhereUniqueInput
    update: XOR<ContractsDetailingUpdateWithoutUsersInput, ContractsDetailingUncheckedUpdateWithoutUsersInput>
    create: XOR<ContractsDetailingCreateWithoutUsersInput, ContractsDetailingUncheckedCreateWithoutUsersInput>
  }

  export type ContractsDetailingUpdateWithWhereUniqueWithoutUsersInput = {
    where: ContractsDetailingWhereUniqueInput
    data: XOR<ContractsDetailingUpdateWithoutUsersInput, ContractsDetailingUncheckedUpdateWithoutUsersInput>
  }

  export type ContractsDetailingUpdateManyWithWhereWithoutUsersInput = {
    where: ContractsDetailingScalarWhereInput
    data: XOR<ContractsDetailingUpdateManyMutationInput, ContractsDetailingUncheckedUpdateManyWithoutUsersInput>
  }

  export type UsersCreateWithoutFurniture_commentsInput = {
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutUsersInput
    user_card?: UserCardCreateNestedManyWithoutUsersInput
    user_address?: UserAddressCreateNestedManyWithoutUsersInput
    payment?: PaymentCreateNestedManyWithoutUsersInput
    contracts?: ContractsCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutFurniture_commentsInput = {
    id?: number
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutUsersInput
    user_card?: UserCardUncheckedCreateNestedManyWithoutUsersInput
    user_address?: UserAddressUncheckedCreateNestedManyWithoutUsersInput
    payment?: PaymentUncheckedCreateNestedManyWithoutUsersInput
    contracts?: ContractsUncheckedCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutFurniture_commentsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFurniture_commentsInput, UsersUncheckedCreateWithoutFurniture_commentsInput>
  }

  export type FurnitureCreateWithoutFurniture_commentsInput = {
    name: string
    produced_date: string
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    Colors?: ColorsCreateNestedOneWithoutFurnitureInput
    Materials?: MaterialsCreateNestedOneWithoutFurnitureInput
    RoomTypes?: RoomTypesCreateNestedOneWithoutFurnitureInput
    FurnitureTypes?: FurnitureTypesCreateNestedOneWithoutFurnitureInput
    furniture_photos?: FurniturePhotosCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureUncheckedCreateWithoutFurniture_commentsInput = {
    id?: number
    name: string
    produced_date: string
    colors_id?: number | null
    materials_id?: number | null
    roomTypes_id?: number | null
    furniture_types_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureCreateOrConnectWithoutFurniture_commentsInput = {
    where: FurnitureWhereUniqueInput
    create: XOR<FurnitureCreateWithoutFurniture_commentsInput, FurnitureUncheckedCreateWithoutFurniture_commentsInput>
  }

  export type UsersUpsertWithoutFurniture_commentsInput = {
    update: XOR<UsersUpdateWithoutFurniture_commentsInput, UsersUncheckedUpdateWithoutFurniture_commentsInput>
    create: XOR<UsersCreateWithoutFurniture_commentsInput, UsersUncheckedCreateWithoutFurniture_commentsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFurniture_commentsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFurniture_commentsInput, UsersUncheckedUpdateWithoutFurniture_commentsInput>
  }

  export type UsersUpdateWithoutFurniture_commentsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_likes?: FurnitureLikesUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUpdateManyWithoutUsersNestedInput
    payment?: PaymentUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutFurniture_commentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUncheckedUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUncheckedUpdateManyWithoutUsersNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUncheckedUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type FurnitureUpsertWithoutFurniture_commentsInput = {
    update: XOR<FurnitureUpdateWithoutFurniture_commentsInput, FurnitureUncheckedUpdateWithoutFurniture_commentsInput>
    create: XOR<FurnitureCreateWithoutFurniture_commentsInput, FurnitureUncheckedCreateWithoutFurniture_commentsInput>
    where?: FurnitureWhereInput
  }

  export type FurnitureUpdateToOneWithWhereWithoutFurniture_commentsInput = {
    where?: FurnitureWhereInput
    data: XOR<FurnitureUpdateWithoutFurniture_commentsInput, FurnitureUncheckedUpdateWithoutFurniture_commentsInput>
  }

  export type FurnitureUpdateWithoutFurniture_commentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Colors?: ColorsUpdateOneWithoutFurnitureNestedInput
    Materials?: MaterialsUpdateOneWithoutFurnitureNestedInput
    RoomTypes?: RoomTypesUpdateOneWithoutFurnitureNestedInput
    FurnitureTypes?: FurnitureTypesUpdateOneWithoutFurnitureNestedInput
    furniture_photos?: FurniturePhotosUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateWithoutFurniture_commentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    colors_id?: NullableIntFieldUpdateOperationsInput | number | null
    materials_id?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypes_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_types_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutFurnitureNestedInput
  }

  export type UsersCreateWithoutFurniture_likesInput = {
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutUsersInput
    user_card?: UserCardCreateNestedManyWithoutUsersInput
    user_address?: UserAddressCreateNestedManyWithoutUsersInput
    payment?: PaymentCreateNestedManyWithoutUsersInput
    contracts?: ContractsCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutFurniture_likesInput = {
    id?: number
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutUsersInput
    user_card?: UserCardUncheckedCreateNestedManyWithoutUsersInput
    user_address?: UserAddressUncheckedCreateNestedManyWithoutUsersInput
    payment?: PaymentUncheckedCreateNestedManyWithoutUsersInput
    contracts?: ContractsUncheckedCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutFurniture_likesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFurniture_likesInput, UsersUncheckedCreateWithoutFurniture_likesInput>
  }

  export type FurnitureCreateWithoutFurniture_likesInput = {
    name: string
    produced_date: string
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    Colors?: ColorsCreateNestedOneWithoutFurnitureInput
    Materials?: MaterialsCreateNestedOneWithoutFurnitureInput
    RoomTypes?: RoomTypesCreateNestedOneWithoutFurnitureInput
    FurnitureTypes?: FurnitureTypesCreateNestedOneWithoutFurnitureInput
    furniture_photos?: FurniturePhotosCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureUncheckedCreateWithoutFurniture_likesInput = {
    id?: number
    name: string
    produced_date: string
    colors_id?: number | null
    materials_id?: number | null
    roomTypes_id?: number | null
    furniture_types_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutFurnitureInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureCreateOrConnectWithoutFurniture_likesInput = {
    where: FurnitureWhereUniqueInput
    create: XOR<FurnitureCreateWithoutFurniture_likesInput, FurnitureUncheckedCreateWithoutFurniture_likesInput>
  }

  export type UsersUpsertWithoutFurniture_likesInput = {
    update: XOR<UsersUpdateWithoutFurniture_likesInput, UsersUncheckedUpdateWithoutFurniture_likesInput>
    create: XOR<UsersCreateWithoutFurniture_likesInput, UsersUncheckedCreateWithoutFurniture_likesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFurniture_likesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFurniture_likesInput, UsersUncheckedUpdateWithoutFurniture_likesInput>
  }

  export type UsersUpdateWithoutFurniture_likesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUpdateManyWithoutUsersNestedInput
    payment?: PaymentUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutFurniture_likesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUncheckedUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUncheckedUpdateManyWithoutUsersNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUncheckedUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type FurnitureUpsertWithoutFurniture_likesInput = {
    update: XOR<FurnitureUpdateWithoutFurniture_likesInput, FurnitureUncheckedUpdateWithoutFurniture_likesInput>
    create: XOR<FurnitureCreateWithoutFurniture_likesInput, FurnitureUncheckedCreateWithoutFurniture_likesInput>
    where?: FurnitureWhereInput
  }

  export type FurnitureUpdateToOneWithWhereWithoutFurniture_likesInput = {
    where?: FurnitureWhereInput
    data: XOR<FurnitureUpdateWithoutFurniture_likesInput, FurnitureUncheckedUpdateWithoutFurniture_likesInput>
  }

  export type FurnitureUpdateWithoutFurniture_likesInput = {
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Colors?: ColorsUpdateOneWithoutFurnitureNestedInput
    Materials?: MaterialsUpdateOneWithoutFurnitureNestedInput
    RoomTypes?: RoomTypesUpdateOneWithoutFurnitureNestedInput
    FurnitureTypes?: FurnitureTypesUpdateOneWithoutFurnitureNestedInput
    furniture_photos?: FurniturePhotosUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateWithoutFurniture_likesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    colors_id?: NullableIntFieldUpdateOperationsInput | number | null
    materials_id?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypes_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_types_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutFurnitureNestedInput
  }

  export type AdminRolesCreateWithoutAdminsInput = {
    Roles?: RolesCreateNestedOneWithoutAdmin_rolesInput
  }

  export type AdminRolesUncheckedCreateWithoutAdminsInput = {
    id?: number
    roles_id?: number | null
  }

  export type AdminRolesCreateOrConnectWithoutAdminsInput = {
    where: AdminRolesWhereUniqueInput
    create: XOR<AdminRolesCreateWithoutAdminsInput, AdminRolesUncheckedCreateWithoutAdminsInput>
  }

  export type AdminRolesCreateManyAdminsInputEnvelope = {
    data: AdminRolesCreateManyAdminsInput | AdminRolesCreateManyAdminsInput[]
    skipDuplicates?: boolean
  }

  export type AdminRolesUpsertWithWhereUniqueWithoutAdminsInput = {
    where: AdminRolesWhereUniqueInput
    update: XOR<AdminRolesUpdateWithoutAdminsInput, AdminRolesUncheckedUpdateWithoutAdminsInput>
    create: XOR<AdminRolesCreateWithoutAdminsInput, AdminRolesUncheckedCreateWithoutAdminsInput>
  }

  export type AdminRolesUpdateWithWhereUniqueWithoutAdminsInput = {
    where: AdminRolesWhereUniqueInput
    data: XOR<AdminRolesUpdateWithoutAdminsInput, AdminRolesUncheckedUpdateWithoutAdminsInput>
  }

  export type AdminRolesUpdateManyWithWhereWithoutAdminsInput = {
    where: AdminRolesScalarWhereInput
    data: XOR<AdminRolesUpdateManyMutationInput, AdminRolesUncheckedUpdateManyWithoutAdminsInput>
  }

  export type AdminRolesScalarWhereInput = {
    AND?: AdminRolesScalarWhereInput | AdminRolesScalarWhereInput[]
    OR?: AdminRolesScalarWhereInput[]
    NOT?: AdminRolesScalarWhereInput | AdminRolesScalarWhereInput[]
    id?: IntFilter<"AdminRoles"> | number
    admins_id?: IntNullableFilter<"AdminRoles"> | number | null
    roles_id?: IntNullableFilter<"AdminRoles"> | number | null
  }

  export type AdminRolesCreateWithoutRolesInput = {
    Admins?: AdminsCreateNestedOneWithoutAdmin_rolesInput
  }

  export type AdminRolesUncheckedCreateWithoutRolesInput = {
    id?: number
    admins_id?: number | null
  }

  export type AdminRolesCreateOrConnectWithoutRolesInput = {
    where: AdminRolesWhereUniqueInput
    create: XOR<AdminRolesCreateWithoutRolesInput, AdminRolesUncheckedCreateWithoutRolesInput>
  }

  export type AdminRolesCreateManyRolesInputEnvelope = {
    data: AdminRolesCreateManyRolesInput | AdminRolesCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type AdminRolesUpsertWithWhereUniqueWithoutRolesInput = {
    where: AdminRolesWhereUniqueInput
    update: XOR<AdminRolesUpdateWithoutRolesInput, AdminRolesUncheckedUpdateWithoutRolesInput>
    create: XOR<AdminRolesCreateWithoutRolesInput, AdminRolesUncheckedCreateWithoutRolesInput>
  }

  export type AdminRolesUpdateWithWhereUniqueWithoutRolesInput = {
    where: AdminRolesWhereUniqueInput
    data: XOR<AdminRolesUpdateWithoutRolesInput, AdminRolesUncheckedUpdateWithoutRolesInput>
  }

  export type AdminRolesUpdateManyWithWhereWithoutRolesInput = {
    where: AdminRolesScalarWhereInput
    data: XOR<AdminRolesUpdateManyMutationInput, AdminRolesUncheckedUpdateManyWithoutRolesInput>
  }

  export type AdminsCreateWithoutAdmin_rolesInput = {
    full_name: string
    birth_date?: string | null
    phone_number: string
    email: string
    hashed_password?: string | null
    hashed_refresh_token?: string | null
    is_creator?: boolean
  }

  export type AdminsUncheckedCreateWithoutAdmin_rolesInput = {
    id?: number
    full_name: string
    birth_date?: string | null
    phone_number: string
    email: string
    hashed_password?: string | null
    hashed_refresh_token?: string | null
    is_creator?: boolean
  }

  export type AdminsCreateOrConnectWithoutAdmin_rolesInput = {
    where: AdminsWhereUniqueInput
    create: XOR<AdminsCreateWithoutAdmin_rolesInput, AdminsUncheckedCreateWithoutAdmin_rolesInput>
  }

  export type RolesCreateWithoutAdmin_rolesInput = {
    value: string
    description: string
  }

  export type RolesUncheckedCreateWithoutAdmin_rolesInput = {
    id?: number
    value: string
    description: string
  }

  export type RolesCreateOrConnectWithoutAdmin_rolesInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutAdmin_rolesInput, RolesUncheckedCreateWithoutAdmin_rolesInput>
  }

  export type AdminsUpsertWithoutAdmin_rolesInput = {
    update: XOR<AdminsUpdateWithoutAdmin_rolesInput, AdminsUncheckedUpdateWithoutAdmin_rolesInput>
    create: XOR<AdminsCreateWithoutAdmin_rolesInput, AdminsUncheckedCreateWithoutAdmin_rolesInput>
    where?: AdminsWhereInput
  }

  export type AdminsUpdateToOneWithWhereWithoutAdmin_rolesInput = {
    where?: AdminsWhereInput
    data: XOR<AdminsUpdateWithoutAdmin_rolesInput, AdminsUncheckedUpdateWithoutAdmin_rolesInput>
  }

  export type AdminsUpdateWithoutAdmin_rolesInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_creator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminsUncheckedUpdateWithoutAdmin_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_creator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolesUpsertWithoutAdmin_rolesInput = {
    update: XOR<RolesUpdateWithoutAdmin_rolesInput, RolesUncheckedUpdateWithoutAdmin_rolesInput>
    create: XOR<RolesCreateWithoutAdmin_rolesInput, RolesUncheckedCreateWithoutAdmin_rolesInput>
    where?: RolesWhereInput
  }

  export type RolesUpdateToOneWithWhereWithoutAdmin_rolesInput = {
    where?: RolesWhereInput
    data: XOR<RolesUpdateWithoutAdmin_rolesInput, RolesUncheckedUpdateWithoutAdmin_rolesInput>
  }

  export type RolesUpdateWithoutAdmin_rolesInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateWithoutAdmin_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type UsersCreateWithoutUser_cardInput = {
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutUsersInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutUsersInput
    user_address?: UserAddressCreateNestedManyWithoutUsersInput
    payment?: PaymentCreateNestedManyWithoutUsersInput
    contracts?: ContractsCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUser_cardInput = {
    id?: number
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutUsersInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutUsersInput
    user_address?: UserAddressUncheckedCreateNestedManyWithoutUsersInput
    payment?: PaymentUncheckedCreateNestedManyWithoutUsersInput
    contracts?: ContractsUncheckedCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUser_cardInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUser_cardInput, UsersUncheckedCreateWithoutUser_cardInput>
  }

  export type PaymentCreateWithoutUserCardInput = {
    company_card: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_status: string
    payment_date: string
    Users?: UsersCreateNestedOneWithoutPaymentInput
    Contracts?: ContractsCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutUserCardInput = {
    id?: number
    users_id?: number | null
    contracts_id?: number | null
    company_card: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_status: string
    payment_date: string
  }

  export type PaymentCreateOrConnectWithoutUserCardInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserCardInput, PaymentUncheckedCreateWithoutUserCardInput>
  }

  export type PaymentCreateManyUserCardInputEnvelope = {
    data: PaymentCreateManyUserCardInput | PaymentCreateManyUserCardInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutUser_cardInput = {
    update: XOR<UsersUpdateWithoutUser_cardInput, UsersUncheckedUpdateWithoutUser_cardInput>
    create: XOR<UsersCreateWithoutUser_cardInput, UsersUncheckedCreateWithoutUser_cardInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUser_cardInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUser_cardInput, UsersUncheckedUpdateWithoutUser_cardInput>
  }

  export type UsersUpdateWithoutUser_cardInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUpdateManyWithoutUsersNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUpdateManyWithoutUsersNestedInput
    payment?: PaymentUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUser_cardInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutUsersNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUncheckedUpdateManyWithoutUsersNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUncheckedUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserCardInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserCardInput, PaymentUncheckedUpdateWithoutUserCardInput>
    create: XOR<PaymentCreateWithoutUserCardInput, PaymentUncheckedCreateWithoutUserCardInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserCardInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserCardInput, PaymentUncheckedUpdateWithoutUserCardInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserCardInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserCardInput>
  }

  export type UsersCreateWithoutUser_addressInput = {
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutUsersInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutUsersInput
    user_card?: UserCardCreateNestedManyWithoutUsersInput
    payment?: PaymentCreateNestedManyWithoutUsersInput
    contracts?: ContractsCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUser_addressInput = {
    id?: number
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutUsersInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutUsersInput
    user_card?: UserCardUncheckedCreateNestedManyWithoutUsersInput
    payment?: PaymentUncheckedCreateNestedManyWithoutUsersInput
    contracts?: ContractsUncheckedCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUser_addressInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUser_addressInput, UsersUncheckedCreateWithoutUser_addressInput>
  }

  export type UsersUpsertWithoutUser_addressInput = {
    update: XOR<UsersUpdateWithoutUser_addressInput, UsersUncheckedUpdateWithoutUser_addressInput>
    create: XOR<UsersCreateWithoutUser_addressInput, UsersUncheckedCreateWithoutUser_addressInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUser_addressInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUser_addressInput, UsersUncheckedUpdateWithoutUser_addressInput>
  }

  export type UsersUpdateWithoutUser_addressInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUpdateManyWithoutUsersNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUpdateManyWithoutUsersNestedInput
    payment?: PaymentUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUser_addressInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutUsersNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUncheckedUpdateManyWithoutUsersNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUncheckedUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ContractsCreateWithoutSupplierInput = {
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
    Users?: UsersCreateNestedOneWithoutContractsInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutContractsInput
    payment?: PaymentCreateNestedManyWithoutContractsInput
  }

  export type ContractsUncheckedCreateWithoutSupplierInput = {
    id?: number
    users_id?: number | null
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutContractsInput
    payment?: PaymentUncheckedCreateNestedManyWithoutContractsInput
  }

  export type ContractsCreateOrConnectWithoutSupplierInput = {
    where: ContractsWhereUniqueInput
    create: XOR<ContractsCreateWithoutSupplierInput, ContractsUncheckedCreateWithoutSupplierInput>
  }

  export type ContractsCreateManySupplierInputEnvelope = {
    data: ContractsCreateManySupplierInput | ContractsCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ContractsUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ContractsWhereUniqueInput
    update: XOR<ContractsUpdateWithoutSupplierInput, ContractsUncheckedUpdateWithoutSupplierInput>
    create: XOR<ContractsCreateWithoutSupplierInput, ContractsUncheckedCreateWithoutSupplierInput>
  }

  export type ContractsUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ContractsWhereUniqueInput
    data: XOR<ContractsUpdateWithoutSupplierInput, ContractsUncheckedUpdateWithoutSupplierInput>
  }

  export type ContractsUpdateManyWithWhereWithoutSupplierInput = {
    where: ContractsScalarWhereInput
    data: XOR<ContractsUpdateManyMutationInput, ContractsUncheckedUpdateManyWithoutSupplierInput>
  }

  export type UsersCreateWithoutPaymentInput = {
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutUsersInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutUsersInput
    user_card?: UserCardCreateNestedManyWithoutUsersInput
    user_address?: UserAddressCreateNestedManyWithoutUsersInput
    contracts?: ContractsCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutPaymentInput = {
    id?: number
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutUsersInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutUsersInput
    user_card?: UserCardUncheckedCreateNestedManyWithoutUsersInput
    user_address?: UserAddressUncheckedCreateNestedManyWithoutUsersInput
    contracts?: ContractsUncheckedCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutPaymentInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPaymentInput, UsersUncheckedCreateWithoutPaymentInput>
  }

  export type ContractsCreateWithoutPaymentInput = {
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
    Users?: UsersCreateNestedOneWithoutContractsInput
    Supplier?: SupplierCreateNestedOneWithoutContractsInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutContractsInput
  }

  export type ContractsUncheckedCreateWithoutPaymentInput = {
    id?: number
    users_id?: number | null
    supplier_id?: number | null
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutContractsInput
  }

  export type ContractsCreateOrConnectWithoutPaymentInput = {
    where: ContractsWhereUniqueInput
    create: XOR<ContractsCreateWithoutPaymentInput, ContractsUncheckedCreateWithoutPaymentInput>
  }

  export type UserCardCreateWithoutPaymentInput = {
    card_number: string
    card_expiration: string
    phone_number: string
    Users?: UsersCreateNestedOneWithoutUser_cardInput
  }

  export type UserCardUncheckedCreateWithoutPaymentInput = {
    id?: number
    users_id?: number | null
    card_number: string
    card_expiration: string
    phone_number: string
  }

  export type UserCardCreateOrConnectWithoutPaymentInput = {
    where: UserCardWhereUniqueInput
    create: XOR<UserCardCreateWithoutPaymentInput, UserCardUncheckedCreateWithoutPaymentInput>
  }

  export type UsersUpsertWithoutPaymentInput = {
    update: XOR<UsersUpdateWithoutPaymentInput, UsersUncheckedUpdateWithoutPaymentInput>
    create: XOR<UsersCreateWithoutPaymentInput, UsersUncheckedCreateWithoutPaymentInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPaymentInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPaymentInput, UsersUncheckedUpdateWithoutPaymentInput>
  }

  export type UsersUpdateWithoutPaymentInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUpdateManyWithoutUsersNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutUsersNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUncheckedUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUncheckedUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUncheckedUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ContractsUpsertWithoutPaymentInput = {
    update: XOR<ContractsUpdateWithoutPaymentInput, ContractsUncheckedUpdateWithoutPaymentInput>
    create: XOR<ContractsCreateWithoutPaymentInput, ContractsUncheckedCreateWithoutPaymentInput>
    where?: ContractsWhereInput
  }

  export type ContractsUpdateToOneWithWhereWithoutPaymentInput = {
    where?: ContractsWhereInput
    data: XOR<ContractsUpdateWithoutPaymentInput, ContractsUncheckedUpdateWithoutPaymentInput>
  }

  export type ContractsUpdateWithoutPaymentInput = {
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutContractsNestedInput
    Supplier?: SupplierUpdateOneWithoutContractsNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutContractsNestedInput
  }

  export type ContractsUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutContractsNestedInput
  }

  export type UserCardUpsertWithoutPaymentInput = {
    update: XOR<UserCardUpdateWithoutPaymentInput, UserCardUncheckedUpdateWithoutPaymentInput>
    create: XOR<UserCardCreateWithoutPaymentInput, UserCardUncheckedCreateWithoutPaymentInput>
    where?: UserCardWhereInput
  }

  export type UserCardUpdateToOneWithWhereWithoutPaymentInput = {
    where?: UserCardWhereInput
    data: XOR<UserCardUpdateWithoutPaymentInput, UserCardUncheckedUpdateWithoutPaymentInput>
  }

  export type UserCardUpdateWithoutPaymentInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    card_expiration?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutUser_cardNestedInput
  }

  export type UserCardUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    card_number?: StringFieldUpdateOperationsInput | string
    card_expiration?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
  }

  export type UsersCreateWithoutContractsInput = {
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutUsersInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutUsersInput
    user_card?: UserCardCreateNestedManyWithoutUsersInput
    user_address?: UserAddressCreateNestedManyWithoutUsersInput
    payment?: PaymentCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutContractsInput = {
    id?: number
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutUsersInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutUsersInput
    user_card?: UserCardUncheckedCreateNestedManyWithoutUsersInput
    user_address?: UserAddressUncheckedCreateNestedManyWithoutUsersInput
    payment?: PaymentUncheckedCreateNestedManyWithoutUsersInput
    contracts_detailing?: ContractsDetailingUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutContractsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutContractsInput, UsersUncheckedCreateWithoutContractsInput>
  }

  export type SupplierCreateWithoutContractsInput = {
    full_name: string
    phone_number_1: string
    phone_number_2: string
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    car_name: string
    car_number: string
    car_size: string
  }

  export type SupplierUncheckedCreateWithoutContractsInput = {
    id?: number
    full_name: string
    phone_number_1: string
    phone_number_2: string
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    car_name: string
    car_number: string
    car_size: string
  }

  export type SupplierCreateOrConnectWithoutContractsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutContractsInput, SupplierUncheckedCreateWithoutContractsInput>
  }

  export type ContractsDetailingCreateWithoutContractsInput = {
    count: number
    total_price: Decimal | DecimalJsLike | number | string
    contract_date: string
    Users?: UsersCreateNestedOneWithoutContracts_detailingInput
    Furniture?: FurnitureCreateNestedOneWithoutContracts_detailingInput
  }

  export type ContractsDetailingUncheckedCreateWithoutContractsInput = {
    id?: number
    users_id?: number | null
    furniture_id?: number | null
    count: number
    total_price: Decimal | DecimalJsLike | number | string
    contract_date: string
  }

  export type ContractsDetailingCreateOrConnectWithoutContractsInput = {
    where: ContractsDetailingWhereUniqueInput
    create: XOR<ContractsDetailingCreateWithoutContractsInput, ContractsDetailingUncheckedCreateWithoutContractsInput>
  }

  export type ContractsDetailingCreateManyContractsInputEnvelope = {
    data: ContractsDetailingCreateManyContractsInput | ContractsDetailingCreateManyContractsInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutContractsInput = {
    company_card: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_status: string
    payment_date: string
    Users?: UsersCreateNestedOneWithoutPaymentInput
    UserCard?: UserCardCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutContractsInput = {
    id?: number
    users_id?: number | null
    user_card_id?: number | null
    company_card: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_status: string
    payment_date: string
  }

  export type PaymentCreateOrConnectWithoutContractsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutContractsInput, PaymentUncheckedCreateWithoutContractsInput>
  }

  export type PaymentCreateManyContractsInputEnvelope = {
    data: PaymentCreateManyContractsInput | PaymentCreateManyContractsInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutContractsInput = {
    update: XOR<UsersUpdateWithoutContractsInput, UsersUncheckedUpdateWithoutContractsInput>
    create: XOR<UsersCreateWithoutContractsInput, UsersUncheckedCreateWithoutContractsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutContractsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutContractsInput, UsersUncheckedUpdateWithoutContractsInput>
  }

  export type UsersUpdateWithoutContractsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUpdateManyWithoutUsersNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUpdateManyWithoutUsersNestedInput
    payment?: PaymentUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutUsersNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUncheckedUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUncheckedUpdateManyWithoutUsersNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutUsersNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type SupplierUpsertWithoutContractsInput = {
    update: XOR<SupplierUpdateWithoutContractsInput, SupplierUncheckedUpdateWithoutContractsInput>
    create: XOR<SupplierCreateWithoutContractsInput, SupplierUncheckedCreateWithoutContractsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutContractsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutContractsInput, SupplierUncheckedUpdateWithoutContractsInput>
  }

  export type SupplierUpdateWithoutContractsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number_1?: StringFieldUpdateOperationsInput | string
    phone_number_2?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    car_name?: StringFieldUpdateOperationsInput | string
    car_number?: StringFieldUpdateOperationsInput | string
    car_size?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierUncheckedUpdateWithoutContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number_1?: StringFieldUpdateOperationsInput | string
    phone_number_2?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    car_name?: StringFieldUpdateOperationsInput | string
    car_number?: StringFieldUpdateOperationsInput | string
    car_size?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsDetailingUpsertWithWhereUniqueWithoutContractsInput = {
    where: ContractsDetailingWhereUniqueInput
    update: XOR<ContractsDetailingUpdateWithoutContractsInput, ContractsDetailingUncheckedUpdateWithoutContractsInput>
    create: XOR<ContractsDetailingCreateWithoutContractsInput, ContractsDetailingUncheckedCreateWithoutContractsInput>
  }

  export type ContractsDetailingUpdateWithWhereUniqueWithoutContractsInput = {
    where: ContractsDetailingWhereUniqueInput
    data: XOR<ContractsDetailingUpdateWithoutContractsInput, ContractsDetailingUncheckedUpdateWithoutContractsInput>
  }

  export type ContractsDetailingUpdateManyWithWhereWithoutContractsInput = {
    where: ContractsDetailingScalarWhereInput
    data: XOR<ContractsDetailingUpdateManyMutationInput, ContractsDetailingUncheckedUpdateManyWithoutContractsInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutContractsInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutContractsInput, PaymentUncheckedUpdateWithoutContractsInput>
    create: XOR<PaymentCreateWithoutContractsInput, PaymentUncheckedCreateWithoutContractsInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutContractsInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutContractsInput, PaymentUncheckedUpdateWithoutContractsInput>
  }

  export type PaymentUpdateManyWithWhereWithoutContractsInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutContractsInput>
  }

  export type UsersCreateWithoutContracts_detailingInput = {
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutUsersInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutUsersInput
    user_card?: UserCardCreateNestedManyWithoutUsersInput
    user_address?: UserAddressCreateNestedManyWithoutUsersInput
    payment?: PaymentCreateNestedManyWithoutUsersInput
    contracts?: ContractsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutContracts_detailingInput = {
    id?: number
    full_name: string
    birth_date?: string | null
    phone_number?: string | null
    email: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link: string
    is_active?: boolean
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutUsersInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutUsersInput
    user_card?: UserCardUncheckedCreateNestedManyWithoutUsersInput
    user_address?: UserAddressUncheckedCreateNestedManyWithoutUsersInput
    payment?: PaymentUncheckedCreateNestedManyWithoutUsersInput
    contracts?: ContractsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutContracts_detailingInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutContracts_detailingInput, UsersUncheckedCreateWithoutContracts_detailingInput>
  }

  export type FurnitureCreateWithoutContracts_detailingInput = {
    name: string
    produced_date: string
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    Colors?: ColorsCreateNestedOneWithoutFurnitureInput
    Materials?: MaterialsCreateNestedOneWithoutFurnitureInput
    RoomTypes?: RoomTypesCreateNestedOneWithoutFurnitureInput
    FurnitureTypes?: FurnitureTypesCreateNestedOneWithoutFurnitureInput
    furniture_photos?: FurniturePhotosCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureUncheckedCreateWithoutContracts_detailingInput = {
    id?: number
    name: string
    produced_date: string
    colors_id?: number | null
    materials_id?: number | null
    roomTypes_id?: number | null
    furniture_types_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_comments?: FurnitureCommentsUncheckedCreateNestedManyWithoutFurnitureInput
    furniture_likes?: FurnitureLikesUncheckedCreateNestedManyWithoutFurnitureInput
  }

  export type FurnitureCreateOrConnectWithoutContracts_detailingInput = {
    where: FurnitureWhereUniqueInput
    create: XOR<FurnitureCreateWithoutContracts_detailingInput, FurnitureUncheckedCreateWithoutContracts_detailingInput>
  }

  export type ContractsCreateWithoutContracts_detailingInput = {
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
    Users?: UsersCreateNestedOneWithoutContractsInput
    Supplier?: SupplierCreateNestedOneWithoutContractsInput
    payment?: PaymentCreateNestedManyWithoutContractsInput
  }

  export type ContractsUncheckedCreateWithoutContracts_detailingInput = {
    id?: number
    users_id?: number | null
    supplier_id?: number | null
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
    payment?: PaymentUncheckedCreateNestedManyWithoutContractsInput
  }

  export type ContractsCreateOrConnectWithoutContracts_detailingInput = {
    where: ContractsWhereUniqueInput
    create: XOR<ContractsCreateWithoutContracts_detailingInput, ContractsUncheckedCreateWithoutContracts_detailingInput>
  }

  export type UsersUpsertWithoutContracts_detailingInput = {
    update: XOR<UsersUpdateWithoutContracts_detailingInput, UsersUncheckedUpdateWithoutContracts_detailingInput>
    create: XOR<UsersCreateWithoutContracts_detailingInput, UsersUncheckedCreateWithoutContracts_detailingInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutContracts_detailingInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutContracts_detailingInput, UsersUncheckedUpdateWithoutContracts_detailingInput>
  }

  export type UsersUpdateWithoutContracts_detailingInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUpdateManyWithoutUsersNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUpdateManyWithoutUsersNestedInput
    payment?: PaymentUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutContracts_detailingInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutUsersNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutUsersNestedInput
    user_card?: UserCardUncheckedUpdateManyWithoutUsersNestedInput
    user_address?: UserAddressUncheckedUpdateManyWithoutUsersNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutUsersNestedInput
    contracts?: ContractsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type FurnitureUpsertWithoutContracts_detailingInput = {
    update: XOR<FurnitureUpdateWithoutContracts_detailingInput, FurnitureUncheckedUpdateWithoutContracts_detailingInput>
    create: XOR<FurnitureCreateWithoutContracts_detailingInput, FurnitureUncheckedCreateWithoutContracts_detailingInput>
    where?: FurnitureWhereInput
  }

  export type FurnitureUpdateToOneWithWhereWithoutContracts_detailingInput = {
    where?: FurnitureWhereInput
    data: XOR<FurnitureUpdateWithoutContracts_detailingInput, FurnitureUncheckedUpdateWithoutContracts_detailingInput>
  }

  export type FurnitureUpdateWithoutContracts_detailingInput = {
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Colors?: ColorsUpdateOneWithoutFurnitureNestedInput
    Materials?: MaterialsUpdateOneWithoutFurnitureNestedInput
    RoomTypes?: RoomTypesUpdateOneWithoutFurnitureNestedInput
    FurnitureTypes?: FurnitureTypesUpdateOneWithoutFurnitureNestedInput
    furniture_photos?: FurniturePhotosUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateWithoutContracts_detailingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    colors_id?: NullableIntFieldUpdateOperationsInput | number | null
    materials_id?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypes_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_types_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutFurnitureNestedInput
  }

  export type ContractsUpsertWithoutContracts_detailingInput = {
    update: XOR<ContractsUpdateWithoutContracts_detailingInput, ContractsUncheckedUpdateWithoutContracts_detailingInput>
    create: XOR<ContractsCreateWithoutContracts_detailingInput, ContractsUncheckedCreateWithoutContracts_detailingInput>
    where?: ContractsWhereInput
  }

  export type ContractsUpdateToOneWithWhereWithoutContracts_detailingInput = {
    where?: ContractsWhereInput
    data: XOR<ContractsUpdateWithoutContracts_detailingInput, ContractsUncheckedUpdateWithoutContracts_detailingInput>
  }

  export type ContractsUpdateWithoutContracts_detailingInput = {
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutContractsNestedInput
    Supplier?: SupplierUpdateOneWithoutContractsNestedInput
    payment?: PaymentUpdateManyWithoutContractsNestedInput
  }

  export type ContractsUncheckedUpdateWithoutContracts_detailingInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
    payment?: PaymentUncheckedUpdateManyWithoutContractsNestedInput
  }

  export type FurnitureCreateManyColorsInput = {
    id?: number
    name: string
    produced_date: string
    materials_id?: number | null
    roomTypes_id?: number | null
    furniture_types_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
  }

  export type FurnitureUpdateWithoutColorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Materials?: MaterialsUpdateOneWithoutFurnitureNestedInput
    RoomTypes?: RoomTypesUpdateOneWithoutFurnitureNestedInput
    FurnitureTypes?: FurnitureTypesUpdateOneWithoutFurnitureNestedInput
    furniture_photos?: FurniturePhotosUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateWithoutColorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    materials_id?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypes_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_types_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateManyWithoutColorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    materials_id?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypes_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_types_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FurnitureCreateManyMaterialsInput = {
    id?: number
    name: string
    produced_date: string
    colors_id?: number | null
    roomTypes_id?: number | null
    furniture_types_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
  }

  export type FurnitureUpdateWithoutMaterialsInput = {
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Colors?: ColorsUpdateOneWithoutFurnitureNestedInput
    RoomTypes?: RoomTypesUpdateOneWithoutFurnitureNestedInput
    FurnitureTypes?: FurnitureTypesUpdateOneWithoutFurnitureNestedInput
    furniture_photos?: FurniturePhotosUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateWithoutMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    colors_id?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypes_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_types_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateManyWithoutMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    colors_id?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypes_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_types_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FurnitureCreateManyRoomTypesInput = {
    id?: number
    name: string
    produced_date: string
    colors_id?: number | null
    materials_id?: number | null
    furniture_types_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
  }

  export type FurnitureUpdateWithoutRoomTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Colors?: ColorsUpdateOneWithoutFurnitureNestedInput
    Materials?: MaterialsUpdateOneWithoutFurnitureNestedInput
    FurnitureTypes?: FurnitureTypesUpdateOneWithoutFurnitureNestedInput
    furniture_photos?: FurniturePhotosUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateWithoutRoomTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    colors_id?: NullableIntFieldUpdateOperationsInput | number | null
    materials_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_types_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateManyWithoutRoomTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    colors_id?: NullableIntFieldUpdateOperationsInput | number | null
    materials_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_types_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FurnitureCreateManyFurnitureTypesInput = {
    id?: number
    name: string
    produced_date: string
    colors_id?: number | null
    materials_id?: number | null
    roomTypes_id?: number | null
    description: string
    height: Decimal | DecimalJsLike | number | string
    width: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
  }

  export type FurnitureUpdateWithoutFurnitureTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Colors?: ColorsUpdateOneWithoutFurnitureNestedInput
    Materials?: MaterialsUpdateOneWithoutFurnitureNestedInput
    RoomTypes?: RoomTypesUpdateOneWithoutFurnitureNestedInput
    furniture_photos?: FurniturePhotosUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateWithoutFurnitureTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    colors_id?: NullableIntFieldUpdateOperationsInput | number | null
    materials_id?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypes_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    furniture_photos?: FurniturePhotosUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_comments?: FurnitureCommentsUncheckedUpdateManyWithoutFurnitureNestedInput
    furniture_likes?: FurnitureLikesUncheckedUpdateManyWithoutFurnitureNestedInput
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutFurnitureNestedInput
  }

  export type FurnitureUncheckedUpdateManyWithoutFurnitureTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    produced_date?: StringFieldUpdateOperationsInput | string
    colors_id?: NullableIntFieldUpdateOperationsInput | number | null
    materials_id?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypes_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    height?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    width?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FurniturePhotosCreateManyFurnitureInput = {
    id?: number
    url: string
    caption: string
  }

  export type FurnitureCommentsCreateManyFurnitureInput = {
    id?: number
    users_id?: number | null
    user_comment: string
  }

  export type FurnitureLikesCreateManyFurnitureInput = {
    id?: number
    users_id?: number | null
  }

  export type ContractsDetailingCreateManyFurnitureInput = {
    id?: number
    users_id?: number | null
    contracts_id?: number | null
    count: number
    total_price: Decimal | DecimalJsLike | number | string
    contract_date: string
  }

  export type FurniturePhotosUpdateWithoutFurnitureInput = {
    url?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
  }

  export type FurniturePhotosUncheckedUpdateWithoutFurnitureInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
  }

  export type FurniturePhotosUncheckedUpdateManyWithoutFurnitureInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureCommentsUpdateWithoutFurnitureInput = {
    user_comment?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutFurniture_commentsNestedInput
  }

  export type FurnitureCommentsUncheckedUpdateWithoutFurnitureInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_comment?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureCommentsUncheckedUpdateManyWithoutFurnitureInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_comment?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureLikesUpdateWithoutFurnitureInput = {
    Users?: UsersUpdateOneWithoutFurniture_likesNestedInput
  }

  export type FurnitureLikesUncheckedUpdateWithoutFurnitureInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FurnitureLikesUncheckedUpdateManyWithoutFurnitureInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractsDetailingUpdateWithoutFurnitureInput = {
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutContracts_detailingNestedInput
    Contracts?: ContractsUpdateOneWithoutContracts_detailingNestedInput
  }

  export type ContractsDetailingUncheckedUpdateWithoutFurnitureInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    contracts_id?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsDetailingUncheckedUpdateManyWithoutFurnitureInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    contracts_id?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureCommentsCreateManyUsersInput = {
    id?: number
    furniture_id?: number | null
    user_comment: string
  }

  export type FurnitureLikesCreateManyUsersInput = {
    id?: number
    furniture_id?: number | null
  }

  export type UserCardCreateManyUsersInput = {
    id?: number
    card_number: string
    card_expiration: string
    phone_number: string
  }

  export type UserAddressCreateManyUsersInput = {
    id?: number
    city: string
    area: string
    street: string
    house: string
    apartment_or_office: string
    entrance?: string | null
    floor?: number | null
    intercom_code?: string | null
  }

  export type PaymentCreateManyUsersInput = {
    id?: number
    contracts_id?: number | null
    user_card_id?: number | null
    company_card: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_status: string
    payment_date: string
  }

  export type ContractsCreateManyUsersInput = {
    id?: number
    supplier_id?: number | null
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
  }

  export type ContractsDetailingCreateManyUsersInput = {
    id?: number
    furniture_id?: number | null
    contracts_id?: number | null
    count: number
    total_price: Decimal | DecimalJsLike | number | string
    contract_date: string
  }

  export type FurnitureCommentsUpdateWithoutUsersInput = {
    user_comment?: StringFieldUpdateOperationsInput | string
    Furniture?: FurnitureUpdateOneWithoutFurniture_commentsNestedInput
  }

  export type FurnitureCommentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_comment?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureCommentsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_comment?: StringFieldUpdateOperationsInput | string
  }

  export type FurnitureLikesUpdateWithoutUsersInput = {
    Furniture?: FurnitureUpdateOneWithoutFurniture_likesNestedInput
  }

  export type FurnitureLikesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FurnitureLikesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCardUpdateWithoutUsersInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    card_expiration?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    payment?: PaymentUpdateManyWithoutUserCardNestedInput
  }

  export type UserCardUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    card_expiration?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    payment?: PaymentUncheckedUpdateManyWithoutUserCardNestedInput
  }

  export type UserCardUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    card_expiration?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
  }

  export type UserAddressUpdateWithoutUsersInput = {
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    house?: StringFieldUpdateOperationsInput | string
    apartment_or_office?: StringFieldUpdateOperationsInput | string
    entrance?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    intercom_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAddressUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    house?: StringFieldUpdateOperationsInput | string
    apartment_or_office?: StringFieldUpdateOperationsInput | string
    entrance?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    intercom_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAddressUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    house?: StringFieldUpdateOperationsInput | string
    apartment_or_office?: StringFieldUpdateOperationsInput | string
    entrance?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    intercom_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutUsersInput = {
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
    Contracts?: ContractsUpdateOneWithoutPaymentNestedInput
    UserCard?: UserCardUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    contracts_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    contracts_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsUpdateWithoutUsersInput = {
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
    Supplier?: SupplierUpdateOneWithoutContractsNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutContractsNestedInput
    payment?: PaymentUpdateManyWithoutContractsNestedInput
  }

  export type ContractsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutContractsNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutContractsNestedInput
  }

  export type ContractsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsDetailingUpdateWithoutUsersInput = {
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
    Furniture?: FurnitureUpdateOneWithoutContracts_detailingNestedInput
    Contracts?: ContractsUpdateOneWithoutContracts_detailingNestedInput
  }

  export type ContractsDetailingUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
    contracts_id?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsDetailingUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
    contracts_id?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
  }

  export type AdminRolesCreateManyAdminsInput = {
    id?: number
    roles_id?: number | null
  }

  export type AdminRolesUpdateWithoutAdminsInput = {
    Roles?: RolesUpdateOneWithoutAdmin_rolesNestedInput
  }

  export type AdminRolesUncheckedUpdateWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roles_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdminRolesUncheckedUpdateManyWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roles_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdminRolesCreateManyRolesInput = {
    id?: number
    admins_id?: number | null
  }

  export type AdminRolesUpdateWithoutRolesInput = {
    Admins?: AdminsUpdateOneWithoutAdmin_rolesNestedInput
  }

  export type AdminRolesUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    admins_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdminRolesUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    admins_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentCreateManyUserCardInput = {
    id?: number
    users_id?: number | null
    contracts_id?: number | null
    company_card: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_status: string
    payment_date: string
  }

  export type PaymentUpdateWithoutUserCardInput = {
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutPaymentNestedInput
    Contracts?: ContractsUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    contracts_id?: NullableIntFieldUpdateOperationsInput | number | null
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    contracts_id?: NullableIntFieldUpdateOperationsInput | number | null
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsCreateManySupplierInput = {
    id?: number
    users_id?: number | null
    delivery_date: string
    note_to_supplier?: string | null
    hours: string
    delivery_status: string
  }

  export type ContractsUpdateWithoutSupplierInput = {
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutContractsNestedInput
    contracts_detailing?: ContractsDetailingUpdateManyWithoutContractsNestedInput
    payment?: PaymentUpdateManyWithoutContractsNestedInput
  }

  export type ContractsUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
    contracts_detailing?: ContractsDetailingUncheckedUpdateManyWithoutContractsNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutContractsNestedInput
  }

  export type ContractsUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_date?: StringFieldUpdateOperationsInput | string
    note_to_supplier?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: StringFieldUpdateOperationsInput | string
    delivery_status?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsDetailingCreateManyContractsInput = {
    id?: number
    users_id?: number | null
    furniture_id?: number | null
    count: number
    total_price: Decimal | DecimalJsLike | number | string
    contract_date: string
  }

  export type PaymentCreateManyContractsInput = {
    id?: number
    users_id?: number | null
    user_card_id?: number | null
    company_card: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_status: string
    payment_date: string
  }

  export type ContractsDetailingUpdateWithoutContractsInput = {
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutContracts_detailingNestedInput
    Furniture?: FurnitureUpdateOneWithoutContracts_detailingNestedInput
  }

  export type ContractsDetailingUncheckedUpdateWithoutContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
  }

  export type ContractsDetailingUncheckedUpdateManyWithoutContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    furniture_id?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contract_date?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUpdateWithoutContractsInput = {
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneWithoutPaymentNestedInput
    UserCard?: UserCardUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUncheckedUpdateManyWithoutContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    users_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    company_card?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_status?: StringFieldUpdateOperationsInput | string
    payment_date?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ColorsCountOutputTypeDefaultArgs instead
     */
    export type ColorsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ColorsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialsCountOutputTypeDefaultArgs instead
     */
    export type MaterialsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomTypesCountOutputTypeDefaultArgs instead
     */
    export type RoomTypesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomTypesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FurnitureTypesCountOutputTypeDefaultArgs instead
     */
    export type FurnitureTypesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FurnitureTypesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FurnitureCountOutputTypeDefaultArgs instead
     */
    export type FurnitureCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FurnitureCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminsCountOutputTypeDefaultArgs instead
     */
    export type AdminsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesCountOutputTypeDefaultArgs instead
     */
    export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCardCountOutputTypeDefaultArgs instead
     */
    export type UserCardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractsCountOutputTypeDefaultArgs instead
     */
    export type ContractsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ColorsDefaultArgs instead
     */
    export type ColorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ColorsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialsDefaultArgs instead
     */
    export type MaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomTypesDefaultArgs instead
     */
    export type RoomTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomTypesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FurnitureTypesDefaultArgs instead
     */
    export type FurnitureTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FurnitureTypesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FurniturePhotosDefaultArgs instead
     */
    export type FurniturePhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FurniturePhotosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FurnitureDefaultArgs instead
     */
    export type FurnitureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FurnitureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersDefaultArgs instead
     */
    export type UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FurnitureCommentsDefaultArgs instead
     */
    export type FurnitureCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FurnitureCommentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FurnitureLikesDefaultArgs instead
     */
    export type FurnitureLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FurnitureLikesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminsDefaultArgs instead
     */
    export type AdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesDefaultArgs instead
     */
    export type RolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminRolesDefaultArgs instead
     */
    export type AdminRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminRolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCardDefaultArgs instead
     */
    export type UserCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAddressDefaultArgs instead
     */
    export type UserAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAddressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractsDefaultArgs instead
     */
    export type ContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractsDetailingDefaultArgs instead
     */
    export type ContractsDetailingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractsDetailingDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}